<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calm Visualiser</title>
    <style>
        /* CSS Reset */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #fff;
            user-select: none;
        }

        /* Main canvas - fills the entire viewport */
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Clock overlay - centred on screen */
        #clock-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        /* Analogue clock canvas */
        #analogue-clock {
            display: none;
            width: 400px;
            height: 400px;
        }

        /* Digital clock */
        #digital-clock {
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            font-weight: 300;
            font-size: 12vw;
            color: #fff;
            letter-spacing: 0.05em;
            font-variant-numeric: tabular-nums;
            font-feature-settings: "tnum";
            text-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
        }

        /* Settings panel - slides out from the left */
        #settings-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 280px;
            height: 100%;
            background: rgba(10, 10, 20, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 30;
            padding: 24px;
            overflow-y: auto;
        }

        #settings-panel.open {
            transform: translateX(0);
        }

        /* Controls container - settings gear + fullscreen button */
        #controls {
            position: absolute;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 8px;
            z-index: 20;
            transition: opacity 0.4s ease;
        }

        #controls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Settings panel internal layout */
        .settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }

        .settings-title {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.7;
        }

        .settings-close-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
            line-height: 1;
        }

        .settings-close-btn:hover {
            background: rgba(255, 255, 255, 0.18);
        }

        .settings-section {
            margin-bottom: 24px;
        }

        .settings-label {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            opacity: 0.5;
            margin-bottom: 10px;
        }

        /* Theme grid */
        .theme-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .theme-btn {
            padding: 10px 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            font-family: inherit;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }

        .theme-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
        }

        .theme-btn.active {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
        }

        /* Clock type selector */
        .clock-type-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .clock-type-btn {
            padding: 9px 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            font-family: inherit;
            cursor: pointer;
            text-align: left;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }

        .clock-type-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
        }

        .clock-type-btn.active {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
        }

        /* Opacity slider */
        .opacity-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
        }

        .opacity-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border: none;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
        }

        #opacity-value, #cycle-interval-value {
            float: right;
            opacity: 0.8;
            font-variant-numeric: tabular-nums;
        }

        /* Scene title - bottom-right corner */
        #scene-title {
            position: absolute;
            bottom: 20px;
            right: 24px;
            font-size: 4vw;
            font-weight: 300;
            letter-spacing: 4px;
            text-transform: lowercase;
            opacity: 0.18;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
    </style>
</head>
<body>
    <!-- Main rendering canvas -->
    <canvas id="canvas"></canvas>

    <!-- Clock overlay (digital, analogue, or sun/moon) -->
    <div id="clock-overlay">
        <div id="digital-clock"></div>
        <canvas id="analogue-clock" width="800" height="800"></canvas>
    </div>

    <!-- Controls: settings gear + fullscreen button -->
    <div id="controls">
        <button class="control-btn" id="btn-settings" title="Settings" aria-label="Settings">
            &#9881;
        </button>
        <button class="control-btn" id="btn-fullscreen" title="Fullscreen (F)" aria-label="Toggle fullscreen">
            &#x26F6;
        </button>
    </div>

    <!-- Settings panel (slides in from left) -->
    <div id="settings-panel">
        <div class="settings-header">
            <span class="settings-title">Settings</span>
            <button class="settings-close-btn" id="btn-close-settings" title="Close" aria-label="Close settings">&times;</button>
        </div>

        <div class="settings-section">
            <div class="settings-label">Theme</div>
            <div class="theme-grid">
                <button class="theme-btn active" data-theme="watery">Watery</button>
                <button class="theme-btn" data-theme="sandy">Sandy</button>
                <button class="theme-btn" data-theme="snowy">Snowy</button>
                <button class="theme-btn" data-theme="wavey">Wavey</button>
                <button class="theme-btn" data-theme="spacey">Spacey</button>
                <button class="theme-btn" data-theme="colourful">Colourful</button>
                <button class="theme-btn" data-theme="windy">Windy</button>
                <button class="theme-btn" data-theme="stormy">Stormy</button>
                <button class="theme-btn" data-theme="sunny">Sunny</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Solar System</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="mercurial">Mercurial</button>
                <button class="theme-btn" data-theme="venusian">Venusian</button>
                <button class="theme-btn" data-theme="martian">Martian</button>
                <button class="theme-btn" data-theme="jovian">Jovian</button>
                <button class="theme-btn" data-theme="saturnine">Saturnine</button>
                <button class="theme-btn" data-theme="neptunian">Neptunian</button>
                <button class="theme-btn" data-theme="europan">Europan</button>
                <button class="theme-btn" data-theme="titanesque">Titanesque</button>
                <button class="theme-btn" data-theme="ionian">Ionian</button>
                <button class="theme-btn" data-theme="enceladean">Enceladean</button>
                <button class="theme-btn" data-theme="tritonian">Tritonian</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Deep Sea</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="abyssal">Abyssal</button>
                <button class="theme-btn" data-theme="coraline">Coraline</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Sky</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="auroral">Auroral</button>
                <button class="theme-btn" data-theme="twilight">Twilight</button>
                <button class="theme-btn" data-theme="misty">Misty</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Abstract</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="crystalline">Crystalline</button>
                <button class="theme-btn" data-theme="embers">Embers</button>
                <button class="theme-btn" data-theme="inkwell">Inkwell</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Exotic</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="pulsar">Pulsar</button>
                <button class="theme-btn" data-theme="nebular">Nebular</button>
                <button class="theme-btn" data-theme="binary">Binary</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Landscapes</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="volcanic">Volcanic</button>
                <button class="theme-btn" data-theme="cavern">Cavern</button>
                <button class="theme-btn" data-theme="arctic">Arctic</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Journey</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="drifting">Drifting</button>
                <button class="theme-btn" data-theme="soaring">Soaring</button>
                <button class="theme-btn" data-theme="cruising">Cruising</button>
                <button class="theme-btn" data-theme="tunnelling">Tunnelling</button>
                <button class="theme-btn" data-theme="coasting">Coasting</button>
                <button class="theme-btn" data-theme="diving">Diving</button>
                <button class="theme-btn" data-theme="ascending">Ascending</button>
                <button class="theme-btn" data-theme="wandering">Wandering</button>
                <button class="theme-btn" data-theme="sailing">Sailing</button>
                <button class="theme-btn" data-theme="streaming">Streaming</button>
                <button class="theme-btn" data-theme="voyager">Voyager</button>
                <button class="theme-btn" data-theme="odyssey">Odyssey</button>
                <button class="theme-btn" data-theme="genesis">Genesis</button>
                <button class="theme-btn" data-theme="spelunker">Spelunker</button>
                <button class="theme-btn" data-theme="freefall">Freefall</button>
                <button class="theme-btn" data-theme="timeline">Timeline</button>
                <button class="theme-btn" data-theme="apollo">Apollo</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Cataclysmic</div>
            <div class="theme-grid">
                <button class="theme-btn" data-theme="supernova">Supernova</button>
                <button class="theme-btn" data-theme="maelstrom">Maelstrom</button>
                <button class="theme-btn" data-theme="earthquake">Earthquake</button>
                <button class="theme-btn" data-theme="erupting">Erupting</button>
                <button class="theme-btn" data-theme="tornado">Tornado</button>
                <button class="theme-btn" data-theme="avalanche">Avalanche</button>
                <button class="theme-btn" data-theme="meteor">Meteor</button>
                <button class="theme-btn" data-theme="tsunami">Tsunami</button>
                <button class="theme-btn" data-theme="bolts">Bolts</button>
                <button class="theme-btn" data-theme="solarflare">Solar Flare</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Auto Cycle</div>
            <div class="auto-cycle-controls">
                <button class="clock-type-btn" id="btn-auto-cycle" aria-label="Toggle auto cycle">Off</button>
                <div class="auto-cycle-slider-row" id="cycle-interval-row" style="margin-top: 8px; display: none;">
                    <div class="settings-label">Interval <span id="cycle-interval-value">30s</span></div>
                    <input type="range" id="cycle-interval" class="opacity-slider" min="10" max="300" value="30">
                </div>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Clock</div>
            <div class="clock-type-group">
                <button class="clock-type-btn active" data-clock="digital">Digital</button>
                <button class="clock-type-btn" data-clock="analogue">Analogue</button>
                <button class="clock-type-btn" data-clock="sunmoon">Sun &amp; Moon</button>
                <button class="clock-type-btn" data-clock="none">None</button>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-label">Clock Opacity <span id="opacity-value">70%</span></div>
            <input type="range" id="clock-opacity" class="opacity-slider" min="0" max="100" value="70">
        </div>
    </div>

    <!-- Scene title in the bottom-right corner -->
    <div id="scene-title">watery</div>

    <script>
        (function () {
            // --- Named constants ---
            const HIDE_TIMEOUT = 3000;
            const TRANSITION_DURATION = 0.8;
            const ARC_SEGMENTS = 100;
            const FALLBACK_DT = 0.016;
            const MAX_DT = 0.1;
            const SHOOTING_STAR_INTERVAL_MIN = 8;
            const SHOOTING_STAR_INTERVAL_RANGE = 2;
            const LIGHTNING_INTERVAL_MIN = 6;
            const LIGHTNING_INTERVAL_RANGE = 10;
            const SHOOTING_STAR_TRAIL_MAX = 20;
            const THEME_NAMES = ['watery', 'sandy', 'snowy', 'wavey', 'spacey', 'colourful', 'windy', 'stormy', 'sunny', 'mercurial', 'venusian', 'martian', 'jovian', 'saturnine', 'neptunian', 'europan', 'titanesque', 'ionian', 'enceladean', 'tritonian', 'abyssal', 'coraline', 'auroral', 'twilight', 'misty', 'crystalline', 'embers', 'inkwell', 'pulsar', 'nebular', 'binary', 'volcanic', 'cavern', 'arctic', 'drifting', 'soaring', 'cruising', 'tunnelling', 'coasting', 'diving', 'ascending', 'wandering', 'sailing', 'streaming', 'voyager', 'odyssey', 'genesis', 'spelunker', 'freefall', 'timeline', 'apollo', 'supernova', 'maelstrom', 'earthquake', 'erupting', 'tornado', 'avalanche', 'meteor', 'tsunami', 'bolts', 'solarflare'];

            // --- Canvas setup ---
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();

            // --- Fullscreen toggle ---
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(function () {});
                } else {
                    document.exitFullscreen().catch(function () {});
                }
            }

            document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);

            // --- Settings panel & controls ---
            const controls = document.getElementById('controls');
            const settingsPanel = document.getElementById('settings-panel');
            const btnSettings = document.getElementById('btn-settings');
            const btnCloseSettings = document.getElementById('btn-close-settings');
            let hideTimeout = null;

            // --- Application state (moved before first usage) ---
            const state = {
                currentTheme: 'watery',
                timeElapsed: 0,
                particles: [],
                clockType: 'digital',
                clockOpacity: 0.7,
                autoCycle: false,
                cycleInterval: 30,
                cycleTimer: 0
            };

            // Transition state for smooth cross-fade between themes
            const transition = {
                active: false,
                progress: 0,
                duration: TRANSITION_DURATION,
                snapshotCanvas: null
            };

            function showControls() {
                controls.classList.remove('hidden');
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(function () {
                    if (!settingsPanel.classList.contains('open')) {
                        controls.classList.add('hidden');
                    }
                }, HIDE_TIMEOUT);
            }

            function openSettings() {
                settingsPanel.classList.add('open');
                controls.classList.remove('hidden');
                clearTimeout(hideTimeout);
                // Focus the close button when settings opens
                btnCloseSettings.focus();
            }

            function closeSettings() {
                settingsPanel.classList.remove('open');
                showControls();
                // Return focus to the settings gear button
                btnSettings.focus();
            }

            btnSettings.addEventListener('click', function () {
                if (settingsPanel.classList.contains('open')) {
                    closeSettings();
                } else {
                    openSettings();
                }
            });

            btnCloseSettings.addEventListener('click', closeSettings);

            // --- Consolidated keydown listener (F + Escape) ---
            document.addEventListener('keydown', function (e) {
                if (e.key === 'f' || e.key === 'F') {
                    // Don't trigger if the user is typing in an input or settings panel is open
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (settingsPanel.classList.contains('open')) return;
                    toggleFullscreen();
                }
                if (e.key === 'Escape' && settingsPanel.classList.contains('open')) {
                    closeSettings();
                }
            });

            // --- Focus trap for settings panel ---
            settingsPanel.addEventListener('keydown', function (e) {
                if (e.key !== 'Tab') return;
                const focusable = settingsPanel.querySelectorAll('button, input, [tabindex]:not([tabindex="-1"])');
                if (focusable.length === 0) return;
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                if (e.shiftKey) {
                    if (document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            });

            // --- Theme buttons ---
            const themeBtns = document.querySelectorAll('.theme-btn');
            const sceneTitle = document.getElementById('scene-title');

            function switchTheme(themeName) {
                if (themeName === state.currentTheme) return;
                state.cycleTimer = 0;

                // Capture snapshot of current frame into offscreen canvas for cross-fade
                try {
                    const snap = document.createElement('canvas');
                    snap.width = canvas.width;
                    snap.height = canvas.height;
                    snap.getContext('2d').drawImage(canvas, 0, 0);
                    transition.snapshotCanvas = snap;
                    transition.active = true;
                    transition.progress = 0;
                } catch (e) {
                    transition.active = false;
                }

                // Update active button highlight
                themeBtns.forEach(function (b) { b.classList.remove('active'); });
                const targetBtn = Array.from(themeBtns).find(function (b) { return b.dataset.theme === themeName; });
                if (targetBtn) targetBtn.classList.add('active');

                // Update scene title
                sceneTitle.textContent = themeName;

                // Re-initialise particles for the new theme
                reinitialiseParticles(themeName);

                savePreferences();
            }

            themeBtns.forEach(function (btn) {
                btn.addEventListener('click', function () {
                    switchTheme(btn.dataset.theme);
                });
            });

            // --- Clock type buttons ---
            const clockTypeBtns = document.querySelectorAll('.clock-type-group .clock-type-btn');

            clockTypeBtns.forEach(function (btn) {
                btn.addEventListener('click', function () {
                    clockTypeBtns.forEach(function (b) { b.classList.remove('active'); });
                    btn.classList.add('active');
                    state.clockType = btn.dataset.clock;
                    const now = new Date();
                    updateDigitalClock(now);
                    updateAnalogueClock(now);
                    savePreferences();
                });
            });

            // --- Clock opacity slider ---
            const opacitySlider = document.getElementById('clock-opacity');
            const opacityValue = document.getElementById('opacity-value');

            opacitySlider.addEventListener('input', function () {
                const val = parseInt(opacitySlider.value, 10);
                opacityValue.textContent = val + '%';
                state.clockOpacity = val / 100;
                const now = new Date();
                updateDigitalClock(now);
                updateAnalogueClock(now);
                savePreferences();
            });

            // --- Auto-cycle controls ---
            const btnAutoCycle = document.getElementById('btn-auto-cycle');
            const cycleIntervalRow = document.getElementById('cycle-interval-row');
            const cycleIntervalSlider = document.getElementById('cycle-interval');
            const cycleIntervalValue = document.getElementById('cycle-interval-value');

            btnAutoCycle.addEventListener('click', function () {
                state.autoCycle = !state.autoCycle;
                state.cycleTimer = 0;
                btnAutoCycle.textContent = state.autoCycle ? 'On' : 'Off';
                if (state.autoCycle) {
                    btnAutoCycle.classList.add('active');
                } else {
                    btnAutoCycle.classList.remove('active');
                }
                cycleIntervalRow.style.display = state.autoCycle ? '' : 'none';
                savePreferences();
            });

            cycleIntervalSlider.addEventListener('input', function () {
                state.cycleInterval = parseInt(cycleIntervalSlider.value, 10);
                cycleIntervalValue.textContent = state.cycleInterval + 's';
                state.cycleTimer = 0;
                savePreferences();
            });

            // --- Digital clock ---
            const digitalClockEl = document.getElementById('digital-clock');

            function updateDigitalClock(now) {
                if (state.clockType !== 'digital') {
                    digitalClockEl.style.display = 'none';
                    return;
                }
                digitalClockEl.style.display = '';
                digitalClockEl.style.opacity = state.clockOpacity;

                now = now || new Date();
                const h = String(now.getHours()).padStart(2, '0');
                const m = String(now.getMinutes()).padStart(2, '0');
                const s = String(now.getSeconds()).padStart(2, '0');
                digitalClockEl.textContent = h + ':' + m + ':' + s;
            }

            // --- Analogue clock ---
            const analogueClockEl = document.getElementById('analogue-clock');
            const analogueCtx = analogueClockEl.getContext('2d');
            // Canvas is 800x800 (2x for sharpness), displayed at 400x400 via CSS
            const ACLOCK_SIZE = 800;
            const ACLOCK_CENTER = ACLOCK_SIZE / 2;
            const ACLOCK_RADIUS = ACLOCK_SIZE / 2 - 20;

            function updateAnalogueClock(now) {
                if (state.clockType !== 'analogue') {
                    analogueClockEl.style.display = 'none';
                    return;
                }
                analogueClockEl.style.display = 'block';
                analogueClockEl.style.opacity = state.clockOpacity;

                const c = analogueCtx;
                const cx = ACLOCK_CENTER;
                const cy = ACLOCK_CENTER;
                const r = ACLOCK_RADIUS;

                // Clear
                c.clearRect(0, 0, ACLOCK_SIZE, ACLOCK_SIZE);

                // Semi-transparent circular face
                c.beginPath();
                c.arc(cx, cy, r, 0, Math.PI * 2);
                c.fillStyle = 'rgba(0, 0, 0, 0.25)';
                c.fill();
                c.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                c.lineWidth = 2;
                c.stroke();

                // Hour markers
                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI / 6) - Math.PI / 2;
                    const isMajor = (i % 3 === 0);
                    const markerLen = isMajor ? 22 : 12;
                    const markerWidth = isMajor ? 3 : 1.5;
                    const outerX = cx + Math.cos(angle) * (r - 8);
                    const outerY = cy + Math.sin(angle) * (r - 8);
                    const innerX = cx + Math.cos(angle) * (r - 8 - markerLen);
                    const innerY = cy + Math.sin(angle) * (r - 8 - markerLen);

                    c.beginPath();
                    c.moveTo(outerX, outerY);
                    c.lineTo(innerX, innerY);
                    c.strokeStyle = isMajor ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.4)';
                    c.lineWidth = markerWidth;
                    c.lineCap = 'round';
                    c.stroke();
                }

                // Current time
                now = now || new Date();
                const hours = now.getHours() % 12;
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();
                const millis = now.getMilliseconds();

                // Smooth second angle (includes milliseconds for sweep)
                const secAngle = ((seconds + millis / 1000) / 60) * Math.PI * 2 - Math.PI / 2;
                const minAngle = ((minutes + seconds / 60) / 60) * Math.PI * 2 - Math.PI / 2;
                const hrAngle = ((hours + minutes / 60) / 12) * Math.PI * 2 - Math.PI / 2;

                // Hour hand
                c.beginPath();
                c.moveTo(cx, cy);
                c.lineTo(cx + Math.cos(hrAngle) * (r * 0.5), cy + Math.sin(hrAngle) * (r * 0.5));
                c.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                c.lineWidth = 6;
                c.lineCap = 'round';
                c.stroke();

                // Minute hand
                c.beginPath();
                c.moveTo(cx, cy);
                c.lineTo(cx + Math.cos(minAngle) * (r * 0.72), cy + Math.sin(minAngle) * (r * 0.72));
                c.strokeStyle = 'rgba(255, 255, 255, 0.85)';
                c.lineWidth = 4;
                c.lineCap = 'round';
                c.stroke();

                // Second hand (sweeping)
                c.beginPath();
                c.moveTo(cx - Math.cos(secAngle) * (r * 0.12), cy - Math.sin(secAngle) * (r * 0.12));
                c.lineTo(cx + Math.cos(secAngle) * (r * 0.82), cy + Math.sin(secAngle) * (r * 0.82));
                c.strokeStyle = 'rgba(220, 80, 80, 0.8)';
                c.lineWidth = 2;
                c.lineCap = 'round';
                c.stroke();

                // Centre dot
                c.beginPath();
                c.arc(cx, cy, 5, 0, Math.PI * 2);
                c.fillStyle = 'rgba(255, 255, 255, 0.9)';
                c.fill();
            }

            // --- Sun & Moon sky tracker clock ---
            function drawSunMoonClock(ctx, w, h, now) {
                if (state.clockType !== 'sunmoon') return;

                const opacity = state.clockOpacity;
                if (opacity <= 0) return;

                now = now || new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();
                const totalMinutes = hours * 60 + minutes + seconds / 60;

                // Determine if daytime (6am-6pm) or nighttime (6pm-6am)
                const isDaytime = (hours >= 6 && hours < 18);

                // Calculate progress (0 to 1) within the current period
                let progress;
                if (isDaytime) {
                    // 6:00 = 360 min, 18:00 = 1080 min; range = 720 min
                    progress = (totalMinutes - 360) / 720;
                } else {
                    // Nighttime wraps: 18:00 (1080) to 6:00 (360 next day)
                    if (totalMinutes >= 1080) {
                        progress = (totalMinutes - 1080) / 720;
                    } else {
                        progress = (totalMinutes + 1440 - 1080) / 720;
                    }
                }
                progress = Math.max(0, Math.min(1, progress));

                // Arc geometry
                const margin = w * 0.08;
                const arcLeft = margin;
                const arcRight = w - margin;
                const arcWidth = arcRight - arcLeft;
                const horizonY = h * 0.72;
                const peakHeight = h * 0.38; // how high the arc peaks above horizon

                // Position on the arc: angle goes from PI to 0 (left to right)
                const angle = Math.PI * (1 - progress);
                const celestialX = arcLeft + arcWidth * progress;
                const celestialY = horizonY - Math.sin(angle) * peakHeight;

                ctx.save();
                ctx.globalAlpha = opacity;

                // --- Draw the dotted arc path ---
                ctx.beginPath();
                ctx.setLineDash([4, 8]);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= ARC_SEGMENTS; i++) {
                    const t = i / ARC_SEGMENTS;
                    const a = Math.PI * (1 - t);
                    const px = arcLeft + arcWidth * t;
                    const py = horizonY - Math.sin(a) * peakHeight;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // --- Draw the horizon line ---
                ctx.beginPath();
                ctx.moveTo(arcLeft - 20, horizonY);
                ctx.lineTo(arcRight + 20, horizonY);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // --- Time labels ---
                ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                const labelY = horizonY + 10;
                const labelAlpha = 0.35;

                if (isDaytime) {
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + labelAlpha + ')';
                    ctx.fillText('6am', arcLeft, labelY);
                    ctx.fillText('noon', arcLeft + arcWidth * 0.5, labelY);
                    ctx.fillText('6pm', arcRight, labelY);
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + labelAlpha + ')';
                    ctx.fillText('6pm', arcLeft, labelY);
                    ctx.fillText('midnight', arcLeft + arcWidth * 0.5, labelY);
                    ctx.fillText('6am', arcRight, labelY);
                }

                // --- Draw the sun or moon ---
                if (isDaytime) {
                    // Sun: warm glow + rays
                    const sunRadius = Math.min(w, h) * 0.028;

                    // Outer glow
                    const glowGrad = ctx.createRadialGradient(celestialX, celestialY, sunRadius * 0.5, celestialX, celestialY, sunRadius * 5);
                    glowGrad.addColorStop(0, 'rgba(255, 200, 50, 0.25)');
                    glowGrad.addColorStop(0.3, 'rgba(255, 180, 40, 0.1)');
                    glowGrad.addColorStop(1, 'rgba(255, 160, 30, 0)');
                    ctx.beginPath();
                    ctx.arc(celestialX, celestialY, sunRadius * 5, 0, Math.PI * 2);
                    ctx.fillStyle = glowGrad;
                    ctx.fill();

                    // Subtle rays
                    const rayCount = 12;
                    const t = state.timeElapsed;
                    for (let i = 0; i < rayCount; i++) {
                        const rayAngle = (i / rayCount) * Math.PI * 2 + t * 0.08;
                        const rayInner = sunRadius * 1.3;
                        const rayOuter = sunRadius * 2.2 + Math.sin(t * 0.5 + i * 1.1) * sunRadius * 0.4;
                        ctx.beginPath();
                        ctx.moveTo(
                            celestialX + Math.cos(rayAngle) * rayInner,
                            celestialY + Math.sin(rayAngle) * rayInner
                        );
                        ctx.lineTo(
                            celestialX + Math.cos(rayAngle) * rayOuter,
                            celestialY + Math.sin(rayAngle) * rayOuter
                        );
                        ctx.strokeStyle = 'rgba(255, 210, 80, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                    }

                    // Sun body
                    const sunGrad = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, sunRadius);
                    sunGrad.addColorStop(0, 'rgba(255, 240, 180, 1)');
                    sunGrad.addColorStop(0.6, 'rgba(255, 200, 60, 1)');
                    sunGrad.addColorStop(1, 'rgba(255, 170, 30, 0.9)');
                    ctx.beginPath();
                    ctx.arc(celestialX, celestialY, sunRadius, 0, Math.PI * 2);
                    ctx.fillStyle = sunGrad;
                    ctx.fill();
                } else {
                    // Moon: cool glow + crescent shadow
                    const moonRadius = Math.min(w, h) * 0.026;

                    // Cool glow
                    const moonGlowGrad = ctx.createRadialGradient(celestialX, celestialY, moonRadius * 0.5, celestialX, celestialY, moonRadius * 4.5);
                    moonGlowGrad.addColorStop(0, 'rgba(180, 200, 255, 0.2)');
                    moonGlowGrad.addColorStop(0.3, 'rgba(150, 180, 240, 0.08)');
                    moonGlowGrad.addColorStop(1, 'rgba(120, 150, 220, 0)');
                    ctx.beginPath();
                    ctx.arc(celestialX, celestialY, moonRadius * 4.5, 0, Math.PI * 2);
                    ctx.fillStyle = moonGlowGrad;
                    ctx.fill();

                    // Moon body (light disc) with crescent shadow
                    // Clip to moon circle, then draw body + shadow
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(celestialX, celestialY, moonRadius, 0, Math.PI * 2);
                    ctx.clip();

                    // Fill the full moon body
                    const moonBodyGrad = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, moonRadius);
                    moonBodyGrad.addColorStop(0, 'rgba(230, 235, 255, 1)');
                    moonBodyGrad.addColorStop(0.7, 'rgba(210, 220, 245, 1)');
                    moonBodyGrad.addColorStop(1, 'rgba(190, 200, 235, 0.9)');
                    ctx.beginPath();
                    ctx.arc(celestialX, celestialY, moonRadius, 0, Math.PI * 2);
                    ctx.fillStyle = moonBodyGrad;
                    ctx.fill();

                    // Crescent shadow (dark circle offset to the upper-right, clipped to moon)
                    ctx.beginPath();
                    ctx.arc(celestialX + moonRadius * 0.5, celestialY - moonRadius * 0.15, moonRadius * 0.78, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(15, 20, 45, 0.9)';
                    ctx.fill();
                    ctx.restore();
                }

                ctx.restore();
            }

            // Initial clock render
            const initDate = new Date();
            updateDigitalClock(initDate);
            updateAnalogueClock(initDate);

            document.addEventListener('mousemove', showControls);
            document.addEventListener('mousedown', showControls);
            document.addEventListener('touchstart', showControls);

            // Start the initial hide timer
            showControls();

            // --- Theme configurations ---
            // Each theme defines how its particles behave and how the scene is drawn.
            const themes = {};

            // --- Watery theme ---
            // Hoisted wave configs (avoid per-frame allocation)
            const wateryWaveConfigs = [
                { yBase: 0.55, amp: 18, freq: 0.004, speed: 0.3, color: '20, 60, 140', opacity: 0.12 },
                { yBase: 0.60, amp: 22, freq: 0.005, speed: 0.25, color: '30, 80, 160', opacity: 0.10 },
                { yBase: 0.68, amp: 15, freq: 0.006, speed: 0.35, color: '20, 70, 150', opacity: 0.10 },
                { yBase: 0.75, amp: 20, freq: 0.003, speed: 0.20, color: '15, 50, 130', opacity: 0.08 },
                { yBase: 0.82, amp: 12, freq: 0.007, speed: 0.28, color: '10, 40, 120', opacity: 0.08 }
            ];

            themes.watery = {
                targetCount: 40,

                spawn: function (w, h) {
                    const r = 2 + Math.random() * 8;
                    return {
                        x: Math.random() * w,
                        y: h + r + Math.random() * h * 0.3,
                        r: r,
                        speed: 12 + Math.random() * 20,
                        wobbleAmp: 15 + Math.random() * 25,
                        wobbleSpeed: 0.4 + Math.random() * 0.6,
                        wobbleOffset: Math.random() * Math.PI * 2,
                        opacity: 0.08 + Math.random() * 0.18
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.y -= p.speed * dt;
                    p.x += Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * p.wobbleAmp * dt;
                    // Recycle when above the top
                    if (p.y + p.r < 0) return false;
                    // Wrap horizontally
                    if (p.x < -p.r) p.x = w + p.r;
                    if (p.x > w + p.r) p.x = -p.r;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(180, 220, 255, ' + p.opacity + ')';
                    ctx.fill();
                    // Highlight on bubble
                    ctx.beginPath();
                    ctx.arc(p.x - p.r * 0.3, p.y - p.r * 0.3, p.r * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (p.opacity * 0.6) + ')';
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    // Deep ocean blue gradient
                    const grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#040818');
                    grad.addColorStop(0.3, '#061530');
                    grad.addColorStop(0.7, '#0a2a50');
                    grad.addColorStop(1, '#0c3568');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Subtle light rays from the top
                    const t = state.timeElapsed;
                    const rayCount = 6;
                    ctx.save();
                    for (let i = 0; i < rayCount; i++) {
                        const baseX = w * (0.15 + 0.7 * (i / (rayCount - 1)));
                        const sway = Math.sin(t * 0.15 + i * 1.2) * w * 0.04;
                        const topX = baseX + sway;
                        const spread = w * 0.04 + Math.sin(t * 0.2 + i * 0.8) * w * 0.01;
                        const rayOpacity = 0.02 + Math.sin(t * 0.25 + i * 1.5) * 0.01;

                        const rayGrad = ctx.createLinearGradient(topX, 0, topX, h * 0.75);
                        rayGrad.addColorStop(0, 'rgba(120, 180, 255, ' + rayOpacity + ')');
                        rayGrad.addColorStop(0.5, 'rgba(80, 150, 230, ' + (rayOpacity * 0.5) + ')');
                        rayGrad.addColorStop(1, 'rgba(60, 120, 200, 0)');

                        ctx.beginPath();
                        ctx.moveTo(topX - spread, 0);
                        ctx.lineTo(topX + spread, 0);
                        ctx.lineTo(topX + spread * 3, h * 0.75);
                        ctx.lineTo(topX - spread * 3, h * 0.75);
                        ctx.closePath();
                        ctx.fillStyle = rayGrad;
                        ctx.fill();
                    }
                    ctx.restore();
                },

                drawForeground: function (ctx, w, h, state) {
                    // 5 layered wave curves
                    const t = state.timeElapsed;

                    for (let i = 0; i < wateryWaveConfigs.length; i++) {
                        const wc = wateryWaveConfigs[i];
                        const baseY = h * wc.yBase;

                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (let x = 0; x <= w; x += 4) {
                            const y = baseY
                                + Math.sin(x * wc.freq + t * wc.speed) * wc.amp
                                + Math.sin(x * wc.freq * 0.5 + t * wc.speed * 1.3 + 2) * wc.amp * 0.5;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(' + wc.color + ', ' + wc.opacity + ')';
                        ctx.fill();
                    }
                }
            };

            // --- Sandy theme ---
            // Hoisted dune configs (avoid per-frame allocation)
            const sandyDuneConfigs = [
                { yBase: 0.62, amp: 35, freq: 0.0025, shiftSpeed: 0.06, color: '160, 110, 40', opacity: 0.18 },
                { yBase: 0.70, amp: 45, freq: 0.0018, shiftSpeed: 0.04, color: '175, 125, 50', opacity: 0.22 },
                { yBase: 0.78, amp: 30, freq: 0.0030, shiftSpeed: 0.08, color: '190, 140, 60', opacity: 0.25 },
                { yBase: 0.86, amp: 25, freq: 0.0022, shiftSpeed: 0.05, color: '200, 155, 70', opacity: 0.30 }
            ];

            themes.sandy = {
                targetCount: 80,

                spawn: function (w, h) {
                    return {
                        x: -Math.random() * w * 0.3,
                        y: Math.random() * h,
                        size: 0.5 + Math.random() * 2,
                        speed: 8 + Math.random() * 18,
                        drift: -2 + Math.random() * 4,
                        opacity: 0.15 + Math.random() * 0.35,
                        wobbleSpeed: 0.3 + Math.random() * 0.5,
                        wobbleOffset: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.x += p.speed * dt;
                    p.y += (p.drift + Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * 3) * dt;
                    // Recycle when past the right edge
                    if (p.x > w + 10) return false;
                    // Wrap vertically
                    if (p.y < 0) p.y = h;
                    if (p.y > h) p.y = 0;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(210, 180, 120, ' + p.opacity + ')';
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    // Warm amber/tan/gold gradient
                    const grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#d4a44a');
                    grad.addColorStop(0.25, '#c89038');
                    grad.addColorStop(0.5, '#b87d2e');
                    grad.addColorStop(0.75, '#a36b24');
                    grad.addColorStop(1, '#8a5518');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Subtle heat shimmer effect - thin horizontal wavy lines
                    const t = state.timeElapsed;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
                    ctx.lineWidth = 1;
                    const shimmerSpacing = 24;
                    for (let row = 0; row < h; row += shimmerSpacing) {
                        ctx.beginPath();
                        for (let x = 0; x <= w; x += 16) {
                            const yOff = Math.sin(x * 0.015 + t * 0.8 + row * 0.1) * 2
                                     + Math.sin(x * 0.008 + t * 1.2 + row * 0.05) * 1.5;
                            if (x === 0) ctx.moveTo(x, row + yOff);
                            else ctx.lineTo(x, row + yOff);
                        }
                        ctx.stroke();
                    }
                    ctx.restore();
                },

                drawForeground: function (ctx, w, h, state) {
                    // 4 smooth dune curves at the lower portion of the screen
                    const t = state.timeElapsed;

                    for (let i = 0; i < sandyDuneConfigs.length; i++) {
                        const dc = sandyDuneConfigs[i];
                        const baseY = h * dc.yBase;

                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (let x = 0; x <= w; x += 4) {
                            const y = baseY
                                + Math.sin(x * dc.freq + t * dc.shiftSpeed) * dc.amp
                                + Math.sin(x * dc.freq * 1.6 + t * dc.shiftSpeed * 0.7 + 1.5) * dc.amp * 0.4
                                + Math.sin(x * dc.freq * 0.5 + t * dc.shiftSpeed * 1.3 + 3) * dc.amp * 0.25;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(' + dc.color + ', ' + dc.opacity + ')';
                        ctx.fill();
                    }
                }
            };

            // --- Snowy theme ---
            // Hoisted snow layers (avoid per-frame allocation)
            const snowyLayers = [
                { yOffset: 0, amp: 18, freq: 0.003, speed: 0.02, opacity: 0.5 },
                { yOffset: -8, amp: 12, freq: 0.005, speed: 0.03, opacity: 0.7 },
                { yOffset: -16, amp: 8, freq: 0.004, speed: 0.015, opacity: 0.9 }
            ];

            themes.snowy = {
                targetCount: 85,

                spawn: function (w, h) {
                    const size = 1 + Math.random() * 5;
                    return {
                        x: Math.random() * w,
                        y: -size - Math.random() * h * 0.3,
                        size: size,
                        speedY: 15 + Math.random() * 25,
                        driftAmp: 20 + Math.random() * 40,
                        driftSpeed: 0.2 + Math.random() * 0.4,
                        driftOffset: Math.random() * Math.PI * 2,
                        opacity: 0.3 + Math.random() * 0.5,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.5
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.y += p.speedY * dt;
                    // Sine-wave horizontal drift that changes over time
                    p.x += Math.sin(state.timeElapsed * p.driftSpeed + p.driftOffset) * p.driftAmp * dt;
                    p.rotation += p.rotationSpeed * dt;
                    // Recycle when below the accumulation zone
                    if (p.y > h + p.size) return false;
                    // Wrap horizontally
                    if (p.x < -p.size * 2) p.x = w + p.size * 2;
                    if (p.x > w + p.size * 2) p.x = -p.size * 2;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    // Draw snowflake as a soft glowing circle
                    ctx.beginPath();
                    ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + p.opacity + ')';
                    ctx.fill();
                    // Subtle glow around larger flakes
                    if (p.size > 3) {
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size * 2, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + (p.opacity * 0.12) + ')';
                        ctx.fill();
                    }
                    ctx.restore();
                },

                drawBackground: function (ctx, w, h, state) {
                    // Soft grey-blue to white gradient
                    const grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#8a9bb5');
                    grad.addColorStop(0.3, '#a0b0c8');
                    grad.addColorStop(0.6, '#bcc8d8');
                    grad.addColorStop(0.85, '#d8e0ea');
                    grad.addColorStop(1, '#e8ecf2');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);
                },

                drawForeground: function (ctx, w, h, state) {
                    // Snow accumulation effect at the bottom - white curved area
                    const t = state.timeElapsed;
                    const accumH = h * 0.12; // height of the accumulation zone
                    const baseY = h - accumH;

                    // Draw 3 layered snow mound curves for a natural look
                    for (let i = 0; i < snowyLayers.length; i++) {
                        const layer = snowyLayers[i];
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (let x = 0; x <= w; x += 4) {
                            const y = baseY + layer.yOffset
                                + Math.sin(x * layer.freq + t * layer.speed) * layer.amp
                                + Math.sin(x * layer.freq * 2.2 + t * layer.speed * 0.7 + 1.8) * layer.amp * 0.4
                                + Math.cos(x * layer.freq * 0.6 + t * layer.speed * 1.4 + 3.2) * layer.amp * 0.25;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + layer.opacity + ')';
                        ctx.fill();
                    }
                }
            };

            // --- Wavey theme ---
            // Hoisted wave configs (avoid per-frame allocation)
            const waveyWaveConfigs = [
                { yBase: 0.15, amp: 30, freq: 0.0030, speed: 0.20, freq2: 0.0018, speed2: 0.12, r: 20, g: 80, b: 160, opacity: 0.06 },
                { yBase: 0.22, amp: 25, freq: 0.0045, speed: 0.28, freq2: 0.0025, speed2: 0.18, r: 30, g: 120, b: 180, opacity: 0.05 },
                { yBase: 0.28, amp: 35, freq: 0.0020, speed: 0.15, freq2: 0.0035, speed2: 0.22, r: 15, g: 100, b: 170, opacity: 0.06 },
                { yBase: 0.35, amp: 22, freq: 0.0055, speed: 0.32, freq2: 0.0012, speed2: 0.10, r: 40, g: 140, b: 190, opacity: 0.05 },
                { yBase: 0.42, amp: 28, freq: 0.0035, speed: 0.22, freq2: 0.0040, speed2: 0.30, r: 20, g: 110, b: 175, opacity: 0.06 },
                { yBase: 0.48, amp: 20, freq: 0.0060, speed: 0.35, freq2: 0.0020, speed2: 0.14, r: 50, g: 150, b: 195, opacity: 0.05 },
                { yBase: 0.55, amp: 32, freq: 0.0025, speed: 0.18, freq2: 0.0045, speed2: 0.26, r: 25, g: 90, b: 165, opacity: 0.06 },
                { yBase: 0.62, amp: 26, freq: 0.0040, speed: 0.25, freq2: 0.0015, speed2: 0.20, r: 35, g: 130, b: 185, opacity: 0.05 },
                { yBase: 0.68, amp: 18, freq: 0.0070, speed: 0.38, freq2: 0.0030, speed2: 0.16, r: 45, g: 155, b: 200, opacity: 0.05 },
                { yBase: 0.75, amp: 30, freq: 0.0028, speed: 0.16, freq2: 0.0050, speed2: 0.28, r: 18, g: 85, b: 155, opacity: 0.06 },
                { yBase: 0.82, amp: 24, freq: 0.0050, speed: 0.30, freq2: 0.0022, speed2: 0.12, r: 30, g: 115, b: 178, opacity: 0.05 },
                { yBase: 0.88, amp: 15, freq: 0.0038, speed: 0.24, freq2: 0.0060, speed2: 0.34, r: 55, g: 160, b: 205, opacity: 0.04 }
            ];

            themes.wavey = {
                targetCount: 0, // No particles - waves are the focus

                spawn: function (w, h) {
                    return { x: 0, y: 0 };
                },

                update: function (p, dt, w, h, state) {
                    return true;
                },

                draw: function (p, ctx, state) {},

                drawBackground: function (ctx, w, h, state) {
                    // Deep teal/navy gradient background
                    const grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#040d1a');
                    grad.addColorStop(0.3, '#061a2e');
                    grad.addColorStop(0.6, '#0a2838');
                    grad.addColorStop(1, '#0d3040');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);
                },

                drawForeground: function (ctx, w, h, state) {
                    const t = state.timeElapsed;

                    // 12 layered flowing sine waves
                    for (let i = 0; i < waveyWaveConfigs.length; i++) {
                        const wc = waveyWaveConfigs[i];
                        const baseY = h * wc.yBase;

                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (let x = 0; x <= w; x += 3) {
                            const y = baseY
                                + Math.sin(x * wc.freq + t * wc.speed) * wc.amp
                                + Math.sin(x * wc.freq2 + t * wc.speed2 + i * 0.8) * wc.amp * 0.6
                                + Math.cos(x * wc.freq * 0.7 + t * wc.speed * 1.4 + i * 1.3) * wc.amp * 0.3;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(' + wc.r + ', ' + wc.g + ', ' + wc.b + ', ' + wc.opacity + ')';
                        ctx.fill();
                    }

                    // Subtle surface shimmer dots
                    ctx.save();
                    const shimmerCount = 60;
                    for (let i = 0; i < shimmerCount; i++) {
                        // Deterministic positions using index-based offsets
                        const sx = (Math.sin(i * 3.7 + t * 0.05) * 0.5 + 0.5) * w;
                        const sy = (Math.sin(i * 5.3 + t * 0.03 + 2.1) * 0.5 + 0.5) * h;
                        const shimmerOpacity = (Math.sin(t * 1.5 + i * 2.1) * 0.5 + 0.5) * 0.15;
                        const shimmerSize = 1 + Math.sin(t * 0.8 + i * 1.7) * 0.5;

                        ctx.beginPath();
                        ctx.arc(sx, sy, shimmerSize, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(150, 220, 255, ' + shimmerOpacity + ')';
                        ctx.fill();
                    }
                    ctx.restore();
                }
            };

            // --- Spacey theme ---
            themes.spacey = (function () {
                // Pre-allocate trail buffer (ring buffer to avoid push/shift GC)
                const trailBuffer = [];
                for (let i = 0; i < SHOOTING_STAR_TRAIL_MAX; i++) {
                    trailBuffer.push({ x: 0, y: 0 });
                }

                // Shooting star state
                const shootingStar = {
                    active: false,
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0,
                    maxLife: 0.6,
                    trailBuffer: trailBuffer,
                    trailIndex: 0,
                    trailCount: 0,
                    timer: SHOOTING_STAR_INTERVAL_MIN + Math.random() * SHOOTING_STAR_INTERVAL_RANGE
                };

                // Nebula blobs - 3 slowly drifting colourful clouds
                const nebulae = [
                    { cx: 0.25, cy: 0.35, r: 0.18, hue: 'purple', driftX: 0.008, driftY: 0.005, phaseX: 0, phaseY: 1.2 },
                    { cx: 0.70, cy: 0.55, r: 0.22, hue: 'blue', driftX: 0.006, driftY: 0.009, phaseX: 2.5, phaseY: 0.4 },
                    { cx: 0.50, cy: 0.75, r: 0.16, hue: 'pink', driftX: 0.010, driftY: 0.007, phaseX: 4.0, phaseY: 3.1 }
                ];

                // Nebula colour mappings
                const nebulaColors = {
                    purple: { r: 120, g: 40, b: 180 },
                    blue:   { r: 40, g: 80, b: 200 },
                    pink:   { r: 180, g: 50, b: 130 }
                };

                return {
                    targetCount: 200,

                    onActivate: function () {
                        shootingStar.active = false;
                        shootingStar.trailCount = 0;
                        shootingStar.trailIndex = 0;
                        shootingStar.timer = SHOOTING_STAR_INTERVAL_MIN + Math.random() * SHOOTING_STAR_INTERVAL_RANGE;
                    },

                    spawn: function (w, h) {
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.5 + Math.random() * 2,
                            baseOpacity: 0.3 + Math.random() * 0.6,
                            twinkleSpeed: 0.8 + Math.random() * 2.5,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        // Stars are stationary, just twinkle
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        // Oscillating opacity via sine wave
                        const twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        const opacity = p.baseOpacity * (0.5 + twinkle * 0.5);
                        if (opacity < 0.05) return;

                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                        ctx.fill();

                        // Glow around brighter/larger stars
                        if (p.size > 1.2 && opacity > 0.4) {
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(200, 220, 255, ' + (opacity * 0.08) + ')';
                            ctx.fill();
                        }
                    },

                    drawBackground: function (ctx, w, h, state) {
                        // Dark navy/black radial gradient background
                        const cx = w * 0.5;
                        const cy = h * 0.4;
                        const maxR = Math.max(w, h) * 0.8;
                        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
                        grad.addColorStop(0, '#0a0e1a');
                        grad.addColorStop(0.4, '#060a14');
                        grad.addColorStop(0.8, '#030610');
                        grad.addColorStop(1, '#010208');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Draw nebula blobs
                        const t = state.timeElapsed;
                        for (let i = 0; i < nebulae.length; i++) {
                            const n = nebulae[i];
                            const col = nebulaColors[n.hue];
                            // Slow drifting position
                            const nx = (n.cx + Math.sin(t * n.driftX + n.phaseX) * 0.06) * w;
                            const ny = (n.cy + Math.sin(t * n.driftY + n.phaseY) * 0.05) * h;
                            const nr = n.r * Math.min(w, h);

                            const nebGrad = ctx.createRadialGradient(nx, ny, 0, nx, ny, nr);
                            nebGrad.addColorStop(0, 'rgba(' + col.r + ', ' + col.g + ', ' + col.b + ', 0.06)');
                            nebGrad.addColorStop(0.3, 'rgba(' + col.r + ', ' + col.g + ', ' + col.b + ', 0.04)');
                            nebGrad.addColorStop(0.6, 'rgba(' + col.r + ', ' + col.g + ', ' + col.b + ', 0.02)');
                            nebGrad.addColorStop(1, 'rgba(' + col.r + ', ' + col.g + ', ' + col.b + ', 0)');
                            ctx.beginPath();
                            ctx.arc(nx, ny, nr, 0, Math.PI * 2);
                            ctx.fillStyle = nebGrad;
                            ctx.fill();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;

                        // --- Shooting star ---
                        shootingStar.timer -= dt;

                        if (!shootingStar.active && shootingStar.timer <= 0) {
                            // Launch a new shooting star
                            shootingStar.active = true;
                            shootingStar.life = 0;
                            shootingStar.maxLife = 0.4 + Math.random() * 0.4;
                            shootingStar.trailCount = 0;
                            shootingStar.trailIndex = 0;
                            // Start from a random position in the upper portion
                            shootingStar.x = Math.random() * w;
                            shootingStar.y = Math.random() * h * 0.4;
                            // Move diagonally downward
                            const speed = 600 + Math.random() * 400;
                            const angle = Math.PI * 0.15 + Math.random() * Math.PI * 0.2;
                            shootingStar.vx = Math.cos(angle) * speed;
                            shootingStar.vy = Math.sin(angle) * speed;
                            shootingStar.timer = SHOOTING_STAR_INTERVAL_MIN + Math.random() * SHOOTING_STAR_INTERVAL_RANGE;
                        }

                        if (shootingStar.active) {
                            shootingStar.life += dt;
                            shootingStar.x += shootingStar.vx * dt;
                            shootingStar.y += shootingStar.vy * dt;

                            // Store trail point in ring buffer
                            shootingStar.trailBuffer[shootingStar.trailIndex].x = shootingStar.x;
                            shootingStar.trailBuffer[shootingStar.trailIndex].y = shootingStar.y;
                            shootingStar.trailIndex = (shootingStar.trailIndex + 1) % SHOOTING_STAR_TRAIL_MAX;
                            if (shootingStar.trailCount < SHOOTING_STAR_TRAIL_MAX) shootingStar.trailCount++;

                            // Draw the trail
                            const progress = shootingStar.life / shootingStar.maxLife;
                            const fadeOut = 1 - progress;

                            if (shootingStar.trailCount > 1) {
                                for (let i = 1; i < shootingStar.trailCount; i++) {
                                    const prevIdx = (shootingStar.trailIndex - shootingStar.trailCount + i - 1 + SHOOTING_STAR_TRAIL_MAX) % SHOOTING_STAR_TRAIL_MAX;
                                    const currIdx = (shootingStar.trailIndex - shootingStar.trailCount + i + SHOOTING_STAR_TRAIL_MAX) % SHOOTING_STAR_TRAIL_MAX;
                                    const prev = shootingStar.trailBuffer[prevIdx];
                                    const curr = shootingStar.trailBuffer[currIdx];
                                    const segAlpha = (i / shootingStar.trailCount) * fadeOut * 0.8;
                                    const segWidth = (i / shootingStar.trailCount) * 2.5;
                                    ctx.beginPath();
                                    ctx.moveTo(prev.x, prev.y);
                                    ctx.lineTo(curr.x, curr.y);
                                    ctx.strokeStyle = 'rgba(255, 255, 255, ' + segAlpha + ')';
                                    ctx.lineWidth = segWidth;
                                    ctx.lineCap = 'round';
                                    ctx.stroke();
                                }

                                // Bright head glow
                                const headIdx = (shootingStar.trailIndex - 1 + SHOOTING_STAR_TRAIL_MAX) % SHOOTING_STAR_TRAIL_MAX;
                                const headX = shootingStar.trailBuffer[headIdx].x;
                                const headY = shootingStar.trailBuffer[headIdx].y;
                                const headGrad = ctx.createRadialGradient(headX, headY, 0, headX, headY, 8);
                                headGrad.addColorStop(0, 'rgba(255, 255, 255, ' + (fadeOut * 0.9) + ')');
                                headGrad.addColorStop(0.5, 'rgba(200, 220, 255, ' + (fadeOut * 0.3) + ')');
                                headGrad.addColorStop(1, 'rgba(150, 180, 255, 0)');
                                ctx.beginPath();
                                ctx.arc(headX, headY, 8, 0, Math.PI * 2);
                                ctx.fillStyle = headGrad;
                                ctx.fill();
                            }

                            // End shooting star when life expires or it goes off-screen
                            if (shootingStar.life >= shootingStar.maxLife ||
                                shootingStar.x > w + 50 || shootingStar.y > h + 50 ||
                                shootingStar.x < -50 || shootingStar.y < -50) {
                                shootingStar.active = false;
                                shootingStar.trailCount = 0;
                                shootingStar.trailIndex = 0;
                            }
                        }
                    }
                };
            })();

            // --- Colourful theme ---
            // Hoisted aurora configs (avoid per-frame allocation)
            const colourfulAuroraConfigs = [
                { yBase: 0.30, amp: 40, freq: 0.003, speed: 0.18, hueBase: 0,   opacity: 0.06 },
                { yBase: 0.40, amp: 35, freq: 0.004, speed: 0.22, hueBase: 72,  opacity: 0.05 },
                { yBase: 0.50, amp: 45, freq: 0.0025, speed: 0.15, hueBase: 144, opacity: 0.06 },
                { yBase: 0.60, amp: 30, freq: 0.005, speed: 0.25, hueBase: 216, opacity: 0.05 },
                { yBase: 0.72, amp: 38, freq: 0.0035, speed: 0.20, hueBase: 288, opacity: 0.06 }
            ];

            themes.colourful = {
                targetCount: 45,

                spawn: function (w, h) {
                    return {
                        x: Math.random() * w,
                        y: Math.random() * h,
                        r: 15 + Math.random() * 35,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12,
                        hueOffset: Math.random() * 360,
                        opacity: 0.08 + Math.random() * 0.15,
                        driftPhaseX: Math.random() * Math.PI * 2,
                        driftPhaseY: Math.random() * Math.PI * 2,
                        driftSpeedX: 0.15 + Math.random() * 0.3,
                        driftSpeedY: 0.15 + Math.random() * 0.3
                    };
                },

                update: function (p, dt, w, h, state) {
                    // Gentle drifting motion using sine waves
                    p.x += Math.sin(state.timeElapsed * p.driftSpeedX + p.driftPhaseX) * p.vx * dt;
                    p.y += Math.sin(state.timeElapsed * p.driftSpeedY + p.driftPhaseY) * p.vy * dt;
                    // Wrap around edges
                    if (p.x < -p.r * 2) p.x = w + p.r * 2;
                    if (p.x > w + p.r * 2) p.x = -p.r * 2;
                    if (p.y < -p.r * 2) p.y = h + p.r * 2;
                    if (p.y > h + p.r * 2) p.y = -p.r * 2;
                    return true;
                },

                draw: function (p, ctx, state) {
                    // Hue shifts over time for kaleidoscopic feel
                    const hue = (p.hueOffset + state.timeElapsed * 15) % 360;
                    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
                    grad.addColorStop(0, 'hsla(' + hue + ', 80%, 65%, ' + p.opacity + ')');
                    grad.addColorStop(0.5, 'hsla(' + hue + ', 70%, 55%, ' + (p.opacity * 0.5) + ')');
                    grad.addColorStop(1, 'hsla(' + hue + ', 60%, 45%, 0)');
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fillStyle = grad;
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    const t = state.timeElapsed;
                    // Slowly rotating rainbow hue gradient background
                    // Use a base hue that shifts over time
                    const baseHue = (t * 8) % 360;
                    const grad = ctx.createLinearGradient(
                        w * 0.5 + Math.cos(t * 0.1) * w * 0.4,
                        h * 0.5 + Math.sin(t * 0.1) * h * 0.4,
                        w * 0.5 + Math.cos(t * 0.1 + Math.PI) * w * 0.4,
                        h * 0.5 + Math.sin(t * 0.1 + Math.PI) * h * 0.4
                    );
                    const hue1 = baseHue;
                    const hue2 = (baseHue + 60) % 360;
                    const hue3 = (baseHue + 120) % 360;
                    const hue4 = (baseHue + 180) % 360;
                    const hue5 = (baseHue + 240) % 360;
                    const hue6 = (baseHue + 300) % 360;
                    grad.addColorStop(0, 'hsl(' + hue1 + ', 35%, 12%)');
                    grad.addColorStop(0.2, 'hsl(' + hue2 + ', 35%, 14%)');
                    grad.addColorStop(0.4, 'hsl(' + hue3 + ', 35%, 12%)');
                    grad.addColorStop(0.6, 'hsl(' + hue4 + ', 35%, 14%)');
                    grad.addColorStop(0.8, 'hsl(' + hue5 + ', 35%, 12%)');
                    grad.addColorStop(1, 'hsl(' + hue6 + ', 35%, 14%)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);
                },

                drawForeground: function (ctx, w, h, state) {
                    const t = state.timeElapsed;

                    // 5 aurora-like wave layers with hue-shifting fills
                    for (let i = 0; i < colourfulAuroraConfigs.length; i++) {
                        const ac = colourfulAuroraConfigs[i];
                        const baseY = h * ac.yBase;
                        // Hue shifts over time
                        const hue = (ac.hueBase + t * 12) % 360;

                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (let x = 0; x <= w; x += 3) {
                            const y = baseY
                                + Math.sin(x * ac.freq + t * ac.speed) * ac.amp
                                + Math.sin(x * ac.freq * 0.6 + t * ac.speed * 1.3 + i * 1.5) * ac.amp * 0.5
                                + Math.cos(x * ac.freq * 0.3 + t * ac.speed * 0.7 + i * 2.8) * ac.amp * 0.3;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'hsla(' + hue + ', 70%, 55%, ' + ac.opacity + ')';
                        ctx.fill();
                    }
                }
            };

            // --- Windy theme ---
            themes.windy = (function () {
                // Wind gust state - varies over time using layered sine waves
                function getWindStrength(t) {
                    return 1.0
                        + Math.sin(t * 0.3) * 0.4
                        + Math.sin(t * 0.7 + 1.2) * 0.25
                        + Math.sin(t * 1.5 + 3.0) * 0.15;
                }

                // Wind current line state (persistent across frames)
                const windLines = [];
                let windLinesInited = false;
                let windLinesW = 0;
                let windLinesH = 0;
                const WIND_LINE_COUNT = 8;

                function initWindLines(w, h) {
                    windLines.length = 0;
                    for (let i = 0; i < WIND_LINE_COUNT; i++) {
                        windLines.push({
                            y: h * (0.1 + 0.8 * (i / (WIND_LINE_COUNT - 1))),
                            speed: 60 + Math.random() * 80,
                            offset: Math.random() * w,
                            amp: 8 + Math.random() * 15,
                            freq: 0.003 + Math.random() * 0.004,
                            opacity: 0.04 + Math.random() * 0.06,
                            length: w * (0.3 + Math.random() * 0.4),
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                    windLinesInited = true;
                    windLinesW = w;
                    windLinesH = h;
                }

                return {
                    targetCount: 35,

                    spawn: function (w, h) {
                        // Leaf-like ellipse particles
                        if (!windLinesInited || windLinesW !== w || windLinesH !== h) initWindLines(w, h);
                        const leafHues = [
                            { r: 90, g: 140, b: 60 },   // green
                            { r: 120, g: 160, b: 50 },  // light green
                            { r: 180, g: 130, b: 40 },  // amber
                            { r: 160, g: 90, b: 30 },   // brown
                            { r: 200, g: 160, b: 50 },  // golden
                            { r: 140, g: 70, b: 40 }    // dark brown
                        ];
                        const col = leafHues[Math.floor(Math.random() * leafHues.length)];
                        return {
                            x: -20 - Math.random() * w * 0.3,
                            y: Math.random() * h,
                            rx: 4 + Math.random() * 6,     // ellipse horizontal radius
                            ry: 2 + Math.random() * 3,     // ellipse vertical radius
                            rotation: Math.random() * Math.PI * 2,
                            rotationSpeed: 1.5 + Math.random() * 3,
                            wobbleAmp: 30 + Math.random() * 50,
                            wobbleSpeed: 0.5 + Math.random() * 1.0,
                            wobbleOffset: Math.random() * Math.PI * 2,
                            baseSpeed: 80 + Math.random() * 100,
                            opacity: 0.4 + Math.random() * 0.4,
                            r: col.r,
                            g: col.g,
                            b: col.b
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        const wind = getWindStrength(state.timeElapsed);
                        // Move horizontally with wind
                        p.x += p.baseSpeed * wind * dt;
                        // Vertical wobble
                        p.y += Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * p.wobbleAmp * dt;
                        // Rotate
                        p.rotation += p.rotationSpeed * wind * dt;
                        // Recycle when past the right edge
                        if (p.x > w + 30) return false;
                        // Wrap vertically
                        if (p.y < -20) p.y = h + 20;
                        if (p.y > h + 20) p.y = -20;
                        return true;
                    },

                    draw: function (p, ctx) {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        // Draw leaf-like ellipse
                        ctx.beginPath();
                        ctx.ellipse(0, 0, p.rx, p.ry, 0, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(' + p.r + ', ' + p.g + ', ' + p.b + ', ' + p.opacity + ')';
                        ctx.fill();
                        // Leaf vein (subtle centre line)
                        ctx.beginPath();
                        ctx.moveTo(-p.rx * 0.8, 0);
                        ctx.lineTo(p.rx * 0.8, 0);
                        ctx.strokeStyle = 'rgba(' + Math.max(0, p.r - 30) + ', ' + Math.max(0, p.g - 30) + ', ' + Math.max(0, p.b - 20) + ', ' + (p.opacity * 0.5) + ')';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                        ctx.restore();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        // Soft sky-blue gradient background
                        const grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#6ba3c7');
                        grad.addColorStop(0.3, '#85b8d8');
                        grad.addColorStop(0.6, '#a0cce5');
                        grad.addColorStop(0.85, '#b8dced');
                        grad.addColorStop(1, '#c8e4f0');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state) {
                        const t = state.timeElapsed;
                        const wind = getWindStrength(t);

                        if (!windLinesInited || windLines.length === 0 || windLinesW !== w || windLinesH !== h) initWindLines(w, h);

                        // Flowing wind current lines - thin semi-transparent horizontal curves
                        ctx.save();
                        ctx.lineWidth = 1;
                        ctx.lineCap = 'round';

                        for (let i = 0; i < windLines.length; i++) {
                            const wl = windLines[i];
                            // Advance the offset so the line moves across the screen
                            const lineX = (wl.offset + t * wl.speed * wind) % (w + wl.length) - wl.length * 0.3;
                            const baseY = wl.y + Math.sin(t * 0.2 + wl.phase) * 20;

                            ctx.beginPath();
                            ctx.strokeStyle = 'rgba(255, 255, 255, ' + (wl.opacity * wind) + ')';

                            const segments = 60;
                            for (let s = 0; s <= segments; s++) {
                                const frac = s / segments;
                                const px = lineX + frac * wl.length;
                                const py = baseY + Math.sin(px * wl.freq + t * 1.5 + wl.phase) * wl.amp
                                              + Math.sin(px * wl.freq * 2.3 + t * 0.8 + wl.phase * 2) * wl.amp * 0.3;

                                // Fade at the ends of the line for a soft look
                                if (s === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                        }
                        ctx.restore();
                    }
                };
            })();

            // --- Stormy theme ---
            themes.stormy = (function () {
                // Lightning flash state
                const lightning = {
                    active: false,
                    opacity: 0,
                    timer: LIGHTNING_INTERVAL_MIN + Math.random() * LIGHTNING_INTERVAL_RANGE,
                    fadeSpeed: 3.0 // how fast the flash fades out
                };

                // Cloud shape definitions (positioned at the top of the screen)
                const clouds = [
                    { cx: 0.12, cy: 0.06, rx: 0.18, ry: 0.08, phase: 0 },
                    { cx: 0.30, cy: 0.04, rx: 0.22, ry: 0.10, phase: 1.5 },
                    { cx: 0.52, cy: 0.05, rx: 0.20, ry: 0.09, phase: 3.0 },
                    { cx: 0.73, cy: 0.04, rx: 0.24, ry: 0.11, phase: 4.5 },
                    { cx: 0.90, cy: 0.06, rx: 0.16, ry: 0.08, phase: 6.0 }
                ];

                return {
                    targetCount: 150,

                    onActivate: function () {
                        lightning.active = false;
                        lightning.opacity = 0;
                        lightning.timer = LIGHTNING_INTERVAL_MIN + Math.random() * LIGHTNING_INTERVAL_RANGE;
                    },

                    spawn: function (w, h) {
                        return {
                            x: Math.random() * w + w * 0.1,
                            y: -Math.random() * h * 0.3,
                            speed: 300 + Math.random() * 250,
                            windDrift: 60 + Math.random() * 40,
                            length: 12 + Math.random() * 18,
                            opacity: 0.15 + Math.random() * 0.35
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        // Fall diagonally (mostly down, slightly to the left)
                        p.y += p.speed * dt;
                        p.x -= p.windDrift * dt;
                        // Recycle when below the screen or past left edge
                        if (p.y > h + 20 || p.x < -20) return false;
                        return true;
                    },

                    draw: function (p, ctx) {
                        // Draw rain drop as a short diagonal line
                        const angle = Math.atan2(p.speed, -p.windDrift);
                        const dx = Math.cos(angle) * p.length;
                        const dy = Math.sin(angle) * p.length;
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + dx, p.y + dy);
                        ctx.strokeStyle = 'rgba(180, 200, 220, ' + p.opacity + ')';
                        ctx.lineWidth = 1;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        // Dark grey/purple gradient background
                        const grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#1a1525');
                        grad.addColorStop(0.3, '#1e1830');
                        grad.addColorStop(0.6, '#22202e');
                        grad.addColorStop(1, '#181620');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Dark cloud shapes at the top using radial gradients
                        for (let i = 0; i < clouds.length; i++) {
                            const c = clouds[i];
                            const cx = (c.cx + Math.sin(state.timeElapsed * 0.02 + c.phase) * 0.02) * w;
                            const cy = c.cy * h;
                            const rx = c.rx * w;
                            const ry = c.ry * h;

                            // Draw cloud as a large elliptical radial gradient
                            ctx.save();
                            ctx.translate(cx, cy);
                            ctx.scale(1, ry / rx);
                            const cloudGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, rx);
                            cloudGrad.addColorStop(0, 'rgba(25, 20, 35, 0.8)');
                            cloudGrad.addColorStop(0.4, 'rgba(30, 25, 40, 0.5)');
                            cloudGrad.addColorStop(0.7, 'rgba(35, 30, 45, 0.25)');
                            cloudGrad.addColorStop(1, 'rgba(35, 30, 45, 0)');
                            ctx.beginPath();
                            ctx.arc(0, 0, rx, 0, Math.PI * 2);
                            ctx.fillStyle = cloudGrad;
                            ctx.fill();
                            ctx.restore();

                            // Second cloud blob slightly offset for volume
                            ctx.save();
                            ctx.translate(cx + rx * 0.3, cy + ry * 0.2);
                            ctx.scale(1, (ry * 0.7) / (rx * 0.6));
                            const cloudGrad2 = ctx.createRadialGradient(0, 0, 0, 0, 0, rx * 0.6);
                            cloudGrad2.addColorStop(0, 'rgba(20, 15, 30, 0.7)');
                            cloudGrad2.addColorStop(0.5, 'rgba(28, 22, 38, 0.35)');
                            cloudGrad2.addColorStop(1, 'rgba(30, 25, 40, 0)');
                            ctx.beginPath();
                            ctx.arc(0, 0, rx * 0.6, 0, Math.PI * 2);
                            ctx.fillStyle = cloudGrad2;
                            ctx.fill();
                            ctx.restore();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;

                        // --- Lightning flash ---
                        lightning.timer -= dt;

                        if (!lightning.active && lightning.timer <= 0) {
                            // Trigger a lightning flash
                            lightning.active = true;
                            lightning.opacity = 0.35 + Math.random() * 0.2; // brief white overlay
                            lightning.timer = LIGHTNING_INTERVAL_MIN + Math.random() * LIGHTNING_INTERVAL_RANGE;
                        }

                        if (lightning.active) {
                            // Draw the screen-wide white overlay
                            ctx.save();
                            ctx.fillStyle = 'rgba(220, 225, 255, ' + lightning.opacity + ')';
                            ctx.fillRect(0, 0, w, h);
                            ctx.restore();

                            // Fade out
                            lightning.opacity -= lightning.fadeSpeed * dt;
                            if (lightning.opacity <= 0) {
                                lightning.active = false;
                                lightning.opacity = 0;
                            }
                        }
                    }
                };
            })();

            // --- Sunny theme ---
            themes.sunny = (function () {
                // Sun position (relative to canvas)
                const sunX = 0.5;
                const sunY = 0.22;
                const sunRadius = 0.06; // relative to Math.min(w, h)

                // Light rays radiating from the sun
                const rayCount = 12;
                const rays = [];
                for (let i = 0; i < rayCount; i++) {
                    rays.push({
                        angle: (i / rayCount) * Math.PI * 2,
                        baseWidth: 0.015 + Math.random() * 0.02,
                        length: 0.3 + Math.random() * 0.25,
                        pulseSpeed: 0.3 + Math.random() * 0.4,
                        pulseOffset: Math.random() * Math.PI * 2,
                        opacityBase: 0.04 + Math.random() * 0.03
                    });
                }

                // Rotation speed for the rays (very slow)
                const rotationSpeed = 0.02;

                return {
                    targetCount: 30,

                    spawn: function (w, h) {
                        return {
                            x: Math.random() * w,
                            y: h * 0.3 + Math.random() * h * 0.7,
                            size: 1 + Math.random() * 2.5,
                            baseOpacity: 0.15 + Math.random() * 0.25,
                            speedY: -(8 + Math.random() * 15), // float upward
                            driftSpeed: 0.5 + Math.random() * 1.0,
                            driftOffset: Math.random() * Math.PI * 2,
                            twinkleSpeed: 0.8 + Math.random() * 1.5,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        // Float gently upward
                        p.y += p.speedY * dt;
                        // Subtle horizontal drift using sine wave
                        p.x += Math.sin(state.timeElapsed * p.driftSpeed + p.driftOffset) * 12 * dt;
                        // Recycle when above screen
                        if (p.y < -10) return false;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        // Oscillating opacity for a gentle twinkle
                        const twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        const opacity = p.baseOpacity * (0.6 + twinkle * 0.4);
                        if (opacity < 0.03) return;

                        // Draw dust mote as a soft glowing circle
                        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2.5);
                        grad.addColorStop(0, 'rgba(255, 240, 200, ' + opacity + ')');
                        grad.addColorStop(0.5, 'rgba(255, 230, 170, ' + (opacity * 0.5) + ')');
                        grad.addColorStop(1, 'rgba(255, 220, 140, 0)');
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
                        ctx.fillStyle = grad;
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        const t = state.timeElapsed;
                        const minDim = Math.min(w, h);

                        // Warm golden radial gradient background
                        const cx = w * sunX;
                        const cy = h * sunY;
                        const maxR = Math.max(w, h) * 1.2;
                        const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
                        bgGrad.addColorStop(0, '#fff5d6');
                        bgGrad.addColorStop(0.15, '#ffe8a0');
                        bgGrad.addColorStop(0.35, '#f5c84a');
                        bgGrad.addColorStop(0.55, '#e0a020');
                        bgGrad.addColorStop(0.8, '#c07818');
                        bgGrad.addColorStop(1, '#905510');
                        ctx.fillStyle = bgGrad;
                        ctx.fillRect(0, 0, w, h);

                        // --- Light rays radiating from the sun ---
                        const rotation = t * rotationSpeed;
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(rotation);

                        for (let i = 0; i < rays.length; i++) {
                            const ray = rays[i];
                            // Pulsing width and opacity
                            const pulse = Math.sin(t * ray.pulseSpeed + ray.pulseOffset);
                            const rayWidth = ray.baseWidth * (0.7 + pulse * 0.3) * minDim;
                            const rayLength = ray.length * maxR;
                            const rayOpacity = ray.opacityBase * (0.6 + pulse * 0.4);

                            // Draw ray as a triangle/wedge
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            const halfAngle = Math.atan2(rayWidth, rayLength * 0.3);
                            const x1 = Math.cos(ray.angle - halfAngle) * rayLength;
                            const y1 = Math.sin(ray.angle - halfAngle) * rayLength;
                            const x2 = Math.cos(ray.angle + halfAngle) * rayLength;
                            const y2 = Math.sin(ray.angle + halfAngle) * rayLength;
                            ctx.lineTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.closePath();

                            // Gradient along the ray for a natural fade
                            const rayGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, rayLength);
                            rayGrad.addColorStop(0, 'rgba(255, 248, 220, ' + rayOpacity + ')');
                            rayGrad.addColorStop(0.3, 'rgba(255, 240, 190, ' + (rayOpacity * 0.6) + ')');
                            rayGrad.addColorStop(0.7, 'rgba(255, 230, 150, ' + (rayOpacity * 0.25) + ')');
                            rayGrad.addColorStop(1, 'rgba(255, 220, 120, 0)');
                            ctx.fillStyle = rayGrad;
                            ctx.fill();
                        }

                        ctx.restore();

                        // --- Glowing sun ---
                        // Outer glow (large soft halo)
                        const glowR = sunRadius * minDim * 4;
                        const outerGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
                        outerGlow.addColorStop(0, 'rgba(255, 250, 230, 0.25)');
                        outerGlow.addColorStop(0.2, 'rgba(255, 240, 200, 0.15)');
                        outerGlow.addColorStop(0.5, 'rgba(255, 220, 150, 0.06)');
                        outerGlow.addColorStop(1, 'rgba(255, 200, 100, 0)');
                        ctx.beginPath();
                        ctx.arc(cx, cy, glowR, 0, Math.PI * 2);
                        ctx.fillStyle = outerGlow;
                        ctx.fill();

                        // Middle glow
                        const midR = sunRadius * minDim * 2;
                        const midGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, midR);
                        midGlow.addColorStop(0, 'rgba(255, 252, 240, 0.4)');
                        midGlow.addColorStop(0.4, 'rgba(255, 245, 210, 0.2)');
                        midGlow.addColorStop(1, 'rgba(255, 235, 180, 0)');
                        ctx.beginPath();
                        ctx.arc(cx, cy, midR, 0, Math.PI * 2);
                        ctx.fillStyle = midGlow;
                        ctx.fill();

                        // Sun core (bright white-yellow disc)
                        const coreR = sunRadius * minDim;
                        const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
                        coreGrad.addColorStop(0, 'rgba(255, 255, 250, 0.95)');
                        coreGrad.addColorStop(0.5, 'rgba(255, 250, 230, 0.85)');
                        coreGrad.addColorStop(0.8, 'rgba(255, 240, 200, 0.6)');
                        coreGrad.addColorStop(1, 'rgba(255, 230, 170, 0.3)');
                        ctx.beginPath();
                        ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
                        ctx.fillStyle = coreGrad;
                        ctx.fill();
                    },

                    drawForeground: function (ctx, w, h, state) {
                        // No foreground effects needed for sunny theme
                    }
                };
            })();

            // --- Mercurial theme ---
            // Sun-blasted cratered surface with harsh light/dark divide
            themes.mercurial = (function () {
                // Micro-meteorite impact state
                const impacts = [];
                const MAX_IMPACTS = 3;

                return {
                    targetCount: 25,

                    spawn: function (w, h) {
                        // Tiny dust particles drifting in the void
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.5 + Math.random() * 1.5,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 2,
                            opacity: 0.1 + Math.random() * 0.2,
                            twinkleSpeed: 0.5 + Math.random() * 1.5,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        if (p.x < -5 || p.x > w + 5 || p.y < -5 || p.y > h + 5) return false;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.opacity * (0.5 + twinkle * 0.5);
                        if (op < 0.02) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(200, 200, 210, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Stark light/dark divide: hot sun side on left, cold shadow on right
                        var grad = ctx.createLinearGradient(0, 0, w, 0);
                        grad.addColorStop(0, '#e8dcc8');
                        grad.addColorStop(0.25, '#c0a880');
                        grad.addColorStop(0.45, '#6a5a48');
                        grad.addColorStop(0.55, '#2a2228');
                        grad.addColorStop(0.75, '#0e0c10');
                        grad.addColorStop(1, '#060408');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Shadow creep: the terminator line slowly shifts
                        var termX = w * (0.48 + Math.sin(t * 0.015) * 0.04);
                        var shadowGrad = ctx.createLinearGradient(termX - w * 0.08, 0, termX + w * 0.08, 0);
                        shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                        shadowGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.15)');
                        shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        ctx.fillStyle = shadowGrad;
                        ctx.fillRect(0, 0, w, h);

                        // Craters on the surface (drawn as subtle circles)
                        ctx.save();
                        for (var i = 0; i < 18; i++) {
                            // Deterministic positions
                            var cx = (Math.sin(i * 7.3 + 1.2) * 0.5 + 0.5) * w;
                            var cy = h * 0.55 + (Math.sin(i * 4.1 + 2.8) * 0.5 + 0.5) * h * 0.4;
                            var cr = 8 + (Math.sin(i * 3.7) * 0.5 + 0.5) * 35;
                            // Side of the terminator determines brightness
                            var brightness = cx < termX ? 0.08 : 0.04;
                            ctx.beginPath();
                            ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(180, 160, 140, ' + brightness + ')';
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                            // Crater shadow
                            ctx.beginPath();
                            ctx.arc(cx + cr * 0.15, cy + cr * 0.1, cr * 0.9, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(0, 0, 0, ' + (brightness * 0.4) + ')';
                            ctx.fill();
                        }
                        ctx.restore();

                        // White-hot sun on the left edge
                        var sunGrad = ctx.createRadialGradient(-w * 0.15, h * 0.3, 0, -w * 0.15, h * 0.3, w * 0.5);
                        sunGrad.addColorStop(0, 'rgba(255, 255, 240, 0.3)');
                        sunGrad.addColorStop(0.2, 'rgba(255, 250, 220, 0.12)');
                        sunGrad.addColorStop(0.5, 'rgba(255, 240, 200, 0.04)');
                        sunGrad.addColorStop(1, 'rgba(255, 220, 180, 0)');
                        ctx.fillStyle = sunGrad;
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        // Micro-meteorite impacts: brief bright flashes on the surface
                        // Spawn new impacts occasionally
                        if (Math.random() < dt * 0.15 && impacts.length < MAX_IMPACTS) {
                            impacts.push({
                                x: Math.random() * w,
                                y: h * 0.5 + Math.random() * h * 0.45,
                                life: 0,
                                maxLife: 0.3 + Math.random() * 0.3,
                                size: 3 + Math.random() * 8
                            });
                        }
                        for (var i = impacts.length - 1; i >= 0; i--) {
                            var imp = impacts[i];
                            imp.life += dt;
                            if (imp.life >= imp.maxLife) {
                                impacts.splice(i, 1);
                                continue;
                            }
                            var prog = imp.life / imp.maxLife;
                            var fade = 1 - prog;
                            var impGrad = ctx.createRadialGradient(imp.x, imp.y, 0, imp.x, imp.y, imp.size * (1 + prog));
                            impGrad.addColorStop(0, 'rgba(255, 255, 240, ' + (fade * 0.7) + ')');
                            impGrad.addColorStop(0.4, 'rgba(255, 200, 120, ' + (fade * 0.3) + ')');
                            impGrad.addColorStop(1, 'rgba(255, 150, 80, 0)');
                            ctx.beginPath();
                            ctx.arc(imp.x, imp.y, imp.size * (1 + prog), 0, Math.PI * 2);
                            ctx.fillStyle = impGrad;
                            ctx.fill();
                        }
                    }
                };
            })();

            // --- Venusian theme ---
            // Thick swirling sulfuric-yellow/orange atmosphere with deep lightning
            themes.venusian = (function () {
                // Deep lightning state
                var deepLightning = {
                    active: false,
                    opacity: 0,
                    x: 0,
                    y: 0,
                    timer: 4 + Math.random() * 8
                };

                // Cloud band configs
                var cloudBands = [
                    { yBase: 0.15, amp: 25, freq: 0.003, speed: 0.08, opacity: 0.06 },
                    { yBase: 0.28, amp: 30, freq: 0.0025, speed: 0.06, opacity: 0.07 },
                    { yBase: 0.40, amp: 20, freq: 0.004, speed: 0.10, opacity: 0.05 },
                    { yBase: 0.52, amp: 35, freq: 0.002, speed: 0.05, opacity: 0.08 },
                    { yBase: 0.65, amp: 28, freq: 0.0035, speed: 0.07, opacity: 0.06 },
                    { yBase: 0.78, amp: 22, freq: 0.003, speed: 0.09, opacity: 0.07 },
                    { yBase: 0.88, amp: 18, freq: 0.0045, speed: 0.11, opacity: 0.05 }
                ];

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        deepLightning.active = false;
                        deepLightning.opacity = 0;
                        deepLightning.timer = 4 + Math.random() * 8;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Thick sulfuric yellow-orange atmosphere gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#8a6a20');
                        grad.addColorStop(0.2, '#9e7828');
                        grad.addColorStop(0.4, '#b08830');
                        grad.addColorStop(0.6, '#c49838');
                        grad.addColorStop(0.8, '#a07828');
                        grad.addColorStop(1, '#7a5818');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Diffused hazy glow overlay
                        var hazeGrad = ctx.createRadialGradient(w * 0.5, h * 0.3, 0, w * 0.5, h * 0.3, Math.max(w, h) * 0.7);
                        hazeGrad.addColorStop(0, 'rgba(220, 190, 100, 0.08)');
                        hazeGrad.addColorStop(0.5, 'rgba(200, 170, 80, 0.04)');
                        hazeGrad.addColorStop(1, 'rgba(180, 150, 60, 0)');
                        ctx.fillStyle = hazeGrad;
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;

                        // Scrolling cloud bands at different speeds
                        for (var i = 0; i < cloudBands.length; i++) {
                            var cb = cloudBands[i];
                            var baseY = h * cb.yBase;
                            ctx.beginPath();
                            ctx.moveTo(0, h);
                            for (var x = 0; x <= w; x += 4) {
                                var y = baseY
                                    + Math.sin(x * cb.freq + t * cb.speed) * cb.amp
                                    + Math.sin(x * cb.freq * 0.6 + t * cb.speed * 1.4 + i * 1.2) * cb.amp * 0.5
                                    + Math.cos(x * cb.freq * 0.3 + t * cb.speed * 0.8 + i * 2.5) * cb.amp * 0.3;
                                ctx.lineTo(x, y);
                            }
                            ctx.lineTo(w, h);
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(180, 150, 60, ' + cb.opacity + ')';
                            ctx.fill();
                        }

                        // Swirling haze particles (deterministic)
                        for (var i = 0; i < 40; i++) {
                            var sx = (Math.sin(i * 5.7 + t * 0.03) * 0.5 + 0.5) * w;
                            var sy = (Math.sin(i * 3.3 + t * 0.02 + 1.8) * 0.5 + 0.5) * h;
                            var sOp = (Math.sin(t * 0.8 + i * 2.3) * 0.5 + 0.5) * 0.06;
                            var sR = 20 + Math.sin(i * 2.1) * 15;
                            var swGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, sR);
                            swGrad.addColorStop(0, 'rgba(200, 180, 80, ' + sOp + ')');
                            swGrad.addColorStop(1, 'rgba(180, 160, 60, 0)');
                            ctx.beginPath();
                            ctx.arc(sx, sy, sR, 0, Math.PI * 2);
                            ctx.fillStyle = swGrad;
                            ctx.fill();
                        }

                        // Deep lightning flickers within clouds
                        deepLightning.timer -= dt;
                        if (!deepLightning.active && deepLightning.timer <= 0) {
                            deepLightning.active = true;
                            deepLightning.opacity = 0.15 + Math.random() * 0.15;
                            deepLightning.x = w * (0.2 + Math.random() * 0.6);
                            deepLightning.y = h * (0.2 + Math.random() * 0.6);
                            deepLightning.timer = 4 + Math.random() * 8;
                        }
                        if (deepLightning.active) {
                            var lgGrad = ctx.createRadialGradient(deepLightning.x, deepLightning.y, 0, deepLightning.x, deepLightning.y, w * 0.2);
                            lgGrad.addColorStop(0, 'rgba(255, 240, 180, ' + deepLightning.opacity + ')');
                            lgGrad.addColorStop(0.3, 'rgba(255, 220, 140, ' + (deepLightning.opacity * 0.5) + ')');
                            lgGrad.addColorStop(1, 'rgba(255, 200, 100, 0)');
                            ctx.beginPath();
                            ctx.arc(deepLightning.x, deepLightning.y, w * 0.2, 0, Math.PI * 2);
                            ctx.fillStyle = lgGrad;
                            ctx.fill();
                            deepLightning.opacity -= 2.5 * dt;
                            if (deepLightning.opacity <= 0) {
                                deepLightning.active = false;
                                deepLightning.opacity = 0;
                            }
                        }
                    }
                };
            })();

            // --- Martian theme ---
            // Rust-red dust storms, mesa silhouettes, butterscotch sky
            themes.martian = (function () {
                // Dust devil state
                var dustDevils = [];
                var MAX_DEVILS = 2;

                // Mesa silhouette configs
                var mesas = [
                    { x: 0.08, w: 0.06, h: 0.12, flat: 0.04 },
                    { x: 0.22, w: 0.08, h: 0.18, flat: 0.05 },
                    { x: 0.45, w: 0.05, h: 0.10, flat: 0.03 },
                    { x: 0.62, w: 0.10, h: 0.22, flat: 0.06 },
                    { x: 0.80, w: 0.07, h: 0.14, flat: 0.04 },
                    { x: 0.92, w: 0.06, h: 0.09, flat: 0.03 }
                ];

                function getWindStrength(t) {
                    return 1.0 + Math.sin(t * 0.2) * 0.5 + Math.sin(t * 0.5 + 1.5) * 0.3;
                }

                return {
                    targetCount: 60,

                    spawn: function (w, h) {
                        return {
                            x: -10 - Math.random() * w * 0.3,
                            y: Math.random() * h,
                            size: 0.5 + Math.random() * 2,
                            speed: 40 + Math.random() * 80,
                            drift: -3 + Math.random() * 6,
                            opacity: 0.15 + Math.random() * 0.3,
                            wobbleSpeed: 0.3 + Math.random() * 0.5,
                            wobbleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        var wind = getWindStrength(state.timeElapsed);
                        p.x += p.speed * wind * dt;
                        p.y += (p.drift + Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * 4) * dt;
                        if (p.x > w + 10) return false;
                        if (p.y < 0) p.y = h;
                        if (p.y > h) p.y = 0;
                        return true;
                    },

                    draw: function (p, ctx) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(180, 100, 60, ' + p.opacity + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Butterscotch sky gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#c8a060');
                        grad.addColorStop(0.3, '#b88848');
                        grad.addColorStop(0.5, '#a06838');
                        grad.addColorStop(0.7, '#884830');
                        grad.addColorStop(1, '#6a3020');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Pale distant sun
                        var sunX = w * 0.7;
                        var sunY = h * 0.18;
                        var sunR = Math.min(w, h) * 0.035;
                        var sunGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR * 6);
                        sunGlow.addColorStop(0, 'rgba(255, 240, 200, 0.2)');
                        sunGlow.addColorStop(0.3, 'rgba(255, 230, 180, 0.08)');
                        sunGlow.addColorStop(1, 'rgba(255, 220, 160, 0)');
                        ctx.beginPath();
                        ctx.arc(sunX, sunY, sunR * 6, 0, Math.PI * 2);
                        ctx.fillStyle = sunGlow;
                        ctx.fill();
                        var sunBody = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
                        sunBody.addColorStop(0, 'rgba(255, 245, 220, 0.6)');
                        sunBody.addColorStop(0.7, 'rgba(255, 235, 200, 0.3)');
                        sunBody.addColorStop(1, 'rgba(255, 225, 180, 0.1)');
                        ctx.beginPath();
                        ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
                        ctx.fillStyle = sunBody;
                        ctx.fill();

                        // Mesa/canyon silhouettes at the horizon
                        var horizonY = h * 0.72;
                        // Flat terrain below horizon
                        ctx.fillStyle = 'rgba(90, 40, 25, 0.6)';
                        ctx.fillRect(0, horizonY, w, h - horizonY);

                        for (var i = 0; i < mesas.length; i++) {
                            var m = mesas[i];
                            var mx = m.x * w;
                            var mw = m.w * w;
                            var mh = m.h * h;
                            var flat = m.flat * w;
                            ctx.beginPath();
                            ctx.moveTo(mx, horizonY);
                            ctx.lineTo(mx + mw * 0.2, horizonY - mh);
                            ctx.lineTo(mx + mw * 0.2 + flat, horizonY - mh);
                            ctx.lineTo(mx + mw, horizonY);
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(70, 30, 18, 0.7)';
                            ctx.fill();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        // Dust devils - spiraling columns of dust
                        if (Math.random() < dt * 0.03 && dustDevils.length < MAX_DEVILS) {
                            dustDevils.push({
                                x: Math.random() * w,
                                baseY: h * 0.72,
                                life: 0,
                                maxLife: 4 + Math.random() * 4,
                                height: h * (0.15 + Math.random() * 0.2),
                                width: 10 + Math.random() * 15,
                                speed: 15 + Math.random() * 25
                            });
                        }
                        for (var i = dustDevils.length - 1; i >= 0; i--) {
                            var dd = dustDevils[i];
                            dd.life += dt;
                            dd.x += dd.speed * dt;
                            if (dd.life >= dd.maxLife || dd.x > w + 50) {
                                dustDevils.splice(i, 1);
                                continue;
                            }
                            var fade = Math.min(1, dd.life * 2) * Math.max(0, 1 - (dd.life / dd.maxLife));
                            // Draw as a tapered column of semi-transparent particles
                            for (var j = 0; j < 20; j++) {
                                var frac = j / 20;
                                var py = dd.baseY - frac * dd.height;
                                var spread = dd.width * (1 - frac * 0.6);
                                var px = dd.x + Math.sin(t * 3 + frac * 8) * spread;
                                var pOp = fade * (0.08 + (1 - frac) * 0.08);
                                ctx.beginPath();
                                ctx.arc(px, py, 2 + (1 - frac) * 3, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(160, 90, 50, ' + pOp + ')';
                                ctx.fill();
                            }
                        }
                    }
                };
            })();

            // --- Jovian theme ---
            // Horizontal banded stripes, Great Red Spot, turbulent swirls
            themes.jovian = (function () {
                // Band configurations (color, y-position, scroll speed)
                var bands = [
                    { yStart: 0.00, yEnd: 0.08, r: 200, g: 180, b: 140, speed: 0.012 },
                    { yStart: 0.08, yEnd: 0.18, r: 160, g: 120, b: 80,  speed: -0.008 },
                    { yStart: 0.18, yEnd: 0.28, r: 210, g: 190, b: 150, speed: 0.015 },
                    { yStart: 0.28, yEnd: 0.38, r: 180, g: 130, b: 80,  speed: -0.010 },
                    { yStart: 0.38, yEnd: 0.48, r: 220, g: 200, b: 160, speed: 0.018 },
                    { yStart: 0.48, yEnd: 0.55, r: 190, g: 100, b: 60,  speed: -0.006 },
                    { yStart: 0.55, yEnd: 0.65, r: 210, g: 180, b: 130, speed: 0.014 },
                    { yStart: 0.65, yEnd: 0.75, r: 170, g: 120, b: 70,  speed: -0.012 },
                    { yStart: 0.75, yEnd: 0.85, r: 200, g: 185, b: 145, speed: 0.010 },
                    { yStart: 0.85, yEnd: 1.00, r: 155, g: 110, b: 65,  speed: -0.009 }
                ];

                // Impact flash state
                var impactFlash = { active: false, opacity: 0, x: 0, y: 0, timer: 20 + Math.random() * 30 };

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        impactFlash.active = false;
                        impactFlash.timer = 20 + Math.random() * 30;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Base warm gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#c8a870');
                        grad.addColorStop(0.5, '#a88050');
                        grad.addColorStop(1, '#886030');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Draw scrolling bands
                        for (var i = 0; i < bands.length; i++) {
                            var b = bands[i];
                            var y1 = b.yStart * h;
                            var y2 = b.yEnd * h;
                            var bandH = y2 - y1;

                            // Wavy band edges
                            ctx.beginPath();
                            for (var x = 0; x <= w; x += 4) {
                                var edgeWave = Math.sin((x + t * b.speed * w) * 0.008 + i * 1.5) * 4
                                    + Math.sin((x + t * b.speed * w * 0.7) * 0.015 + i * 2.3) * 2;
                                if (x === 0) ctx.moveTo(x, y1 + edgeWave);
                                else ctx.lineTo(x, y1 + edgeWave);
                            }
                            for (var x = w; x >= 0; x -= 4) {
                                var edgeWave2 = Math.sin((x + t * b.speed * w) * 0.008 + i * 1.5 + 1.0) * 4
                                    + Math.sin((x + t * b.speed * w * 0.7) * 0.015 + i * 2.3 + 1.0) * 2;
                                ctx.lineTo(x, y2 + edgeWave2);
                            }
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(' + b.r + ', ' + b.g + ', ' + b.b + ', 0.35)';
                            ctx.fill();
                        }

                        // Great Red Spot - oval that drifts across
                        var spotX = (w * 0.5 + Math.sin(t * 0.02) * w * 0.3);
                        var spotY = h * 0.52;
                        var spotRx = w * 0.07;
                        var spotRy = h * 0.05;
                        ctx.save();
                        ctx.translate(spotX, spotY);
                        ctx.scale(1, spotRy / spotRx);
                        var spotGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, spotRx);
                        spotGrad.addColorStop(0, 'rgba(200, 80, 40, 0.25)');
                        spotGrad.addColorStop(0.4, 'rgba(180, 60, 30, 0.18)');
                        spotGrad.addColorStop(0.7, 'rgba(160, 50, 25, 0.08)');
                        spotGrad.addColorStop(1, 'rgba(140, 40, 20, 0)');
                        ctx.beginPath();
                        ctx.arc(0, 0, spotRx, 0, Math.PI * 2);
                        ctx.fillStyle = spotGrad;
                        ctx.fill();
                        // Swirl lines inside the spot
                        ctx.rotate(t * 0.1);
                        for (var s = 0; s < 5; s++) {
                            var sAngle = (s / 5) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, spotRx * (0.3 + s * 0.12), sAngle, sAngle + Math.PI * 0.8);
                            ctx.strokeStyle = 'rgba(220, 100, 50, 0.06)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Turbulent swirls at band edges
                        for (var i = 0; i < 25; i++) {
                            var sx = (Math.sin(i * 6.3 + t * 0.04) * 0.5 + 0.5) * w;
                            var sy = (Math.sin(i * 4.1 + 0.7) * 0.5 + 0.5) * h;
                            var sOp = (Math.sin(t * 0.6 + i * 1.9) * 0.5 + 0.5) * 0.04;
                            var sR = 15 + Math.sin(i * 2.8) * 10;
                            ctx.beginPath();
                            ctx.arc(sx, sy, sR, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(210, 180, 130, ' + sOp + ')';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        // Rare bright impact flashes
                        impactFlash.timer -= dt;
                        if (!impactFlash.active && impactFlash.timer <= 0) {
                            impactFlash.active = true;
                            impactFlash.opacity = 0.2 + Math.random() * 0.15;
                            impactFlash.x = Math.random() * w;
                            impactFlash.y = Math.random() * h;
                            impactFlash.timer = 20 + Math.random() * 30;
                        }
                        if (impactFlash.active) {
                            var fGrad = ctx.createRadialGradient(impactFlash.x, impactFlash.y, 0, impactFlash.x, impactFlash.y, 30);
                            fGrad.addColorStop(0, 'rgba(255, 255, 220, ' + impactFlash.opacity + ')');
                            fGrad.addColorStop(0.5, 'rgba(255, 240, 180, ' + (impactFlash.opacity * 0.4) + ')');
                            fGrad.addColorStop(1, 'rgba(255, 220, 140, 0)');
                            ctx.beginPath();
                            ctx.arc(impactFlash.x, impactFlash.y, 30, 0, Math.PI * 2);
                            ctx.fillStyle = fGrad;
                            ctx.fill();
                            impactFlash.opacity -= 1.5 * dt;
                            if (impactFlash.opacity <= 0) {
                                impactFlash.active = false;
                                impactFlash.opacity = 0;
                            }
                        }
                    }
                };
            })();

            // --- Saturnine theme ---
            // Pale gold planet body with elegant ring arcs, ice particles glitter
            themes.saturnine = {
                targetCount: 50,

                spawn: function (w, h) {
                    // Ice particles drifting within the ring plane
                    var angle = Math.random() * Math.PI * 2;
                    var dist = w * (0.2 + Math.random() * 0.35);
                    return {
                        x: w * 0.5 + Math.cos(angle) * dist,
                        y: h * 0.45 + Math.sin(angle) * dist * 0.15, // flattened to ring plane
                        size: 0.5 + Math.random() * 2,
                        orbitSpeed: 0.02 + Math.random() * 0.04,
                        orbitAngle: angle,
                        orbitDist: dist,
                        opacity: 0.2 + Math.random() * 0.5,
                        twinkleSpeed: 1 + Math.random() * 2,
                        twinkleOffset: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.orbitAngle += p.orbitSpeed * dt;
                    p.x = w * 0.5 + Math.cos(p.orbitAngle) * p.orbitDist;
                    p.y = h * 0.45 + Math.sin(p.orbitAngle) * p.orbitDist * 0.15;
                    return true;
                },

                draw: function (p, ctx, state) {
                    var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                    var op = p.opacity * (0.4 + twinkle * 0.6);
                    if (op < 0.03) return;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(230, 240, 255, ' + op + ')';
                    ctx.fill();
                    if (p.size > 1 && op > 0.3) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(200, 220, 255, ' + (op * 0.1) + ')';
                        ctx.fill();
                    }
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Dark space background
                    var grad = ctx.createRadialGradient(w * 0.5, h * 0.45, 0, w * 0.5, h * 0.45, Math.max(w, h));
                    grad.addColorStop(0, '#0c0a12');
                    grad.addColorStop(0.3, '#08060e');
                    grad.addColorStop(1, '#040308');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Background stars
                    for (var i = 0; i < 80; i++) {
                        var sx = (Math.sin(i * 7.1 + 0.5) * 0.5 + 0.5) * w;
                        var sy = (Math.sin(i * 11.3 + 2.1) * 0.5 + 0.5) * h;
                        var sOp = (Math.sin(t * (0.5 + i * 0.03) + i * 1.7) * 0.5 + 0.5) * 0.4;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 0.5 + Math.sin(i * 2.3) * 0.5, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + sOp + ')';
                        ctx.fill();
                    }

                    // Saturn body - pale gold planet
                    var cx = w * 0.5;
                    var cy = h * 0.45;
                    var planetR = Math.min(w, h) * 0.15;
                    var planetGrad = ctx.createRadialGradient(cx - planetR * 0.2, cy - planetR * 0.1, 0, cx, cy, planetR);
                    planetGrad.addColorStop(0, '#e8d8a8');
                    planetGrad.addColorStop(0.3, '#d8c890');
                    planetGrad.addColorStop(0.6, '#c8b878');
                    planetGrad.addColorStop(0.85, '#b8a868');
                    planetGrad.addColorStop(1, '#a09058');
                    ctx.beginPath();
                    ctx.arc(cx, cy, planetR, 0, Math.PI * 2);
                    ctx.fillStyle = planetGrad;
                    ctx.fill();

                    // Subtle banding on the planet
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(cx, cy, planetR, 0, Math.PI * 2);
                    ctx.clip();
                    for (var i = 0; i < 8; i++) {
                        var bandY = cy - planetR + (i / 8) * planetR * 2;
                        ctx.fillStyle = (i % 2 === 0) ? 'rgba(180, 160, 120, 0.06)' : 'rgba(200, 180, 140, 0.04)';
                        ctx.fillRect(cx - planetR, bandY, planetR * 2, planetR * 2 / 8);
                    }
                    ctx.restore();

                    // Ring system - elegant elliptical arcs
                    ctx.save();
                    ctx.translate(cx, cy);
                    // Ring shadow on planet (behind planet is already covered)
                    // Draw rings
                    var ringColors = [
                        { inner: 1.3, outer: 1.5, opacity: 0.12 },
                        { inner: 1.55, outer: 1.9, opacity: 0.18 },
                        { inner: 1.95, outer: 2.1, opacity: 0.08 },
                        { inner: 2.15, outer: 2.6, opacity: 0.15 },
                        { inner: 2.65, outer: 2.8, opacity: 0.06 }
                    ];
                    for (var r = 0; r < ringColors.length; r++) {
                        var ring = ringColors[r];
                        var innerR = planetR * ring.inner;
                        var outerR = planetR * ring.outer;
                        // Draw as a flattened elliptical ring
                        ctx.beginPath();
                        ctx.ellipse(0, 0, outerR, outerR * 0.15, 0, 0, Math.PI * 2);
                        ctx.ellipse(0, 0, innerR, innerR * 0.15, 0, 0, Math.PI * 2);
                        // Use even-odd rule to create ring shape
                        ctx.fillStyle = 'rgba(200, 190, 170, ' + ring.opacity + ')';
                        ctx.fill('evenodd');
                    }
                    ctx.restore();

                    // Shadow of rings on planet body
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(cx, cy, planetR, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy - planetR * 0.15, planetR * 2.6, planetR * 2.6 * 0.15, 0, Math.PI, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Neptunian theme ---
            // Deep electric-blue with racing white clouds and a faint dark spot
            themes.neptunian = {
                targetCount: 40,

                spawn: function (w, h) {
                    // Methane-blue shimmering particles
                    return {
                        x: Math.random() * w,
                        y: Math.random() * h,
                        size: 1 + Math.random() * 3,
                        opacity: 0.1 + Math.random() * 0.2,
                        twinkleSpeed: 0.8 + Math.random() * 2,
                        twinkleOffset: Math.random() * Math.PI * 2,
                        driftX: (Math.random() - 0.5) * 5,
                        driftY: (Math.random() - 0.5) * 3
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.x += p.driftX * dt;
                    p.y += p.driftY * dt;
                    if (p.x < -5) p.x = w + 5;
                    if (p.x > w + 5) p.x = -5;
                    if (p.y < -5) p.y = h + 5;
                    if (p.y > h + 5) p.y = -5;
                    return true;
                },

                draw: function (p, ctx, state) {
                    var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                    var op = p.opacity * (0.4 + twinkle * 0.6);
                    if (op < 0.02) return;
                    var grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
                    grad.addColorStop(0, 'rgba(100, 180, 255, ' + op + ')');
                    grad.addColorStop(1, 'rgba(60, 140, 220, 0)');
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = grad;
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Deep electric blue gradient
                    var grad = ctx.createRadialGradient(w * 0.5, h * 0.5, 0, w * 0.5, h * 0.5, Math.max(w, h) * 0.7);
                    grad.addColorStop(0, '#1840a0');
                    grad.addColorStop(0.3, '#143588');
                    grad.addColorStop(0.6, '#102870');
                    grad.addColorStop(1, '#0a1848');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Subtle darker bands
                    for (var i = 0; i < 6; i++) {
                        var bandY = h * (0.1 + i * 0.15);
                        var bandH = h * 0.06;
                        ctx.fillStyle = 'rgba(10, 20, 60, 0.12)';
                        ctx.beginPath();
                        for (var x = 0; x <= w; x += 4) {
                            var by = bandY + Math.sin(x * 0.005 + t * 0.03 + i * 2) * 8;
                            if (x === 0) ctx.moveTo(x, by);
                            else ctx.lineTo(x, by);
                        }
                        for (var x = w; x >= 0; x -= 4) {
                            var by2 = bandY + bandH + Math.sin(x * 0.005 + t * 0.03 + i * 2 + 0.5) * 8;
                            ctx.lineTo(x, by2);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Faint dark spot drifting slowly
                    var spotX = w * (0.4 + Math.sin(t * 0.01) * 0.15);
                    var spotY = h * 0.55;
                    var spotGrad = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, w * 0.05);
                    spotGrad.addColorStop(0, 'rgba(10, 20, 50, 0.2)');
                    spotGrad.addColorStop(0.5, 'rgba(10, 20, 50, 0.1)');
                    spotGrad.addColorStop(1, 'rgba(10, 20, 50, 0)');
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, w * 0.05, 0, Math.PI * 2);
                    ctx.fillStyle = spotGrad;
                    ctx.fill();
                },

                drawForeground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Wispy white cloud streaks racing across at high speed
                    for (var i = 0; i < 8; i++) {
                        var cloudY = h * (0.1 + (Math.sin(i * 5.7 + 1.3) * 0.5 + 0.5) * 0.8);
                        var cloudSpeed = 80 + i * 30;
                        var cloudX = ((t * cloudSpeed + i * w * 0.3) % (w * 1.5)) - w * 0.25;
                        var cloudLen = w * (0.1 + Math.sin(i * 3.2) * 0.05);
                        var cloudOp = 0.04 + Math.sin(t * 0.5 + i * 1.8) * 0.02;

                        ctx.beginPath();
                        ctx.moveTo(cloudX, cloudY);
                        for (var x = 0; x <= cloudLen; x += 4) {
                            var cy = cloudY + Math.sin(x * 0.02 + t * 2 + i) * 3;
                            ctx.lineTo(cloudX + x, cy);
                        }
                        ctx.strokeStyle = 'rgba(220, 240, 255, ' + cloudOp + ')';
                        ctx.lineWidth = 6 + Math.sin(i * 2.1) * 3;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                    }
                }
            };

            // --- Europan theme ---
            // Icy cracked surface, water geysers, Jupiter looming in sky
            themes.europan = (function () {
                // Geyser state
                var geysers = [];
                var MAX_GEYSERS = 3;
                var geyserTimer = 3 + Math.random() * 5;

                // Crack line configs (deterministic)
                var cracks = [];
                for (var i = 0; i < 15; i++) {
                    cracks.push({
                        x1: Math.sin(i * 5.7 + 1.2) * 0.5 + 0.5,
                        y1: 0.55 + (Math.sin(i * 3.3 + 0.8) * 0.5 + 0.5) * 0.4,
                        angle: Math.sin(i * 4.1 + 2.5) * Math.PI * 0.4,
                        length: 0.05 + (Math.sin(i * 2.9 + 1.1) * 0.5 + 0.5) * 0.15,
                        branches: Math.floor(2 + Math.sin(i * 6.3) * 2)
                    });
                }

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        geysers.length = 0;
                        geyserTimer = 3 + Math.random() * 5;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Icy pale blue-white surface gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#0a0e18');
                        grad.addColorStop(0.35, '#101828');
                        grad.addColorStop(0.5, '#8098b8');
                        grad.addColorStop(0.65, '#a0b8d0');
                        grad.addColorStop(0.8, '#b8cce0');
                        grad.addColorStop(1, '#c8d8e8');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Jupiter looming in the sky as a massive banded crescent
                        var jx = w * 0.75;
                        var jy = h * 0.15;
                        var jr = Math.min(w, h) * 0.22;
                        // Jupiter body
                        var jupGrad = ctx.createRadialGradient(jx - jr * 0.3, jy, 0, jx, jy, jr);
                        jupGrad.addColorStop(0, 'rgba(200, 170, 120, 0.25)');
                        jupGrad.addColorStop(0.5, 'rgba(180, 140, 90, 0.15)');
                        jupGrad.addColorStop(0.8, 'rgba(160, 120, 70, 0.08)');
                        jupGrad.addColorStop(1, 'rgba(140, 100, 60, 0)');
                        ctx.beginPath();
                        ctx.arc(jx, jy, jr, 0, Math.PI * 2);
                        ctx.fillStyle = jupGrad;
                        ctx.fill();
                        // Jupiter bands
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(jx, jy, jr, 0, Math.PI * 2);
                        ctx.clip();
                        for (var i = 0; i < 8; i++) {
                            var by = jy - jr + (i / 8) * jr * 2;
                            ctx.fillStyle = (i % 2 === 0) ? 'rgba(180, 130, 70, 0.06)' : 'rgba(200, 160, 100, 0.04)';
                            ctx.fillRect(jx - jr, by, jr * 2, jr * 2 / 8);
                        }
                        ctx.restore();
                        // Crescent shadow on Jupiter
                        ctx.beginPath();
                        ctx.arc(jx + jr * 0.5, jy, jr * 0.85, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(10, 14, 24, 0.2)';
                        ctx.fill();

                        // Fracture/crack lines on the surface
                        ctx.save();
                        ctx.lineWidth = 1;
                        ctx.lineCap = 'round';
                        for (var i = 0; i < cracks.length; i++) {
                            var c = cracks[i];
                            var cx = c.x1 * w;
                            var cy = c.y1 * h;
                            var len = c.length * w;
                            // Shift slightly over time
                            var shift = Math.sin(t * 0.02 + i * 1.5) * 5;

                            ctx.strokeStyle = 'rgba(120, 70, 50, 0.12)';
                            ctx.beginPath();
                            ctx.moveTo(cx + shift, cy);
                            var ex = cx + shift + Math.cos(c.angle) * len;
                            var ey = cy + Math.sin(c.angle) * len;
                            ctx.lineTo(ex, ey);
                            ctx.stroke();

                            // Branches
                            for (var b = 0; b < c.branches; b++) {
                                var bFrac = (b + 1) / (c.branches + 1);
                                var bx = cx + shift + Math.cos(c.angle) * len * bFrac;
                                var by = cy + Math.sin(c.angle) * len * bFrac;
                                var bAngle = c.angle + (Math.sin(i * 3.1 + b * 2.7) * 0.8);
                                var bLen = len * (0.2 + Math.sin(i * 2.3 + b * 1.9) * 0.15);
                                ctx.beginPath();
                                ctx.moveTo(bx, by);
                                ctx.lineTo(bx + Math.cos(bAngle) * bLen, by + Math.sin(bAngle) * bLen);
                                ctx.strokeStyle = 'rgba(120, 70, 50, 0.08)';
                                ctx.stroke();
                            }
                        }
                        ctx.restore();
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;

                        // Geyser eruptions
                        geyserTimer -= dt;
                        if (geyserTimer <= 0 && geysers.length < MAX_GEYSERS) {
                            geysers.push({
                                x: w * (0.2 + Math.random() * 0.6),
                                baseY: h * (0.65 + Math.random() * 0.2),
                                life: 0,
                                maxLife: 2 + Math.random() * 3,
                                height: h * (0.15 + Math.random() * 0.2),
                                spread: 15 + Math.random() * 20,
                                particleCount: 25
                            });
                            geyserTimer = 3 + Math.random() * 5;
                        }

                        for (var g = geysers.length - 1; g >= 0; g--) {
                            var gey = geysers[g];
                            gey.life += dt;
                            if (gey.life >= gey.maxLife) {
                                geysers.splice(g, 1);
                                continue;
                            }
                            var gProg = gey.life / gey.maxLife;
                            var gFade = gProg < 0.2 ? gProg / 0.2 : (gProg > 0.7 ? (1 - gProg) / 0.3 : 1);

                            // Draw geyser particles arcing upward
                            for (var p = 0; p < gey.particleCount; p++) {
                                var pFrac = p / gey.particleCount;
                                var pTime = (gey.life + pFrac * 0.5) * 2;
                                var px = gey.x + Math.sin(pFrac * 17 + t) * gey.spread * pFrac;
                                var py = gey.baseY - pFrac * gey.height + pFrac * pFrac * gey.height * 0.4; // arc
                                var pOp = gFade * (1 - pFrac) * 0.3;
                                ctx.beginPath();
                                ctx.arc(px, py, 1.5 + (1 - pFrac) * 2, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 230, 255, ' + pOp + ')';
                                ctx.fill();
                            }
                        }
                    }
                };
            })();

            // --- Titanesque theme ---
            // Thick orange-brown haze, methane rain, dark hydrocarbon lakes
            themes.titanesque = {
                targetCount: 60,

                spawn: function (w, h) {
                    // Methane rain drops - slow, heavy
                    return {
                        x: Math.random() * w,
                        y: -Math.random() * h * 0.3,
                        speed: 40 + Math.random() * 60,
                        length: 6 + Math.random() * 10,
                        opacity: 0.08 + Math.random() * 0.15,
                        drift: -2 + Math.random() * 4
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.y += p.speed * dt;
                    p.x += p.drift * dt;
                    if (p.y > h + 20) return false;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + p.drift * 0.1, p.y + p.length);
                    ctx.strokeStyle = 'rgba(160, 130, 80, ' + p.opacity + ')';
                    ctx.lineWidth = 1.5;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Thick orange-brown haze gradient
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#5a4020');
                    grad.addColorStop(0.2, '#6a4828');
                    grad.addColorStop(0.4, '#7a5530');
                    grad.addColorStop(0.6, '#685028');
                    grad.addColorStop(0.8, '#504020');
                    grad.addColorStop(1, '#382818');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Dim distant sun - occasional break in haze
                    var sunOp = 0.05 + Math.sin(t * 0.1) * 0.03;
                    var sunGrad = ctx.createRadialGradient(w * 0.35, h * 0.12, 0, w * 0.35, h * 0.12, Math.min(w, h) * 0.12);
                    sunGrad.addColorStop(0, 'rgba(255, 240, 200, ' + sunOp + ')');
                    sunGrad.addColorStop(0.5, 'rgba(255, 220, 160, ' + (sunOp * 0.4) + ')');
                    sunGrad.addColorStop(1, 'rgba(255, 200, 120, 0)');
                    ctx.beginPath();
                    ctx.arc(w * 0.35, h * 0.12, Math.min(w, h) * 0.12, 0, Math.PI * 2);
                    ctx.fillStyle = sunGrad;
                    ctx.fill();

                    // Haze layers (horizontal)
                    for (var i = 0; i < 10; i++) {
                        var hazeY = h * (i / 10);
                        var hazeOp = 0.03 + Math.sin(t * 0.08 + i * 1.5) * 0.015;
                        ctx.fillStyle = 'rgba(120, 90, 50, ' + hazeOp + ')';
                        ctx.fillRect(0, hazeY, w, h / 10);
                    }

                    // Dark hydrocarbon lake shapes at the bottom
                    var lakeY = h * 0.82;
                    ctx.beginPath();
                    ctx.moveTo(0, h);
                    for (var x = 0; x <= w; x += 4) {
                        var ly = lakeY + Math.sin(x * 0.005 + t * 0.04) * 12
                            + Math.sin(x * 0.012 + t * 0.07 + 1.5) * 6;
                        ctx.lineTo(x, ly);
                    }
                    ctx.lineTo(w, h);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(30, 22, 12, 0.5)';
                    ctx.fill();

                    // Lake ripples
                    for (var i = 0; i < 5; i++) {
                        var rx = w * (0.15 + i * 0.18);
                        var ry = lakeY + 15 + Math.sin(t * 0.3 + i * 2) * 5;
                        ctx.beginPath();
                        ctx.ellipse(rx, ry, 20 + Math.sin(t * 0.5 + i) * 5, 3, 0, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(80, 60, 35, 0.08)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Ionian theme ---
            // Sulfurous yellow-green surface, volcanic plumes, Jupiter looming
            themes.ionian = (function () {
                // Volcanic eruption particles
                var eruptions = [];
                var MAX_ERUPTIONS = 2;
                var eruptTimer = 1 + Math.random() * 3;

                // Lava glow spots
                var lavaSpots = [];
                for (var i = 0; i < 8; i++) {
                    lavaSpots.push({
                        x: (Math.sin(i * 5.3 + 1.7) * 0.5 + 0.5),
                        y: 0.7 + (Math.sin(i * 3.9 + 0.4) * 0.5 + 0.5) * 0.25,
                        size: 0.01 + (Math.sin(i * 2.7) * 0.5 + 0.5) * 0.02,
                        pulseSpeed: 0.5 + Math.sin(i * 4.1) * 0.3,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        eruptions.length = 0;
                        eruptTimer = 1 + Math.random() * 3;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Sulfurous yellow-green surface
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#0a0c14');
                        grad.addColorStop(0.3, '#101418');
                        grad.addColorStop(0.55, '#686030');
                        grad.addColorStop(0.7, '#8a8028');
                        grad.addColorStop(0.85, '#a09030');
                        grad.addColorStop(1, '#807020');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Jupiter looming huge in the sky
                        var jx = w * 0.3;
                        var jy = h * 0.05;
                        var jr = Math.min(w, h) * 0.35;
                        var jupGrad = ctx.createRadialGradient(jx, jy + jr * 0.3, 0, jx, jy, jr);
                        jupGrad.addColorStop(0, 'rgba(200, 170, 110, 0.2)');
                        jupGrad.addColorStop(0.4, 'rgba(180, 140, 80, 0.12)');
                        jupGrad.addColorStop(0.7, 'rgba(160, 120, 60, 0.06)');
                        jupGrad.addColorStop(1, 'rgba(140, 100, 50, 0)');
                        ctx.beginPath();
                        ctx.arc(jx, jy, jr, 0, Math.PI * 2);
                        ctx.fillStyle = jupGrad;
                        ctx.fill();
                        // Jupiter bands
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(jx, jy, jr, 0, Math.PI * 2);
                        ctx.clip();
                        for (var i = 0; i < 10; i++) {
                            var by = jy - jr + (i / 10) * jr * 2;
                            ctx.fillStyle = (i % 2 === 0) ? 'rgba(170, 120, 60, 0.04)' : 'rgba(190, 150, 90, 0.03)';
                            ctx.fillRect(jx - jr, by, jr * 2, jr * 2 / 10);
                        }
                        ctx.restore();

                        // Lava glow spots on the surface
                        for (var i = 0; i < lavaSpots.length; i++) {
                            var ls = lavaSpots[i];
                            var lx = ls.x * w;
                            var ly = ls.y * h;
                            var lr = ls.size * Math.min(w, h);
                            var pulse = Math.sin(t * ls.pulseSpeed + ls.pulseOffset);
                            var lOp = 0.15 + pulse * 0.1;
                            var lGrad = ctx.createRadialGradient(lx, ly, 0, lx, ly, lr * (2 + pulse * 0.5));
                            lGrad.addColorStop(0, 'rgba(255, 120, 20, ' + lOp + ')');
                            lGrad.addColorStop(0.3, 'rgba(255, 80, 10, ' + (lOp * 0.6) + ')');
                            lGrad.addColorStop(0.6, 'rgba(200, 50, 5, ' + (lOp * 0.3) + ')');
                            lGrad.addColorStop(1, 'rgba(150, 30, 0, 0)');
                            ctx.beginPath();
                            ctx.arc(lx, ly, lr * (2 + pulse * 0.5), 0, Math.PI * 2);
                            ctx.fillStyle = lGrad;
                            ctx.fill();
                            // Core bright spot
                            ctx.beginPath();
                            ctx.arc(lx, ly, lr * 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 200, 80, ' + (lOp * 0.5) + ')';
                            ctx.fill();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;

                        // Volcanic eruption particles - fountain arcs
                        eruptTimer -= dt;
                        if (eruptTimer <= 0 && eruptions.length < MAX_ERUPTIONS) {
                            var eruptX = w * (0.15 + Math.random() * 0.7);
                            var particles = [];
                            for (var i = 0; i < 30; i++) {
                                var angle = -Math.PI * 0.3 - Math.random() * Math.PI * 0.4;
                                var speed = 100 + Math.random() * 200;
                                particles.push({
                                    x: eruptX,
                                    y: h * (0.65 + Math.random() * 0.1),
                                    vx: Math.cos(angle) * speed * (0.5 + Math.random()),
                                    vy: Math.sin(angle) * speed * (0.5 + Math.random()),
                                    size: 1 + Math.random() * 3,
                                    opacity: 0.5 + Math.random() * 0.5
                                });
                            }
                            eruptions.push({
                                particles: particles,
                                life: 0,
                                maxLife: 3 + Math.random() * 2
                            });
                            eruptTimer = 2 + Math.random() * 4;
                        }

                        for (var e = eruptions.length - 1; e >= 0; e--) {
                            var erupt = eruptions[e];
                            erupt.life += dt;
                            if (erupt.life >= erupt.maxLife) {
                                eruptions.splice(e, 1);
                                continue;
                            }
                            var eFade = erupt.life > erupt.maxLife * 0.6 ? (1 - (erupt.life - erupt.maxLife * 0.6) / (erupt.maxLife * 0.4)) : 1;
                            for (var p = 0; p < erupt.particles.length; p++) {
                                var ep = erupt.particles[p];
                                ep.x += ep.vx * dt;
                                ep.y += ep.vy * dt;
                                ep.vy += 80 * dt; // gravity
                                var pOp = ep.opacity * eFade;
                                if (pOp < 0.02) continue;
                                ctx.beginPath();
                                ctx.arc(ep.x, ep.y, ep.size, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(255, ' + Math.floor(100 + Math.random() * 80) + ', 20, ' + pOp + ')';
                                ctx.fill();
                            }
                        }
                    }
                };
            })();

            // --- Enceladean theme ---
            // Brilliant white ice surface, dramatic ice geysers, Saturn's rings in sky
            themes.enceladean = (function () {
                // Geyser state
                var geysers = [];
                var MAX_GEYSERS = 4;
                var geyserTimer = 1 + Math.random() * 2;

                return {
                    targetCount: 35,

                    spawn: function (w, h) {
                        // Tiny ice crystal particles
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.5 + Math.random() * 1.5,
                            opacity: 0.1 + Math.random() * 0.3,
                            twinkleSpeed: 1 + Math.random() * 3,
                            twinkleOffset: Math.random() * Math.PI * 2,
                            driftX: (Math.random() - 0.5) * 3,
                            driftY: -(1 + Math.random() * 3)
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.x += p.driftX * dt;
                        p.y += p.driftY * dt;
                        if (p.y < -5) return false;
                        if (p.x < -5) p.x = w + 5;
                        if (p.x > w + 5) p.x = -5;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.opacity * (0.3 + twinkle * 0.7);
                        if (op < 0.02) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(230, 245, 255, ' + op + ')';
                        ctx.fill();
                        if (op > 0.2) {
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(200, 225, 255, ' + (op * 0.08) + ')';
                            ctx.fill();
                        }
                    },

                    onActivate: function () {
                        geysers.length = 0;
                        geyserTimer = 1 + Math.random() * 2;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Black space / brilliant white ice divide
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#040608');
                        grad.addColorStop(0.35, '#080c14');
                        grad.addColorStop(0.5, '#c8d4e0');
                        grad.addColorStop(0.65, '#d8e4ee');
                        grad.addColorStop(0.8, '#e4ecf4');
                        grad.addColorStop(1, '#f0f4f8');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Background stars in the upper sky
                        for (var i = 0; i < 60; i++) {
                            var sx = (Math.sin(i * 8.3 + 0.7) * 0.5 + 0.5) * w;
                            var sy = (Math.sin(i * 12.1 + 3.2) * 0.5 + 0.5) * h * 0.45;
                            var sOp = (Math.sin(t * (0.6 + i * 0.04) + i * 2.1) * 0.5 + 0.5) * 0.5;
                            ctx.beginPath();
                            ctx.arc(sx, sy, 0.5 + Math.sin(i * 1.7) * 0.4, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 255, 255, ' + sOp + ')';
                            ctx.fill();
                        }

                        // Saturn's rings arcing across the sky as thin luminous lines
                        ctx.save();
                        ctx.translate(w * 0.5, h * -0.3);
                        var ringAngles = [0.18, 0.22, 0.28, 0.32, 0.38];
                        for (var r = 0; r < ringAngles.length; r++) {
                            var rr = Math.max(w, h) * ringAngles[r];
                            ctx.beginPath();
                            ctx.ellipse(0, 0, rr, rr * 0.3, 0.2, 0.3, Math.PI - 0.3);
                            ctx.strokeStyle = 'rgba(200, 190, 170, ' + (0.06 + r * 0.02) + ')';
                            ctx.lineWidth = 1 + r * 0.5;
                            ctx.stroke();
                        }
                        ctx.restore();
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;

                        // Ice geysers from the south (bottom) of the surface
                        geyserTimer -= dt;
                        if (geyserTimer <= 0 && geysers.length < MAX_GEYSERS) {
                            var gx = w * (0.2 + Math.random() * 0.6);
                            var particles = [];
                            for (var i = 0; i < 40; i++) {
                                var angle = -Math.PI * 0.35 - Math.random() * Math.PI * 0.3;
                                var speed = 120 + Math.random() * 180;
                                particles.push({
                                    x: gx + (Math.random() - 0.5) * 10,
                                    y: h * 0.55,
                                    vx: Math.cos(angle) * speed * (0.3 + Math.random() * 0.7),
                                    vy: Math.sin(angle) * speed * (0.5 + Math.random() * 0.5),
                                    size: 0.5 + Math.random() * 2,
                                    opacity: 0.3 + Math.random() * 0.5
                                });
                            }
                            geysers.push({
                                particles: particles,
                                life: 0,
                                maxLife: 3 + Math.random() * 3
                            });
                            geyserTimer = 2 + Math.random() * 3;
                        }

                        for (var g = geysers.length - 1; g >= 0; g--) {
                            var gey = geysers[g];
                            gey.life += dt;
                            if (gey.life >= gey.maxLife) {
                                geysers.splice(g, 1);
                                continue;
                            }
                            var gFade = gey.life > gey.maxLife * 0.5 ? (1 - (gey.life - gey.maxLife * 0.5) / (gey.maxLife * 0.5)) : 1;
                            for (var p = 0; p < gey.particles.length; p++) {
                                var ep = gey.particles[p];
                                ep.x += ep.vx * dt;
                                ep.y += ep.vy * dt;
                                ep.vy += 20 * dt; // weak gravity (low mass)
                                ep.vx *= 0.998; // slight deceleration
                                var pOp = ep.opacity * gFade;
                                if (pOp < 0.02) continue;
                                ctx.beginPath();
                                ctx.arc(ep.x, ep.y, ep.size, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(220, 240, 255, ' + pOp + ')';
                                ctx.fill();
                                // Subtle glow
                                if (ep.size > 1) {
                                    ctx.beginPath();
                                    ctx.arc(ep.x, ep.y, ep.size * 3, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(200, 225, 255, ' + (pOp * 0.06) + ')';
                                    ctx.fill();
                                }
                            }
                        }
                    }
                };
            })();

            // --- Tritonian theme ---
            // Pale pink cantaloupe terrain, nitrogen frost, dark geyser plumes, Neptune crescent
            themes.tritonian = {
                targetCount: 20,

                spawn: function (w, h) {
                    // Dark geyser plume particles streaking sideways in thin atmosphere
                    return {
                        x: w * (0.3 + Math.random() * 0.4),
                        y: h * (0.6 + Math.random() * 0.15),
                        size: 1 + Math.random() * 2,
                        vx: 30 + Math.random() * 60,
                        vy: -(5 + Math.random() * 15),
                        opacity: 0.08 + Math.random() * 0.12,
                        life: 0,
                        maxLife: 3 + Math.random() * 4
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.life += dt;
                    if (p.life >= p.maxLife) return false;
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.vy += 2 * dt; // slight gravity pull
                    if (p.x > w + 10) return false;
                    return true;
                },

                draw: function (p, ctx, state) {
                    var fade = p.life > p.maxLife * 0.6 ? (1 - (p.life - p.maxLife * 0.6) / (p.maxLife * 0.4)) : 1;
                    var op = p.opacity * fade;
                    if (op < 0.01) return;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(40, 35, 30, ' + op + ')';
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Dark space sky transitioning to pale pink terrain
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#060810');
                    grad.addColorStop(0.3, '#0a0e18');
                    grad.addColorStop(0.5, '#a08880');
                    grad.addColorStop(0.65, '#c0a098');
                    grad.addColorStop(0.8, '#d0b0a8');
                    grad.addColorStop(1, '#c8a8a0');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Neptune as a deep blue crescent in the sky
                    var nx = w * 0.8;
                    var ny = h * 0.2;
                    var nr = Math.min(w, h) * 0.08;
                    var nepGrad = ctx.createRadialGradient(nx - nr * 0.3, ny, 0, nx, ny, nr);
                    nepGrad.addColorStop(0, 'rgba(40, 80, 180, 0.35)');
                    nepGrad.addColorStop(0.6, 'rgba(30, 60, 150, 0.2)');
                    nepGrad.addColorStop(1, 'rgba(20, 40, 120, 0)');
                    ctx.beginPath();
                    ctx.arc(nx, ny, nr, 0, Math.PI * 2);
                    ctx.fillStyle = nepGrad;
                    ctx.fill();
                    // Crescent shadow on Neptune
                    ctx.beginPath();
                    ctx.arc(nx + nr * 0.45, ny - nr * 0.1, nr * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(6, 8, 16, 0.3)';
                    ctx.fill();

                    // Background stars
                    for (var i = 0; i < 50; i++) {
                        var sx = (Math.sin(i * 9.1 + 0.3) * 0.5 + 0.5) * w;
                        var sy = (Math.sin(i * 13.7 + 2.6) * 0.5 + 0.5) * h * 0.45;
                        var sOp = (Math.sin(t * (0.4 + i * 0.05) + i * 1.3) * 0.5 + 0.5) * 0.4;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 0.5 + Math.sin(i * 2.1) * 0.4, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + sOp + ')';
                        ctx.fill();
                    }

                    // Cantaloupe terrain texture - subtle dimpled pattern on the surface
                    ctx.save();
                    for (var i = 0; i < 30; i++) {
                        var cx = (Math.sin(i * 6.7 + 0.9) * 0.5 + 0.5) * w;
                        var cy = h * 0.55 + (Math.sin(i * 4.3 + 1.6) * 0.5 + 0.5) * h * 0.4;
                        var cr = 8 + Math.sin(i * 3.1) * 6;
                        ctx.beginPath();
                        ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(180, 150, 140, 0.06)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    ctx.restore();

                    // Nitrogen frost patches - subtle white-pink shimmer
                    for (var i = 0; i < 12; i++) {
                        var fx = (Math.sin(i * 8.3 + 2.1) * 0.5 + 0.5) * w;
                        var fy = h * 0.6 + (Math.sin(i * 5.7 + 0.8) * 0.5 + 0.5) * h * 0.35;
                        var fr = 15 + Math.sin(i * 3.9 + t * 0.1) * 8;
                        var fOp = 0.03 + Math.sin(t * 0.2 + i * 1.4) * 0.015;
                        var fGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fr);
                        fGrad.addColorStop(0, 'rgba(255, 230, 240, ' + fOp + ')');
                        fGrad.addColorStop(1, 'rgba(240, 210, 220, 0)');
                        ctx.beginPath();
                        ctx.arc(fx, fy, fr, 0, Math.PI * 2);
                        ctx.fillStyle = fGrad;
                        ctx.fill();
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Abyssal theme ---
            // Deep ocean floor with bioluminescent creatures, hydrothermal vents, marine snow
            themes.abyssal = (function () {
                // Bioluminescent creature pulses
                var bioLights = [];
                for (var i = 0; i < 12; i++) {
                    bioLights.push({
                        x: (Math.sin(i * 5.9 + 1.4) * 0.5 + 0.5),
                        y: 0.3 + (Math.sin(i * 3.7 + 0.6) * 0.5 + 0.5) * 0.6,
                        hue: [180, 200, 140, 260, 300][i % 5],
                        size: 0.008 + (Math.sin(i * 2.3) * 0.5 + 0.5) * 0.015,
                        pulseSpeed: 0.3 + Math.sin(i * 4.7) * 0.2,
                        pulseOffset: Math.random() * Math.PI * 2,
                        driftX: 0.003 + Math.sin(i * 1.9) * 0.002,
                        driftY: 0.002 + Math.sin(i * 2.7) * 0.001,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2
                    });
                }

                // Hydrothermal vent configs
                var vents = [
                    { x: 0.25, width: 0.03, speed: 30 },
                    { x: 0.70, width: 0.025, speed: 25 }
                ];

                return {
                    targetCount: 50,

                    spawn: function (w, h) {
                        // Marine snow particles drifting downward
                        return {
                            x: Math.random() * w,
                            y: -Math.random() * h * 0.2,
                            size: 0.3 + Math.random() * 1.2,
                            speed: 5 + Math.random() * 12,
                            drift: (Math.random() - 0.5) * 4,
                            opacity: 0.05 + Math.random() * 0.12,
                            wobbleSpeed: 0.3 + Math.random() * 0.5,
                            wobbleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.y += p.speed * dt;
                        p.x += (p.drift + Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * 3) * dt;
                        if (p.y > h + 5) return false;
                        if (p.x < -5) p.x = w + 5;
                        if (p.x > w + 5) p.x = -5;
                        return true;
                    },

                    draw: function (p, ctx) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(180, 200, 220, ' + p.opacity + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Pitch black with slight deep blue gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#010208');
                        grad.addColorStop(0.5, '#020410');
                        grad.addColorStop(0.8, '#030614');
                        grad.addColorStop(1, '#040818');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Bioluminescent creature pulses
                        for (var i = 0; i < bioLights.length; i++) {
                            var bl = bioLights[i];
                            var bx = (bl.x + Math.sin(t * bl.driftX + bl.phaseX) * 0.08) * w;
                            var by = (bl.y + Math.sin(t * bl.driftY + bl.phaseY) * 0.05) * h;
                            var pulse = Math.sin(t * bl.pulseSpeed + bl.pulseOffset);
                            var bOp = 0.03 + (pulse * 0.5 + 0.5) * 0.08;
                            var bSize = bl.size * Math.min(w, h) * (0.8 + pulse * 0.2);

                            var blGrad = ctx.createRadialGradient(bx, by, 0, bx, by, bSize);
                            blGrad.addColorStop(0, 'hsla(' + bl.hue + ', 80%, 60%, ' + bOp + ')');
                            blGrad.addColorStop(0.3, 'hsla(' + bl.hue + ', 70%, 50%, ' + (bOp * 0.5) + ')');
                            blGrad.addColorStop(1, 'hsla(' + bl.hue + ', 60%, 40%, 0)');
                            ctx.beginPath();
                            ctx.arc(bx, by, bSize, 0, Math.PI * 2);
                            ctx.fillStyle = blGrad;
                            ctx.fill();

                            // Bright core
                            if (pulse > 0.3) {
                                ctx.beginPath();
                                ctx.arc(bx, by, bSize * 0.15, 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + bl.hue + ', 90%, 80%, ' + (bOp * 0.8) + ')';
                                ctx.fill();
                            }
                        }

                        // Anglerfish-like lure light drifting slowly
                        var lureX = (0.5 + Math.sin(t * 0.02 + 1.3) * 0.3) * w;
                        var lureY = (0.4 + Math.sin(t * 0.015 + 2.7) * 0.2) * h;
                        var lurePulse = Math.sin(t * 1.5) * 0.5 + 0.5;
                        var lureGrad = ctx.createRadialGradient(lureX, lureY, 0, lureX, lureY, 20);
                        lureGrad.addColorStop(0, 'rgba(200, 255, 220, ' + (0.15 * lurePulse) + ')');
                        lureGrad.addColorStop(0.3, 'rgba(100, 220, 180, ' + (0.06 * lurePulse) + ')');
                        lureGrad.addColorStop(1, 'rgba(50, 180, 140, 0)');
                        ctx.beginPath();
                        ctx.arc(lureX, lureY, 20, 0, Math.PI * 2);
                        ctx.fillStyle = lureGrad;
                        ctx.fill();
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Hydrothermal vent plumes rising from the bottom
                        for (var v = 0; v < vents.length; v++) {
                            var vent = vents[v];
                            var vx = vent.x * w;
                            var vWidth = vent.width * w;
                            // Shimmering plume particles
                            for (var i = 0; i < 15; i++) {
                                var frac = i / 15;
                                var py = h - frac * h * 0.35;
                                var spread = vWidth * (1 + frac * 2);
                                var px = vx + Math.sin(t * 2 + frac * 10 + v * 3) * spread;
                                var pOp = (1 - frac) * 0.06;
                                var pSize = 3 + frac * 5;
                                var pGrad = ctx.createRadialGradient(px, py, 0, px, py, pSize);
                                pGrad.addColorStop(0, 'rgba(180, 120, 60, ' + pOp + ')');
                                pGrad.addColorStop(1, 'rgba(140, 80, 40, 0)');
                                ctx.beginPath();
                                ctx.arc(px, py, pSize, 0, Math.PI * 2);
                                ctx.fillStyle = pGrad;
                                ctx.fill();
                            }
                            // Vent glow at the base
                            var ventGlow = ctx.createRadialGradient(vx, h, 0, vx, h, vWidth * 3);
                            ventGlow.addColorStop(0, 'rgba(200, 100, 30, 0.08)');
                            ventGlow.addColorStop(0.5, 'rgba(160, 70, 20, 0.03)');
                            ventGlow.addColorStop(1, 'rgba(120, 50, 10, 0)');
                            ctx.beginPath();
                            ctx.arc(vx, h, vWidth * 3, 0, Math.PI * 2);
                            ctx.fillStyle = ventGlow;
                            ctx.fill();
                        }
                    }
                };
            })();

            // --- Coraline theme ---
            // Shallow reef with caustics, swaying corals, fish schools, bubbles
            themes.coraline = (function () {
                // Coral shapes at the bottom
                var corals = [];
                for (var i = 0; i < 10; i++) {
                    corals.push({
                        x: (i / 10) + Math.sin(i * 3.7) * 0.03,
                        height: 0.08 + (Math.sin(i * 2.9 + 1.1) * 0.5 + 0.5) * 0.12,
                        width: 0.03 + (Math.sin(i * 4.3) * 0.5 + 0.5) * 0.03,
                        hue: [340, 280, 30, 15, 320, 260, 35, 350, 300, 25][i],
                        branches: 2 + Math.floor(Math.sin(i * 5.1) * 2 + 2)
                    });
                }

                // Fish school configs
                var schools = [
                    { cx: 0.3, cy: 0.35, count: 12, speed: 0.04, radius: 0.08, hue: 45 },
                    { cx: 0.7, cy: 0.45, count: 8, speed: 0.03, radius: 0.06, hue: 200 }
                ];

                return {
                    targetCount: 20,

                    spawn: function (w, h) {
                        // Rising bubbles
                        var r = 1.5 + Math.random() * 4;
                        return {
                            x: Math.random() * w,
                            y: h + r + Math.random() * h * 0.2,
                            r: r,
                            speed: 15 + Math.random() * 25,
                            wobbleAmp: 10 + Math.random() * 20,
                            wobbleSpeed: 0.5 + Math.random() * 0.8,
                            wobbleOffset: Math.random() * Math.PI * 2,
                            opacity: 0.1 + Math.random() * 0.2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.y -= p.speed * dt;
                        p.x += Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * p.wobbleAmp * dt;
                        if (p.y + p.r < 0) return false;
                        if (p.x < -p.r) p.x = w + p.r;
                        if (p.x > w + p.r) p.x = -p.r;
                        return true;
                    },

                    draw: function (p, ctx) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(200, 240, 255, ' + p.opacity + ')';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // Highlight
                        ctx.beginPath();
                        ctx.arc(p.x - p.r * 0.25, p.y - p.r * 0.25, p.r * 0.25, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + (p.opacity * 0.5) + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Warm turquoise water gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#1098a8');
                        grad.addColorStop(0.3, '#0e8898');
                        grad.addColorStop(0.6, '#0c7888');
                        grad.addColorStop(0.8, '#0a6878');
                        grad.addColorStop(1, '#085868');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Dappled light caustics - overlapping bright patches
                        ctx.save();
                        for (var i = 0; i < 20; i++) {
                            var cx = (Math.sin(i * 4.3 + t * 0.08 + 1.2) * 0.5 + 0.5) * w;
                            var cy = (Math.sin(i * 6.1 + t * 0.06 + 2.8) * 0.5 + 0.5) * h * 0.7;
                            var cr = 30 + Math.sin(i * 2.7 + t * 0.3) * 15;
                            var cOp = 0.02 + Math.sin(t * 0.4 + i * 1.5) * 0.015;
                            var caustGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cr);
                            caustGrad.addColorStop(0, 'rgba(180, 255, 240, ' + cOp + ')');
                            caustGrad.addColorStop(1, 'rgba(120, 220, 200, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                            ctx.fillStyle = caustGrad;
                            ctx.fill();
                        }
                        ctx.restore();

                        // Sandy bottom
                        var sandY = h * 0.82;
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (var x = 0; x <= w; x += 4) {
                            var sy = sandY + Math.sin(x * 0.008 + t * 0.03) * 8 + Math.sin(x * 0.02 + 1.5) * 4;
                            ctx.lineTo(x, sy);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(180, 160, 120, 0.3)';
                        ctx.fill();

                        // Coral shapes
                        for (var i = 0; i < corals.length; i++) {
                            var c = corals[i];
                            var cx = c.x * w;
                            var baseY = h * 0.88;
                            var ch = c.height * h;
                            var cw = c.width * w;
                            var sway = Math.sin(t * 0.5 + i * 1.8) * 5;

                            // Main trunk
                            ctx.beginPath();
                            ctx.moveTo(cx, baseY);
                            ctx.quadraticCurveTo(cx + sway, baseY - ch * 0.5, cx + sway * 1.5, baseY - ch);
                            ctx.strokeStyle = 'hsla(' + c.hue + ', 60%, 50%, 0.25)';
                            ctx.lineWidth = cw;
                            ctx.lineCap = 'round';
                            ctx.stroke();

                            // Branches
                            for (var b = 0; b < c.branches; b++) {
                                var bFrac = (b + 1) / (c.branches + 1);
                                var bx = cx + sway * bFrac;
                                var by = baseY - ch * bFrac;
                                var bAngle = (b % 2 === 0 ? -1 : 1) * (0.3 + Math.sin(i + b) * 0.2);
                                var bLen = ch * (0.2 + Math.sin(i * 2 + b) * 0.1);
                                var bSway = Math.sin(t * 0.6 + i * 2 + b * 1.3) * 4;
                                ctx.beginPath();
                                ctx.moveTo(bx, by);
                                ctx.quadraticCurveTo(bx + bSway + Math.cos(bAngle) * bLen * 0.5, by - bLen * 0.5, bx + bSway + Math.cos(bAngle) * bLen, by + Math.sin(bAngle) * bLen);
                                ctx.strokeStyle = 'hsla(' + c.hue + ', 65%, 55%, 0.2)';
                                ctx.lineWidth = cw * 0.5;
                                ctx.stroke();
                            }
                        }
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Fish schools - coordinated dot groups
                        for (var s = 0; s < schools.length; s++) {
                            var school = schools[s];
                            var scx = (school.cx + Math.sin(t * school.speed + s * 2) * 0.15) * w;
                            var scy = (school.cy + Math.sin(t * school.speed * 0.7 + s * 3 + 1) * 0.08) * h;
                            for (var f = 0; f < school.count; f++) {
                                var fAngle = (f / school.count) * Math.PI * 2 + t * 0.3;
                                var fDist = school.radius * Math.min(w, h) * (0.5 + Math.sin(f * 2.3 + t * 0.5) * 0.3);
                                var fx = scx + Math.cos(fAngle) * fDist;
                                var fy = scy + Math.sin(fAngle) * fDist * 0.5;
                                ctx.beginPath();
                                ctx.ellipse(fx, fy, 3, 1.5, Math.atan2(Math.sin(fAngle), Math.cos(fAngle)), 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + school.hue + ', 50%, 65%, 0.2)';
                                ctx.fill();
                            }
                        }
                    }
                };
            })();

            // --- Auroral theme ---
            // Northern lights with sweeping curtains of colour, dark starry sky, mountain silhouette
            themes.auroral = (function () {
                // Aurora curtain configs
                var curtains = [
                    { yBase: 0.20, amp: 60, freq: 0.003, speed: 0.12, hue: 120, height: 0.25, opacity: 0.06 },
                    { yBase: 0.25, amp: 50, freq: 0.004, speed: 0.15, hue: 140, height: 0.22, opacity: 0.05 },
                    { yBase: 0.22, amp: 70, freq: 0.0025, speed: 0.10, hue: 180, height: 0.28, opacity: 0.04 },
                    { yBase: 0.28, amp: 45, freq: 0.005, speed: 0.18, hue: 100, height: 0.20, opacity: 0.05 },
                    { yBase: 0.18, amp: 55, freq: 0.0035, speed: 0.14, hue: 280, height: 0.24, opacity: 0.03 }
                ];

                return {
                    targetCount: 120,

                    spawn: function (w, h) {
                        // Stars in the sky
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h * 0.75,
                            size: 0.3 + Math.random() * 1.5,
                            baseOpacity: 0.2 + Math.random() * 0.6,
                            twinkleSpeed: 0.5 + Math.random() * 2,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        return true; // Stars are stationary
                    },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.baseOpacity * (0.5 + twinkle * 0.5);
                        if (op < 0.05) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark starry sky gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#040810');
                        grad.addColorStop(0.5, '#060c16');
                        grad.addColorStop(0.75, '#0a1020');
                        grad.addColorStop(1, '#0c1424');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;

                        // Aurora curtains - sweeping, folding bands of colour
                        for (var c = 0; c < curtains.length; c++) {
                            var cur = curtains[c];
                            var baseY = h * cur.yBase;

                            // Draw as a vertical gradient band following a wave
                            for (var x = 0; x <= w; x += 3) {
                                var waveY = baseY
                                    + Math.sin(x * cur.freq + t * cur.speed) * cur.amp
                                    + Math.sin(x * cur.freq * 0.5 + t * cur.speed * 1.5 + c * 1.8) * cur.amp * 0.6
                                    + Math.cos(x * cur.freq * 0.3 + t * cur.speed * 0.8 + c * 3.2) * cur.amp * 0.3;

                                var colH = cur.height * h;
                                // Fold intensity varies along the curtain
                                var foldIntensity = 0.6 + Math.sin(x * 0.008 + t * 0.2 + c * 2) * 0.4;
                                var op = cur.opacity * foldIntensity;

                                // Vertical stripe of aurora
                                var aGrad = ctx.createLinearGradient(x, waveY, x, waveY + colH);
                                aGrad.addColorStop(0, 'hsla(' + cur.hue + ', 80%, 65%, 0)');
                                aGrad.addColorStop(0.2, 'hsla(' + cur.hue + ', 80%, 60%, ' + op + ')');
                                aGrad.addColorStop(0.5, 'hsla(' + ((cur.hue + 30) % 360) + ', 70%, 55%, ' + (op * 0.8) + ')');
                                aGrad.addColorStop(0.8, 'hsla(' + ((cur.hue + 60) % 360) + ', 60%, 45%, ' + (op * 0.4) + ')');
                                aGrad.addColorStop(1, 'hsla(' + cur.hue + ', 50%, 40%, 0)');
                                ctx.fillStyle = aGrad;
                                ctx.fillRect(x, waveY, 4, colH);
                            }
                        }

                        // Mountain/treeline silhouette along the bottom
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (var x = 0; x <= w; x += 3) {
                            var my = h * 0.82
                                - Math.sin(x * 0.003 + 0.5) * h * 0.06
                                - Math.sin(x * 0.008 + 2.1) * h * 0.03
                                - Math.sin(x * 0.02 + 0.8) * h * 0.008;
                            ctx.lineTo(x, my);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = '#060a10';
                        ctx.fill();

                        // Small trees on the ridge
                        for (var i = 0; i < 30; i++) {
                            var tx = (i / 30) * w + Math.sin(i * 5.3) * 15;
                            var tBase = h * 0.82 - Math.sin(tx * 0.003 + 0.5) * h * 0.06 - Math.sin(tx * 0.008 + 2.1) * h * 0.03;
                            var tHeight = 8 + Math.sin(i * 3.7) * 5;
                            ctx.beginPath();
                            ctx.moveTo(tx, tBase);
                            ctx.lineTo(tx - 3, tBase);
                            ctx.lineTo(tx, tBase - tHeight);
                            ctx.lineTo(tx + 3, tBase);
                            ctx.closePath();
                            ctx.fillStyle = '#050810';
                            ctx.fill();
                        }
                    }
                };
            })();

            // --- Twilight theme ---
            // Golden hour fading to blue hour, silhouetted clouds, first stars, fireflies
            themes.twilight = (function () {
                // Firefly state
                var fireflies = [];
                for (var i = 0; i < 15; i++) {
                    fireflies.push({
                        x: Math.random(),
                        y: 0.65 + Math.random() * 0.3,
                        pulseSpeed: 0.5 + Math.random() * 1.5,
                        pulseOffset: Math.random() * Math.PI * 2,
                        driftX: 0.01 + Math.random() * 0.02,
                        driftY: 0.005 + Math.random() * 0.01,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2
                    });
                }

                return {
                    targetCount: 40,

                    spawn: function (w, h) {
                        // First stars appearing
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h * 0.4,
                            size: 0.3 + Math.random() * 1.2,
                            baseOpacity: 0.1 + Math.random() * 0.4,
                            twinkleSpeed: 0.8 + Math.random() * 2,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.baseOpacity * (0.3 + twinkle * 0.7);
                        if (op < 0.03) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 240, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Golden hour to blue hour gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#0c1428');
                        grad.addColorStop(0.2, '#1a2848');
                        grad.addColorStop(0.4, '#3a3060');
                        grad.addColorStop(0.55, '#8a4858');
                        grad.addColorStop(0.7, '#d08848');
                        grad.addColorStop(0.82, '#e8a838');
                        grad.addColorStop(0.9, '#f0c040');
                        grad.addColorStop(1, '#e0a030');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Silhouetted clouds drifting slowly
                        for (var i = 0; i < 5; i++) {
                            var cx = ((i * 0.22 + Math.sin(i * 3.1) * 0.05 + t * 0.005) % 1.3 - 0.15) * w;
                            var cy = h * (0.3 + Math.sin(i * 4.7) * 0.1);
                            var crx = w * (0.08 + Math.sin(i * 2.3) * 0.03);
                            var cry = h * (0.02 + Math.sin(i * 3.9) * 0.008);
                            // Cloud as overlapping ellipses
                            ctx.save();
                            ctx.globalAlpha = 0.15;
                            for (var j = 0; j < 3; j++) {
                                var ox = crx * (j - 1) * 0.5;
                                var oy = cry * Math.sin(j * 2.1) * 0.3;
                                ctx.beginPath();
                                ctx.ellipse(cx + ox, cy + oy, crx * (0.6 + j * 0.15), cry * (0.8 + j * 0.1), 0, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(40, 20, 30, 1)';
                                ctx.fill();
                            }
                            ctx.restore();
                        }
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;

                        // Ground silhouette
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (var x = 0; x <= w; x += 4) {
                            var gy = h * 0.88 - Math.sin(x * 0.004 + 0.3) * h * 0.02 - Math.sin(x * 0.01 + 1.7) * h * 0.008;
                            ctx.lineTo(x, gy);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = '#0a0810';
                        ctx.fill();

                        // Fireflies glowing near the ground
                        for (var i = 0; i < fireflies.length; i++) {
                            var ff = fireflies[i];
                            var fx = (ff.x + Math.sin(t * ff.driftX + ff.phaseX) * 0.08) * w;
                            var fy = (ff.y + Math.sin(t * ff.driftY + ff.phaseY) * 0.03) * h;
                            var pulse = Math.sin(t * ff.pulseSpeed + ff.pulseOffset);
                            var fOp = Math.max(0, pulse) * 0.25; // Only glow on positive half
                            if (fOp < 0.02) continue;
                            var ffGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, 12);
                            ffGrad.addColorStop(0, 'rgba(220, 255, 100, ' + fOp + ')');
                            ffGrad.addColorStop(0.3, 'rgba(180, 230, 60, ' + (fOp * 0.5) + ')');
                            ffGrad.addColorStop(1, 'rgba(140, 200, 40, 0)');
                            ctx.beginPath();
                            ctx.arc(fx, fy, 12, 0, Math.PI * 2);
                            ctx.fillStyle = ffGrad;
                            ctx.fill();
                            // Bright core
                            ctx.beginPath();
                            ctx.arc(fx, fy, 1.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(240, 255, 150, ' + (fOp * 0.8) + ')';
                            ctx.fill();
                        }
                    }
                };
            })();

            // --- Misty theme ---
            // Dense fog in a forest with drifting layers and tree silhouettes
            themes.misty = {
                targetCount: 30,

                spawn: function (w, h) {
                    // Water droplets condensing and falling
                    return {
                        x: Math.random() * w,
                        y: -Math.random() * h * 0.1,
                        size: 0.5 + Math.random() * 1,
                        speed: 20 + Math.random() * 30,
                        opacity: 0.04 + Math.random() * 0.08
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.y += p.speed * dt;
                    if (p.y > h + 5) return false;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(200, 210, 220, ' + p.opacity + ')';
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Muted grey-green forest atmosphere
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#6a7a6a');
                    grad.addColorStop(0.3, '#788878');
                    grad.addColorStop(0.6, '#8a9888');
                    grad.addColorStop(1, '#7a8a78');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Soft light blooms breaking through
                    for (var i = 0; i < 4; i++) {
                        var lx = (0.2 + i * 0.2 + Math.sin(t * 0.03 + i * 2) * 0.05) * w;
                        var ly = (0.15 + Math.sin(t * 0.02 + i * 3) * 0.05) * h;
                        var lr = Math.min(w, h) * (0.15 + Math.sin(t * 0.1 + i * 1.5) * 0.03);
                        var lOp = 0.04 + Math.sin(t * 0.15 + i * 2.3) * 0.02;
                        var lGrad = ctx.createRadialGradient(lx, ly, 0, lx, ly, lr);
                        lGrad.addColorStop(0, 'rgba(230, 240, 220, ' + lOp + ')');
                        lGrad.addColorStop(1, 'rgba(200, 210, 190, 0)');
                        ctx.beginPath();
                        ctx.arc(lx, ly, lr, 0, Math.PI * 2);
                        ctx.fillStyle = lGrad;
                        ctx.fill();
                    }

                    // Tree trunk silhouettes at varying distances
                    var treeConfigs = [
                        { x: 0.05, w: 0.015, depth: 0.3 },
                        { x: 0.15, w: 0.02, depth: 0.5 },
                        { x: 0.28, w: 0.012, depth: 0.2 },
                        { x: 0.42, w: 0.018, depth: 0.6 },
                        { x: 0.55, w: 0.014, depth: 0.35 },
                        { x: 0.68, w: 0.022, depth: 0.7 },
                        { x: 0.78, w: 0.016, depth: 0.4 },
                        { x: 0.90, w: 0.013, depth: 0.25 },
                        { x: 0.35, w: 0.02, depth: 0.8 },
                        { x: 0.82, w: 0.017, depth: 0.55 }
                    ];
                    for (var i = 0; i < treeConfigs.length; i++) {
                        var tr = treeConfigs[i];
                        var treeOp = 0.08 + (1 - tr.depth) * 0.12;
                        var tx = tr.x * w;
                        var tw = tr.w * w;
                        ctx.fillStyle = 'rgba(40, 50, 40, ' + treeOp + ')';
                        ctx.fillRect(tx, h * 0.1, tw, h * 0.9);
                        // Slight taper
                        ctx.beginPath();
                        ctx.moveTo(tx, h * 0.1);
                        ctx.lineTo(tx + tw * 0.5, h * 0.05);
                        ctx.lineTo(tx + tw, h * 0.1);
                        ctx.fillStyle = 'rgba(40, 50, 40, ' + (treeOp * 0.5) + ')';
                        ctx.fill();
                    }
                },

                drawForeground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Drifting fog layers at different speeds and heights
                    for (var layer = 0; layer < 6; layer++) {
                        var fogY = h * (0.15 + layer * 0.14);
                        var fogSpeed = 8 + layer * 5;
                        var fogOp = 0.06 + (layer % 2) * 0.02;
                        ctx.beginPath();
                        var fogOffset = t * fogSpeed;
                        ctx.moveTo(0, h);
                        for (var x = 0; x <= w; x += 4) {
                            var fy = fogY
                                + Math.sin((x + fogOffset) * 0.004 + layer * 1.5) * 25
                                + Math.sin((x + fogOffset) * 0.008 + layer * 3 + 1) * 12;
                            ctx.lineTo(x, fy);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(190, 200, 190, ' + fogOp + ')';
                        ctx.fill();
                    }
                }
            };

            // --- Crystalline theme ---
            // Slowly growing crystal formations with refractive highlights
            themes.crystalline = (function () {
                // Crystal seed points with branches
                var crystals = [];
                for (var i = 0; i < 8; i++) {
                    var branches = [];
                    var branchCount = 3 + Math.floor(Math.sin(i * 4.3) * 2 + 2);
                    for (var b = 0; b < branchCount; b++) {
                        branches.push({
                            angle: (b / branchCount) * Math.PI * 2 + Math.sin(i * 2.7 + b * 1.3) * 0.3,
                            length: 0.03 + (Math.sin(i * 3.1 + b * 2.5) * 0.5 + 0.5) * 0.06,
                            width: 2 + Math.sin(i * 5.1 + b * 1.7) * 1.5,
                            growSpeed: 0.08 + Math.sin(i * 2.3 + b * 3.1) * 0.04
                        });
                    }
                    crystals.push({
                        x: 0.08 + (i / 8) * 0.84 + Math.sin(i * 5.7) * 0.04,
                        y: 0.55 + (Math.sin(i * 3.3 + 0.8) * 0.5 + 0.5) * 0.35,
                        branches: branches,
                        hue: 190 + Math.sin(i * 4.1) * 20
                    });
                }

                return {
                    targetCount: 25,

                    spawn: function (w, h) {
                        // Sparkle particles
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.5 + Math.random() * 1.5,
                            opacity: 0.1 + Math.random() * 0.3,
                            twinkleSpeed: 1.5 + Math.random() * 3,
                            twinkleOffset: Math.random() * Math.PI * 2,
                            life: 0,
                            maxLife: 2 + Math.random() * 4
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.life += dt;
                        if (p.life >= p.maxLife) return false;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var fade = p.life < 0.3 ? p.life / 0.3 : (p.life > p.maxLife - 0.5 ? (p.maxLife - p.life) / 0.5 : 1);
                        var op = p.opacity * (0.2 + twinkle * 0.8) * fade;
                        if (op < 0.02) return;
                        // Draw as a small cross/star shape
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.strokeStyle = 'rgba(200, 230, 255, ' + op + ')';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(-p.size, 0); ctx.lineTo(p.size, 0);
                        ctx.moveTo(0, -p.size); ctx.lineTo(0, p.size);
                        ctx.stroke();
                        ctx.restore();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Cool ice-blue to dark background
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#0a1020');
                        grad.addColorStop(0.3, '#0c1830');
                        grad.addColorStop(0.6, '#102040');
                        grad.addColorStop(1, '#0e1828');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        var minDim = Math.min(w, h);
                        // Draw crystal formations
                        for (var i = 0; i < crystals.length; i++) {
                            var cr = crystals[i];
                            var cx = cr.x * w;
                            var cy = cr.y * h;

                            for (var b = 0; b < cr.branches.length; b++) {
                                var br = cr.branches[b];
                                // Growth animation - crystal extends over time
                                var growPhase = (Math.sin(t * br.growSpeed + i * 1.7 + b * 2.3) * 0.5 + 0.5);
                                var len = br.length * minDim * (0.5 + growPhase * 0.5);
                                var endX = cx + Math.cos(br.angle) * len;
                                var endY = cy + Math.sin(br.angle) * len;

                                // Crystal edge with gradient
                                var brGrad = ctx.createLinearGradient(cx, cy, endX, endY);
                                brGrad.addColorStop(0, 'hsla(' + cr.hue + ', 50%, 60%, 0.15)');
                                brGrad.addColorStop(0.5, 'hsla(' + cr.hue + ', 60%, 70%, 0.08)');
                                brGrad.addColorStop(1, 'hsla(' + cr.hue + ', 40%, 80%, 0.03)');
                                ctx.beginPath();
                                ctx.moveTo(cx, cy);
                                ctx.lineTo(endX, endY);
                                ctx.strokeStyle = brGrad;
                                ctx.lineWidth = br.width;
                                ctx.lineCap = 'round';
                                ctx.stroke();

                                // Refractive rainbow highlight near the tip
                                var highlightOp = growPhase * 0.1;
                                if (highlightOp > 0.02) {
                                    var hGrad = ctx.createRadialGradient(endX, endY, 0, endX, endY, 8);
                                    hGrad.addColorStop(0, 'rgba(255, 255, 255, ' + highlightOp + ')');
                                    hGrad.addColorStop(0.3, 'hsla(' + ((cr.hue + 60) % 360) + ', 80%, 80%, ' + (highlightOp * 0.5) + ')');
                                    hGrad.addColorStop(1, 'rgba(200, 220, 255, 0)');
                                    ctx.beginPath();
                                    ctx.arc(endX, endY, 8, 0, Math.PI * 2);
                                    ctx.fillStyle = hGrad;
                                    ctx.fill();
                                }

                                // Sub-branches
                                for (var sb = 0; sb < 2; sb++) {
                                    var subFrac = 0.4 + sb * 0.3;
                                    var subX = cx + Math.cos(br.angle) * len * subFrac;
                                    var subY = cy + Math.sin(br.angle) * len * subFrac;
                                    var subAngle = br.angle + (sb === 0 ? 0.5 : -0.5);
                                    var subLen = len * 0.3;
                                    var subEndX = subX + Math.cos(subAngle) * subLen;
                                    var subEndY = subY + Math.sin(subAngle) * subLen;
                                    ctx.beginPath();
                                    ctx.moveTo(subX, subY);
                                    ctx.lineTo(subEndX, subEndY);
                                    ctx.strokeStyle = 'hsla(' + cr.hue + ', 50%, 65%, 0.06)';
                                    ctx.lineWidth = br.width * 0.6;
                                    ctx.stroke();
                                }
                            }

                            // Seed point glow
                            var seedGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 10);
                            seedGrad.addColorStop(0, 'hsla(' + cr.hue + ', 60%, 70%, 0.12)');
                            seedGrad.addColorStop(1, 'hsla(' + cr.hue + ', 50%, 60%, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, 10, 0, Math.PI * 2);
                            ctx.fillStyle = seedGrad;
                            ctx.fill();
                        }
                    },

                    drawForeground: function (ctx, w, h, state) {}
                };
            })();

            // --- Embers theme ---
            // Dying campfire with floating embers, warm glow, wispy smoke
            themes.embers = (function () {
                // Smoke trail state
                var smokeParticles = [];
                var SMOKE_MAX = 20;

                return {
                    targetCount: 45,

                    spawn: function (w, h) {
                        // Ember particles floating upward
                        var isLarge = Math.random() < 0.15;
                        return {
                            x: w * (0.3 + Math.random() * 0.4),
                            y: h * (0.75 + Math.random() * 0.15),
                            size: isLarge ? (2 + Math.random() * 3) : (0.5 + Math.random() * 2),
                            speed: -(15 + Math.random() * 35),
                            driftAmp: 20 + Math.random() * 40,
                            driftSpeed: 0.3 + Math.random() * 0.8,
                            driftOffset: Math.random() * Math.PI * 2,
                            startOpacity: 0.5 + Math.random() * 0.5,
                            hue: 15 + Math.random() * 25, // orange to red
                            life: 0,
                            maxLife: 3 + Math.random() * 5,
                            isLarge: isLarge
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.life += dt;
                        if (p.life >= p.maxLife) return false;
                        p.y += p.speed * dt;
                        p.x += Math.sin(state.timeElapsed * p.driftSpeed + p.driftOffset) * p.driftAmp * dt;
                        // Cool and dim as they rise
                        if (p.y < h * 0.2) return false;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var progress = p.life / p.maxLife;
                        var fade = progress < 0.1 ? progress / 0.1 : (1 - (progress - 0.1) / 0.9);
                        var op = p.startOpacity * fade;
                        if (op < 0.02) return;
                        // Colour shifts from bright orange to dim red as it ages
                        var hue = p.hue - progress * 10;
                        var lightness = 60 - progress * 25;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * (1 - progress * 0.3), 0, Math.PI * 2);
                        ctx.fillStyle = 'hsla(' + hue + ', 100%, ' + lightness + '%, ' + op + ')';
                        ctx.fill();
                        // Glow around larger embers
                        if (p.isLarge && op > 0.1) {
                            var gGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                            gGrad.addColorStop(0, 'hsla(' + hue + ', 100%, 50%, ' + (op * 0.15) + ')');
                            gGrad.addColorStop(1, 'hsla(' + hue + ', 80%, 40%, 0)');
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 4, 0, Math.PI * 2);
                            ctx.fillStyle = gGrad;
                            ctx.fill();
                        }
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Deep black background
                        var grad = ctx.createRadialGradient(w * 0.5, h * 0.85, 0, w * 0.5, h * 0.5, Math.max(w, h) * 0.8);
                        grad.addColorStop(0, '#1a0a04');
                        grad.addColorStop(0.3, '#0c0604');
                        grad.addColorStop(0.6, '#060404');
                        grad.addColorStop(1, '#020202');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Warm fire glow at the bottom
                        var glowPulse = Math.sin(t * 1.5) * 0.02 + Math.sin(t * 2.3 + 1.1) * 0.015;
                        var fireGlow = ctx.createRadialGradient(w * 0.5, h * 0.88, 0, w * 0.5, h * 0.88, Math.min(w, h) * 0.4);
                        fireGlow.addColorStop(0, 'rgba(255, 120, 20, ' + (0.12 + glowPulse) + ')');
                        fireGlow.addColorStop(0.3, 'rgba(255, 80, 10, ' + (0.06 + glowPulse * 0.5) + ')');
                        fireGlow.addColorStop(0.6, 'rgba(200, 50, 5, ' + (0.02 + glowPulse * 0.2) + ')');
                        fireGlow.addColorStop(1, 'rgba(100, 20, 0, 0)');
                        ctx.beginPath();
                        ctx.arc(w * 0.5, h * 0.88, Math.min(w, h) * 0.4, 0, Math.PI * 2);
                        ctx.fillStyle = fireGlow;
                        ctx.fill();
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        // Wispy smoke trails rising from the fire
                        if (Math.random() < dt * 2 && smokeParticles.length < SMOKE_MAX) {
                            smokeParticles.push({
                                x: w * (0.45 + Math.random() * 0.1),
                                y: h * 0.78,
                                size: 10 + Math.random() * 15,
                                vy: -(10 + Math.random() * 20),
                                vx: (Math.random() - 0.5) * 8,
                                opacity: 0.04 + Math.random() * 0.04,
                                life: 0,
                                maxLife: 4 + Math.random() * 4
                            });
                        }
                        for (var i = smokeParticles.length - 1; i >= 0; i--) {
                            var sp = smokeParticles[i];
                            sp.life += dt;
                            if (sp.life >= sp.maxLife) {
                                smokeParticles.splice(i, 1);
                                continue;
                            }
                            sp.y += sp.vy * dt;
                            sp.x += (sp.vx + Math.sin(t * 0.5 + i) * 5) * dt;
                            sp.size += 3 * dt;
                            var fade = sp.life > sp.maxLife * 0.5 ? (1 - (sp.life - sp.maxLife * 0.5) / (sp.maxLife * 0.5)) : 1;
                            var sOp = sp.opacity * fade;
                            if (sOp < 0.005) continue;
                            var smGrad = ctx.createRadialGradient(sp.x, sp.y, 0, sp.x, sp.y, sp.size);
                            smGrad.addColorStop(0, 'rgba(80, 70, 60, ' + sOp + ')');
                            smGrad.addColorStop(1, 'rgba(60, 55, 50, 0)');
                            ctx.beginPath();
                            ctx.arc(sp.x, sp.y, sp.size, 0, Math.PI * 2);
                            ctx.fillStyle = smGrad;
                            ctx.fill();
                        }
                    }
                };
            })();

            // --- Inkwell theme ---
            // Ink dropped in water with blooming tendrils
            themes.inkwell = (function () {
                // Ink drop state
                var inkDrops = [];
                var MAX_DROPS = 5;
                var dropTimer = 2;

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        inkDrops.length = 0;
                        dropTimer = 1;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        // Pale water-like background
                        var grad = ctx.createRadialGradient(w * 0.5, h * 0.5, 0, w * 0.5, h * 0.5, Math.max(w, h) * 0.7);
                        grad.addColorStop(0, '#e8e4e0');
                        grad.addColorStop(0.5, '#d8d4d0');
                        grad.addColorStop(1, '#c8c4c0');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var minDim = Math.min(w, h);

                        // Spawn new ink drops periodically
                        dropTimer -= dt;
                        if (dropTimer <= 0 && inkDrops.length < MAX_DROPS) {
                            var hues = [240, 260, 220, 280, 200]; // blues and purples
                            inkDrops.push({
                                x: w * (0.2 + Math.random() * 0.6),
                                y: h * (0.2 + Math.random() * 0.6),
                                life: 0,
                                maxLife: 12 + Math.random() * 8,
                                hue: hues[Math.floor(Math.random() * hues.length)],
                                tendrils: (function () {
                                    var arr = [];
                                    var count = 6 + Math.floor(Math.random() * 6);
                                    for (var j = 0; j < count; j++) {
                                        arr.push({
                                            angle: (j / count) * Math.PI * 2 + (Math.random() - 0.5) * 0.5,
                                            speed: 15 + Math.random() * 25,
                                            curl: (Math.random() - 0.5) * 1.5,
                                            width: 3 + Math.random() * 5
                                        });
                                    }
                                    return arr;
                                })()
                            });
                            dropTimer = 3 + Math.random() * 5;
                        }

                        // Draw ink drops
                        for (var d = inkDrops.length - 1; d >= 0; d--) {
                            var drop = inkDrops[d];
                            drop.life += dt;
                            if (drop.life >= drop.maxLife) {
                                inkDrops.splice(d, 1);
                                continue;
                            }
                            var prog = drop.life / drop.maxLife;
                            var fadeIn = Math.min(1, drop.life * 2);
                            var fadeOut = prog > 0.6 ? (1 - (prog - 0.6) / 0.4) : 1;
                            var opacity = fadeIn * fadeOut;

                            // Central bloom
                            var bloomR = minDim * (0.02 + prog * 0.06);
                            var bGrad = ctx.createRadialGradient(drop.x, drop.y, 0, drop.x, drop.y, bloomR);
                            bGrad.addColorStop(0, 'hsla(' + drop.hue + ', 40%, 15%, ' + (opacity * 0.3) + ')');
                            bGrad.addColorStop(0.4, 'hsla(' + drop.hue + ', 50%, 20%, ' + (opacity * 0.15) + ')');
                            bGrad.addColorStop(1, 'hsla(' + drop.hue + ', 40%, 25%, 0)');
                            ctx.beginPath();
                            ctx.arc(drop.x, drop.y, bloomR, 0, Math.PI * 2);
                            ctx.fillStyle = bGrad;
                            ctx.fill();

                            // Tendrils extending outward
                            for (var j = 0; j < drop.tendrils.length; j++) {
                                var ten = drop.tendrils[j];
                                var tLen = ten.speed * drop.life;
                                ctx.beginPath();
                                var segments = 20;
                                for (var s = 0; s <= segments; s++) {
                                    var frac = s / segments;
                                    var dist = tLen * frac;
                                    var curlAngle = ten.angle + ten.curl * frac * frac;
                                    var tx = drop.x + Math.cos(curlAngle) * dist;
                                    var ty = drop.y + Math.sin(curlAngle) * dist;
                                    // Add organic wobble
                                    tx += Math.sin(frac * 8 + t * 0.3 + j * 2) * (3 + dist * 0.05);
                                    ty += Math.cos(frac * 6 + t * 0.2 + j * 3) * (2 + dist * 0.04);
                                    if (s === 0) ctx.moveTo(tx, ty);
                                    else ctx.lineTo(tx, ty);
                                }
                                var tOp = opacity * (0.08 + (1 - prog) * 0.08);
                                ctx.strokeStyle = 'hsla(' + ((drop.hue + j * 10) % 360) + ', 45%, 20%, ' + tOp + ')';
                                ctx.lineWidth = ten.width * (1 - prog * 0.5);
                                ctx.lineCap = 'round';
                                ctx.stroke();
                            }
                        }
                    }
                };
            })();

            // --- Pulsar theme ---
            // Rotating neutron star with sweeping beams and magnetic field lines
            themes.pulsar = (function () {
                // Pre-compute field line configs
                var fieldLines = [];
                for (var i = 0; i < 10; i++) {
                    fieldLines.push({
                        angleOffset: (i / 10) * Math.PI * 2,
                        height: 0.15 + Math.sin(i * 3.1) * 0.05,
                        width: 0.08 + Math.sin(i * 2.7) * 0.03,
                        opacity: 0.03 + Math.sin(i * 4.3) * 0.015
                    });
                }

                return {
                    targetCount: 60,

                    spawn: function (w, h) {
                        // Particles spiraling along field lines
                        return {
                            angle: Math.random() * Math.PI * 2,
                            dist: 0.1 + Math.random() * 0.3,
                            speed: 0.3 + Math.random() * 0.6,
                            size: 0.5 + Math.random() * 1,
                            opacity: 0.15 + Math.random() * 0.3,
                            wobble: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.angle += p.speed * dt;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var w = ctx.canvas.width;
                        var h = ctx.canvas.height;
                        var cx = w * 0.5;
                        var cy = h * 0.5;
                        var minDim = Math.min(w, h);
                        var dist = p.dist * minDim;
                        var wobble = Math.sin(state.timeElapsed * 2 + p.wobble) * dist * 0.1;
                        var px = cx + Math.cos(p.angle) * (dist + wobble);
                        var py = cy + Math.sin(p.angle) * (dist + wobble) * 0.6; // flatten to ellipse
                        ctx.beginPath();
                        ctx.arc(px, py, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(150, 200, 255, ' + p.opacity + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark space background
                        ctx.fillStyle = '#020308';
                        ctx.fillRect(0, 0, w, h);

                        var cx = w * 0.5;
                        var cy = h * 0.5;
                        var minDim = Math.min(w, h);

                        // Background stars
                        for (var i = 0; i < 60; i++) {
                            var sx = (Math.sin(i * 7.3 + 0.9) * 0.5 + 0.5) * w;
                            var sy = (Math.sin(i * 11.1 + 2.3) * 0.5 + 0.5) * h;
                            var sOp = (Math.sin(t * (0.3 + i * 0.04) + i * 1.5) * 0.5 + 0.5) * 0.3;
                            ctx.beginPath();
                            ctx.arc(sx, sy, 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 255, 255, ' + sOp + ')';
                            ctx.fill();
                        }

                        // Magnetic field lines (elliptical arcs around the star)
                        ctx.save();
                        ctx.translate(cx, cy);
                        for (var i = 0; i < fieldLines.length; i++) {
                            var fl = fieldLines[i];
                            var flH = fl.height * minDim;
                            var flW = fl.width * minDim;
                            ctx.beginPath();
                            ctx.ellipse(0, 0, flW, flH, fl.angleOffset + t * 0.05, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(100, 150, 255, ' + fl.opacity + ')';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Bright central neutron star
                        var starGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, minDim * 0.08);
                        starGlow.addColorStop(0, 'rgba(200, 220, 255, 0.6)');
                        starGlow.addColorStop(0.2, 'rgba(150, 180, 255, 0.25)');
                        starGlow.addColorStop(0.5, 'rgba(100, 140, 255, 0.08)');
                        starGlow.addColorStop(1, 'rgba(60, 100, 220, 0)');
                        ctx.beginPath();
                        ctx.arc(cx, cy, minDim * 0.08, 0, Math.PI * 2);
                        ctx.fillStyle = starGlow;
                        ctx.fill();
                        // Core
                        ctx.beginPath();
                        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(230, 240, 255, 0.9)';
                        ctx.fill();
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        var cx = w * 0.5;
                        var cy = h * 0.5;
                        var minDim = Math.min(w, h);

                        // Two sweeping beams rotating like a lighthouse
                        var beamAngle = t * 0.8; // rotation speed
                        var beamLen = Math.max(w, h) * 0.8;

                        for (var b = 0; b < 2; b++) {
                            var angle = beamAngle + b * Math.PI;
                            var bx = Math.cos(angle);
                            var by = Math.sin(angle);

                            // Beam as a narrow triangle with gradient
                            ctx.save();
                            ctx.translate(cx, cy);
                            ctx.rotate(angle);

                            var beamGrad = ctx.createLinearGradient(0, 0, beamLen, 0);
                            beamGrad.addColorStop(0, 'rgba(180, 210, 255, 0.2)');
                            beamGrad.addColorStop(0.1, 'rgba(150, 190, 255, 0.1)');
                            beamGrad.addColorStop(0.4, 'rgba(100, 150, 230, 0.03)');
                            beamGrad.addColorStop(1, 'rgba(60, 100, 200, 0)');

                            var beamWidth = minDim * 0.02;
                            ctx.beginPath();
                            ctx.moveTo(0, -beamWidth * 0.3);
                            ctx.lineTo(beamLen, -beamWidth * 2);
                            ctx.lineTo(beamLen, beamWidth * 2);
                            ctx.lineTo(0, beamWidth * 0.3);
                            ctx.closePath();
                            ctx.fillStyle = beamGrad;
                            ctx.fill();

                            ctx.restore();
                        }
                    }
                };
            })();

            // --- Nebular theme ---
            // Inside a nebula with rich colour clouds, dense star fields, gas pillars
            themes.nebular = {
                targetCount: 180,

                spawn: function (w, h) {
                    return {
                        x: Math.random() * w,
                        y: Math.random() * h,
                        size: 0.3 + Math.random() * 1.8,
                        baseOpacity: 0.2 + Math.random() * 0.6,
                        twinkleSpeed: 0.5 + Math.random() * 2.5,
                        twinkleOffset: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    return true; // Stars are stationary
                },

                draw: function (p, ctx, state) {
                    var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                    var op = p.baseOpacity * (0.5 + twinkle * 0.5);
                    if (op < 0.05) return;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + op + ')';
                    ctx.fill();
                    if (p.size > 1.2 && op > 0.4) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(220, 230, 255, ' + (op * 0.06) + ')';
                        ctx.fill();
                    }
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Deep space base
                    ctx.fillStyle = '#050308';
                    ctx.fillRect(0, 0, w, h);

                    // Rich colour clouds - large overlapping radial gradients
                    var clouds = [
                        { cx: 0.3, cy: 0.25, r: 0.35, hue: 340, sat: 50, light: 25, drift: 0.008 },
                        { cx: 0.7, cy: 0.6, r: 0.30, hue: 180, sat: 45, light: 22, drift: 0.006 },
                        { cx: 0.5, cy: 0.45, r: 0.40, hue: 40, sat: 55, light: 20, drift: 0.010 },
                        { cx: 0.2, cy: 0.7, r: 0.25, hue: 280, sat: 50, light: 23, drift: 0.007 },
                        { cx: 0.8, cy: 0.3, r: 0.28, hue: 200, sat: 40, light: 21, drift: 0.009 },
                        { cx: 0.45, cy: 0.8, r: 0.32, hue: 320, sat: 45, light: 24, drift: 0.005 }
                    ];

                    for (var i = 0; i < clouds.length; i++) {
                        var c = clouds[i];
                        var cx = (c.cx + Math.sin(t * c.drift + i * 2.3) * 0.04) * w;
                        var cy = (c.cy + Math.sin(t * c.drift * 0.7 + i * 3.1 + 1) * 0.03) * h;
                        var cr = c.r * Math.min(w, h);

                        var nebGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cr);
                        nebGrad.addColorStop(0, 'hsla(' + c.hue + ', ' + c.sat + '%, ' + c.light + '%, 0.12)');
                        nebGrad.addColorStop(0.2, 'hsla(' + c.hue + ', ' + (c.sat - 5) + '%, ' + (c.light - 2) + '%, 0.08)');
                        nebGrad.addColorStop(0.5, 'hsla(' + c.hue + ', ' + (c.sat - 10) + '%, ' + (c.light - 5) + '%, 0.04)');
                        nebGrad.addColorStop(1, 'hsla(' + c.hue + ', ' + c.sat + '%, ' + c.light + '%, 0)');
                        ctx.beginPath();
                        ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                        ctx.fillStyle = nebGrad;
                        ctx.fill();
                    }

                    // Gas pillars - tall dark columns
                    for (var i = 0; i < 3; i++) {
                        var px = w * (0.25 + i * 0.25 + Math.sin(i * 3.7 + t * 0.01) * 0.02);
                        var pw = w * (0.03 + Math.sin(i * 2.3) * 0.01);
                        var pTop = h * (0.2 + Math.sin(i * 4.1) * 0.1);
                        // Pillar body
                        ctx.beginPath();
                        ctx.moveTo(px - pw, h);
                        for (var y = h; y >= pTop; y -= 4) {
                            var frac = (h - y) / (h - pTop);
                            var wobble = Math.sin(y * 0.01 + t * 0.1 + i * 2) * pw * 0.3 * frac;
                            var taper = 1 - frac * 0.4;
                            ctx.lineTo(px - pw * taper + wobble, y);
                        }
                        for (var y = pTop; y <= h; y += 4) {
                            var frac = (h - y) / (h - pTop);
                            var wobble = Math.sin(y * 0.01 + t * 0.1 + i * 2) * pw * 0.3 * frac;
                            var taper = 1 - frac * 0.4;
                            ctx.lineTo(px + pw * taper + wobble, y);
                        }
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(8, 5, 12, 0.15)';
                        ctx.fill();
                        // Bright edge glow
                        ctx.strokeStyle = 'rgba(200, 150, 100, 0.03)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Binary theme ---
            // Binary star system with two orbiting stars and material streams
            themes.binary = (function () {
                var orbitRadius = 0.12;
                var orbitSpeed = 0.3;

                return {
                    targetCount: 80,

                    spawn: function (w, h) {
                        // Background stars
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.3 + Math.random() * 1.2,
                            baseOpacity: 0.15 + Math.random() * 0.4,
                            twinkleSpeed: 0.5 + Math.random() * 2,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.baseOpacity * (0.4 + twinkle * 0.6);
                        if (op < 0.04) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark space
                        ctx.fillStyle = '#030208';
                        ctx.fillRect(0, 0, w, h);

                        var cx = w * 0.5;
                        var cy = h * 0.5;
                        var minDim = Math.min(w, h);
                        var orbR = orbitRadius * minDim;

                        // Calculate star positions
                        var angle = t * orbitSpeed;
                        var s1x = cx + Math.cos(angle) * orbR;
                        var s1y = cy + Math.sin(angle) * orbR * 0.4;
                        var s2x = cx + Math.cos(angle + Math.PI) * orbR;
                        var s2y = cy + Math.sin(angle + Math.PI) * orbR * 0.4;

                        // Combined light glow (illuminates surrounding space)
                        var combinedGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, minDim * 0.4);
                        combinedGlow.addColorStop(0, 'rgba(180, 160, 200, 0.04)');
                        combinedGlow.addColorStop(0.5, 'rgba(150, 140, 180, 0.02)');
                        combinedGlow.addColorStop(1, 'rgba(100, 100, 150, 0)');
                        ctx.beginPath();
                        ctx.arc(cx, cy, minDim * 0.4, 0, Math.PI * 2);
                        ctx.fillStyle = combinedGlow;
                        ctx.fill();

                        // Material stream between stars (figure-eight pattern)
                        ctx.save();
                        ctx.globalAlpha = 0.6;
                        for (var i = 0; i < 30; i++) {
                            var streamAngle = angle + (i / 30) * Math.PI * 2;
                            var streamR = orbR * (0.8 + Math.sin(streamAngle * 2 + t) * 0.3);
                            var sx = cx + Math.cos(streamAngle) * streamR;
                            var sy = cy + Math.sin(streamAngle) * streamR * 0.4;
                            var sOp = 0.03 + Math.sin(i * 2.3 + t * 1.5) * 0.02;
                            ctx.beginPath();
                            ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(200, 180, 220, ' + sOp + ')';
                            ctx.fill();
                        }
                        ctx.restore();

                        // Warm star (gold/orange)
                        var warmGlow = ctx.createRadialGradient(s1x, s1y, 0, s1x, s1y, minDim * 0.06);
                        warmGlow.addColorStop(0, 'rgba(255, 240, 200, 0.5)');
                        warmGlow.addColorStop(0.2, 'rgba(255, 200, 120, 0.2)');
                        warmGlow.addColorStop(0.5, 'rgba(255, 170, 60, 0.06)');
                        warmGlow.addColorStop(1, 'rgba(255, 140, 30, 0)');
                        ctx.beginPath();
                        ctx.arc(s1x, s1y, minDim * 0.06, 0, Math.PI * 2);
                        ctx.fillStyle = warmGlow;
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(s1x, s1y, 5, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 245, 220, 0.9)';
                        ctx.fill();

                        // Cool star (blue/white)
                        var coolGlow = ctx.createRadialGradient(s2x, s2y, 0, s2x, s2y, minDim * 0.05);
                        coolGlow.addColorStop(0, 'rgba(200, 220, 255, 0.5)');
                        coolGlow.addColorStop(0.2, 'rgba(150, 190, 255, 0.2)');
                        coolGlow.addColorStop(0.5, 'rgba(100, 150, 240, 0.06)');
                        coolGlow.addColorStop(1, 'rgba(60, 100, 220, 0)');
                        ctx.beginPath();
                        ctx.arc(s2x, s2y, minDim * 0.05, 0, Math.PI * 2);
                        ctx.fillStyle = coolGlow;
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(s2x, s2y, 4, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(220, 235, 255, 0.9)';
                        ctx.fill();
                    },

                    drawForeground: function (ctx, w, h, state) {}
                };
            })();

            // --- Volcanic theme ---
            // Hawaiian-style lava flow with glowing cracks, lava rivers, steam
            themes.volcanic = (function () {
                // Lava fountain state
                var fountains = [];
                var fountainTimer = 3 + Math.random() * 5;
                var MAX_FOUNTAINS = 2;

                return {
                    targetCount: 20,

                    spawn: function (w, h) {
                        // Steam/smoke particles rising
                        return {
                            x: w * (0.1 + Math.random() * 0.8),
                            y: h * (0.5 + Math.random() * 0.3),
                            size: 5 + Math.random() * 10,
                            vy: -(8 + Math.random() * 15),
                            vx: (Math.random() - 0.5) * 6,
                            opacity: 0.03 + Math.random() * 0.04,
                            life: 0,
                            maxLife: 4 + Math.random() * 5
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.life += dt;
                        if (p.life >= p.maxLife) return false;
                        p.y += p.vy * dt;
                        p.x += p.vx * dt;
                        p.size += 2 * dt;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var fade = p.life > p.maxLife * 0.5 ? (1 - (p.life - p.maxLife * 0.5) / (p.maxLife * 0.5)) : 1;
                        var op = p.opacity * fade;
                        if (op < 0.005) return;
                        var smGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                        smGrad.addColorStop(0, 'rgba(120, 110, 100, ' + op + ')');
                        smGrad.addColorStop(1, 'rgba(80, 75, 70, 0)');
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = smGrad;
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark basalt base
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#1a0a08');
                        grad.addColorStop(0.3, '#140808');
                        grad.addColorStop(0.6, '#100606');
                        grad.addColorStop(1, '#0c0404');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Lava glow from below
                        var lavaGlow = ctx.createRadialGradient(w * 0.5, h, 0, w * 0.5, h * 0.5, h * 0.8);
                        lavaGlow.addColorStop(0, 'rgba(255, 80, 10, 0.08)');
                        lavaGlow.addColorStop(0.4, 'rgba(200, 40, 5, 0.04)');
                        lavaGlow.addColorStop(1, 'rgba(100, 20, 0, 0)');
                        ctx.fillStyle = lavaGlow;
                        ctx.fillRect(0, 0, w, h);

                        // Glowing cracks and fissures in the cooled crust
                        ctx.save();
                        for (var i = 0; i < 20; i++) {
                            var x1 = (Math.sin(i * 5.3 + 0.7) * 0.5 + 0.5) * w;
                            var y1 = h * 0.4 + (Math.sin(i * 3.7 + 1.2) * 0.5 + 0.5) * h * 0.55;
                            var angle = Math.sin(i * 4.1 + 2.3) * Math.PI * 0.5;
                            var len = 20 + (Math.sin(i * 2.9) * 0.5 + 0.5) * 60;
                            var x2 = x1 + Math.cos(angle) * len;
                            var y2 = y1 + Math.sin(angle) * len;
                            var pulse = Math.sin(t * 0.3 + i * 1.7) * 0.5 + 0.5;
                            var cOp = 0.1 + pulse * 0.15;

                            // Glow around crack
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.strokeStyle = 'rgba(255, 100, 20, ' + (cOp * 0.3) + ')';
                            ctx.lineWidth = 8;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                            // Crack line
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.strokeStyle = 'rgba(255, 180, 40, ' + cOp + ')';
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Lava rivers - glowing flowing lines
                        for (var r = 0; r < 3; r++) {
                            var ry = h * (0.55 + r * 0.15);
                            ctx.beginPath();
                            for (var x = 0; x <= w; x += 3) {
                                var rvy = ry + Math.sin(x * 0.005 + t * 0.1 + r * 2) * 15
                                    + Math.sin(x * 0.012 + t * 0.15 + r * 4) * 8;
                                if (x === 0) ctx.moveTo(x, rvy);
                                else ctx.lineTo(x, rvy);
                            }
                            ctx.strokeStyle = 'rgba(255, 120, 20, 0.08)';
                            ctx.lineWidth = 6;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                            ctx.strokeStyle = 'rgba(255, 200, 60, 0.12)';
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        // Occasional lava fountain bursts
                        fountainTimer -= dt;
                        if (fountainTimer <= 0 && fountains.length < MAX_FOUNTAINS) {
                            var fx = w * (0.2 + Math.random() * 0.6);
                            var particles = [];
                            for (var i = 0; i < 20; i++) {
                                var angle = -Math.PI * 0.3 - Math.random() * Math.PI * 0.4;
                                var speed = 80 + Math.random() * 150;
                                particles.push({
                                    x: fx, y: h * 0.6,
                                    vx: Math.cos(angle) * speed * (0.4 + Math.random()),
                                    vy: Math.sin(angle) * speed * (0.5 + Math.random()),
                                    size: 1.5 + Math.random() * 3,
                                    opacity: 0.6 + Math.random() * 0.4
                                });
                            }
                            fountains.push({ particles: particles, life: 0, maxLife: 2.5 + Math.random() * 2 });
                            fountainTimer = 4 + Math.random() * 6;
                        }
                        for (var f = fountains.length - 1; f >= 0; f--) {
                            var ftn = fountains[f];
                            ftn.life += dt;
                            if (ftn.life >= ftn.maxLife) { fountains.splice(f, 1); continue; }
                            var fFade = ftn.life > ftn.maxLife * 0.5 ? (1 - (ftn.life - ftn.maxLife * 0.5) / (ftn.maxLife * 0.5)) : 1;
                            for (var p = 0; p < ftn.particles.length; p++) {
                                var ep = ftn.particles[p];
                                ep.x += ep.vx * dt;
                                ep.y += ep.vy * dt;
                                ep.vy += 100 * dt;
                                var pOp = ep.opacity * fFade;
                                if (pOp < 0.02) continue;
                                ctx.beginPath();
                                ctx.arc(ep.x, ep.y, ep.size, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(255, ' + Math.floor(120 + Math.random() * 80) + ', 20, ' + pOp + ')';
                                ctx.fill();
                            }
                        }
                    }
                };
            })();

            // --- Cavern theme ---
            // Underground cave with stalactites/stalagmites, glowing minerals, underground pool
            themes.cavern = (function () {
                // Stalactite configs (hanging from top)
                var stalactites = [];
                for (var i = 0; i < 12; i++) {
                    stalactites.push({
                        x: (i / 12) + Math.sin(i * 4.3) * 0.02,
                        length: 0.08 + (Math.sin(i * 3.1 + 0.5) * 0.5 + 0.5) * 0.15,
                        width: 0.008 + (Math.sin(i * 2.7) * 0.5 + 0.5) * 0.01
                    });
                }
                // Stalagmite configs (rising from bottom)
                var stalagmites = [];
                for (var i = 0; i < 10; i++) {
                    stalagmites.push({
                        x: 0.05 + (i / 10) * 0.9 + Math.sin(i * 5.1) * 0.03,
                        height: 0.05 + (Math.sin(i * 2.3 + 1.7) * 0.5 + 0.5) * 0.12,
                        width: 0.01 + (Math.sin(i * 3.9) * 0.5 + 0.5) * 0.015
                    });
                }
                // Glowing mineral deposits
                var minerals = [];
                for (var i = 0; i < 15; i++) {
                    minerals.push({
                        x: (Math.sin(i * 6.7 + 0.3) * 0.5 + 0.5),
                        y: (Math.sin(i * 4.3 + 2.1) * 0.5 + 0.5),
                        hue: [170, 280, 120, 200, 50][i % 5],
                        size: 0.005 + (Math.sin(i * 3.1) * 0.5 + 0.5) * 0.01,
                        pulseSpeed: 0.3 + Math.sin(i * 2.7) * 0.2,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }

                // Water drop state
                var drops = [];
                var dropTimer = 1 + Math.random() * 2;

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        drops.length = 0;
                        dropTimer = 1 + Math.random() * 2;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Very dark cave background
                        var grad = ctx.createRadialGradient(w * 0.5, h * 0.6, 0, w * 0.5, h * 0.5, Math.max(w, h) * 0.6);
                        grad.addColorStop(0, '#0e0a08');
                        grad.addColorStop(0.4, '#0a0806');
                        grad.addColorStop(1, '#040304');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Glowing mineral deposits in the walls
                        for (var i = 0; i < minerals.length; i++) {
                            var m = minerals[i];
                            var mx = m.x * w;
                            var my = m.y * h;
                            var mSize = m.size * Math.min(w, h);
                            var pulse = Math.sin(t * m.pulseSpeed + m.pulseOffset);
                            var mOp = 0.04 + (pulse * 0.5 + 0.5) * 0.06;

                            var mGrad = ctx.createRadialGradient(mx, my, 0, mx, my, mSize * 3);
                            mGrad.addColorStop(0, 'hsla(' + m.hue + ', 70%, 60%, ' + mOp + ')');
                            mGrad.addColorStop(0.4, 'hsla(' + m.hue + ', 60%, 50%, ' + (mOp * 0.4) + ')');
                            mGrad.addColorStop(1, 'hsla(' + m.hue + ', 50%, 40%, 0)');
                            ctx.beginPath();
                            ctx.arc(mx, my, mSize * 3, 0, Math.PI * 2);
                            ctx.fillStyle = mGrad;
                            ctx.fill();
                            // Bright core
                            ctx.beginPath();
                            ctx.arc(mx, my, mSize * 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'hsla(' + m.hue + ', 80%, 70%, ' + (mOp * 0.6) + ')';
                            ctx.fill();
                        }

                        // Underground pool at the bottom (reflective surface)
                        var poolY = h * 0.78;
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (var x = 0; x <= w; x += 4) {
                            var py = poolY + Math.sin(x * 0.006 + t * 0.15) * 3 + Math.sin(x * 0.015 + t * 0.25) * 1.5;
                            ctx.lineTo(x, py);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(8, 15, 25, 0.4)';
                        ctx.fill();

                        // Pool reflections - faint copies of mineral glows
                        for (var i = 0; i < minerals.length; i++) {
                            var m = minerals[i];
                            if (m.y > 0.6) continue;
                            var mx = m.x * w;
                            var reflY = poolY + (poolY - m.y * h) * 0.15;
                            var pulse = Math.sin(t * m.pulseSpeed + m.pulseOffset);
                            var rOp = (0.02 + (pulse * 0.5 + 0.5) * 0.02);
                            ctx.beginPath();
                            ctx.arc(mx + Math.sin(t * 0.5 + i) * 3, reflY, 8, 0, Math.PI * 2);
                            ctx.fillStyle = 'hsla(' + m.hue + ', 50%, 50%, ' + rOp + ')';
                            ctx.fill();
                        }

                        // Stalactites
                        for (var i = 0; i < stalactites.length; i++) {
                            var s = stalactites[i];
                            var sx = s.x * w;
                            var sLen = s.length * h;
                            var sW = s.width * w;
                            ctx.beginPath();
                            ctx.moveTo(sx - sW, 0);
                            ctx.lineTo(sx + sW, 0);
                            ctx.lineTo(sx, sLen);
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(30, 25, 20, 0.4)';
                            ctx.fill();
                        }

                        // Stalagmites
                        for (var i = 0; i < stalagmites.length; i++) {
                            var s = stalagmites[i];
                            var sx = s.x * w;
                            var sH = s.height * h;
                            var sW = s.width * w;
                            ctx.beginPath();
                            ctx.moveTo(sx - sW, h);
                            ctx.lineTo(sx + sW, h);
                            ctx.lineTo(sx, h - sH);
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(35, 28, 22, 0.4)';
                            ctx.fill();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;

                        // Water drops falling from stalactites
                        dropTimer -= dt;
                        if (dropTimer <= 0) {
                            var srcStal = stalactites[Math.floor(Math.random() * stalactites.length)];
                            drops.push({
                                x: srcStal.x * w,
                                y: srcStal.length * h,
                                vy: 0,
                                size: 2,
                                opacity: 0.3,
                                ripple: false,
                                rippleTime: 0,
                                rippleX: 0,
                                rippleY: 0
                            });
                            dropTimer = 1.5 + Math.random() * 3;
                        }

                        for (var i = drops.length - 1; i >= 0; i--) {
                            var d = drops[i];
                            if (!d.ripple) {
                                d.vy += 200 * dt;
                                d.y += d.vy * dt;
                                // Check if hit pool
                                var poolY = h * 0.78;
                                if (d.y >= poolY) {
                                    d.ripple = true;
                                    d.rippleTime = 0;
                                    d.rippleX = d.x;
                                    d.rippleY = poolY;
                                }
                                // Draw drop
                                ctx.beginPath();
                                ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(150, 180, 210, ' + d.opacity + ')';
                                ctx.fill();
                            } else {
                                d.rippleTime += dt;
                                if (d.rippleTime > 2) { drops.splice(i, 1); continue; }
                                // Expanding ripple rings
                                for (var r = 0; r < 3; r++) {
                                    var rTime = d.rippleTime - r * 0.2;
                                    if (rTime < 0) continue;
                                    var rRadius = rTime * 30;
                                    var rOp = Math.max(0, 0.12 - rTime * 0.06);
                                    ctx.beginPath();
                                    ctx.ellipse(d.rippleX, d.rippleY, rRadius, rRadius * 0.2, 0, 0, Math.PI * 2);
                                    ctx.strokeStyle = 'rgba(150, 180, 210, ' + rOp + ')';
                                    ctx.lineWidth = 1;
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                };
            })();

            // --- Arctic theme ---
            // Frozen tundra with pale sun, ice crystals, icebergs, wind-blown snow
            themes.arctic = {
                targetCount: 50,

                spawn: function (w, h) {
                    // Wind-blown snow particles skimming the surface
                    return {
                        x: -10 - Math.random() * w * 0.2,
                        y: h * (0.5 + Math.random() * 0.45),
                        size: 0.5 + Math.random() * 1.5,
                        speed: 50 + Math.random() * 80,
                        drift: -3 + Math.random() * 6,
                        opacity: 0.15 + Math.random() * 0.3,
                        wobbleSpeed: 0.5 + Math.random() * 1,
                        wobbleOffset: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.x += p.speed * dt;
                    p.y += (p.drift + Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * 5) * dt;
                    if (p.x > w + 10) return false;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(230, 240, 255, ' + p.opacity + ')';
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Pale blue-white sky gradient
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#6080a0');
                    grad.addColorStop(0.25, '#8098b8');
                    grad.addColorStop(0.45, '#a0b4cc');
                    grad.addColorStop(0.55, '#c0d0e0');
                    grad.addColorStop(0.65, '#d0dce8');
                    grad.addColorStop(1, '#dce4ec');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Faint sun low on the horizon
                    var sunX = w * 0.3;
                    var sunY = h * 0.48;
                    var sunR = Math.min(w, h) * 0.04;
                    var sunGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR * 8);
                    sunGlow.addColorStop(0, 'rgba(255, 240, 210, 0.15)');
                    sunGlow.addColorStop(0.3, 'rgba(255, 230, 190, 0.06)');
                    sunGlow.addColorStop(1, 'rgba(255, 220, 170, 0)');
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, sunR * 8, 0, Math.PI * 2);
                    ctx.fillStyle = sunGlow;
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 245, 225, 0.35)';
                    ctx.fill();

                    // Ice landscape - flat with subtle textures
                    var iceY = h * 0.58;
                    ctx.beginPath();
                    ctx.moveTo(0, h);
                    for (var x = 0; x <= w; x += 4) {
                        var iy = iceY + Math.sin(x * 0.003 + 0.8) * 8 + Math.sin(x * 0.01 + 2.1) * 3;
                        ctx.lineTo(x, iy);
                    }
                    ctx.lineTo(w, h);
                    ctx.closePath();
                    var iceGrad = ctx.createLinearGradient(0, iceY, 0, h);
                    iceGrad.addColorStop(0, '#c8d8e8');
                    iceGrad.addColorStop(0.3, '#b8cce0');
                    iceGrad.addColorStop(1, '#a8c0d8');
                    ctx.fillStyle = iceGrad;
                    ctx.fill();

                    // Long blue shadows cast by the low sun
                    for (var i = 0; i < 6; i++) {
                        var shX = w * (0.15 + i * 0.14);
                        var shY = iceY + 5 + Math.sin(shX * 0.003 + 0.8) * 8;
                        var shLen = w * (0.05 + Math.sin(i * 3.1) * 0.02);
                        ctx.beginPath();
                        ctx.ellipse(shX + shLen * 0.5, shY + 3, shLen, 3, 0, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(80, 110, 150, 0.06)';
                        ctx.fill();
                    }

                    // Distant icebergs / pressure ridges
                    var ridgeConfigs = [
                        { x: 0.15, w: 0.06, h: 0.04 },
                        { x: 0.40, w: 0.08, h: 0.06 },
                        { x: 0.65, w: 0.05, h: 0.035 },
                        { x: 0.85, w: 0.07, h: 0.05 }
                    ];
                    for (var i = 0; i < ridgeConfigs.length; i++) {
                        var r = ridgeConfigs[i];
                        var rx = r.x * w;
                        var rw = r.w * w;
                        var rh = r.h * h;
                        var ry = iceY - 2 + Math.sin(rx * 0.003 + 0.8) * 8;
                        ctx.beginPath();
                        ctx.moveTo(rx, ry);
                        ctx.lineTo(rx + rw * 0.3, ry - rh);
                        ctx.lineTo(rx + rw * 0.5, ry - rh * 0.85);
                        ctx.lineTo(rx + rw * 0.7, ry - rh * 0.95);
                        ctx.lineTo(rx + rw, ry);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(190, 210, 230, 0.2)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(170, 195, 220, 0.1)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }

                    // Ice crystals sparkling in the air
                    for (var i = 0; i < 20; i++) {
                        var cx = (Math.sin(i * 7.3 + t * 0.05 + 1.2) * 0.5 + 0.5) * w;
                        var cy = (Math.sin(i * 5.1 + t * 0.03 + 2.8) * 0.5 + 0.5) * h * 0.55;
                        var sparkle = Math.sin(t * 2 + i * 3.7);
                        if (sparkle < 0.5) continue;
                        var sOp = (sparkle - 0.5) * 0.6;
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(t * 0.5 + i);
                        ctx.strokeStyle = 'rgba(220, 240, 255, ' + sOp + ')';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(-2, 0); ctx.lineTo(2, 0);
                        ctx.moveTo(0, -2); ctx.lineTo(0, 2);
                        ctx.moveTo(-1.5, -1.5); ctx.lineTo(1.5, 1.5);
                        ctx.moveTo(-1.5, 1.5); ctx.lineTo(1.5, -1.5);
                        ctx.stroke();
                        ctx.restore();
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Drifting theme ---
            // Floating down a calm river with parallax banks, lily pads, dappled light
            themes.drifting = (function () {
                // Parallax bank layers (left and right)
                var bankLayers = [
                    { depth: 0.3, color: '25, 50, 20', y: 0.35, height: 0.7 },
                    { depth: 0.5, color: '35, 65, 25', y: 0.40, height: 0.65 },
                    { depth: 0.8, color: '45, 80, 30', y: 0.45, height: 0.6 }
                ];

                // Overhanging branch configs
                var branches = [];
                for (var i = 0; i < 6; i++) {
                    branches.push({
                        xOffset: Math.random() * 2,
                        y: 0.05 + Math.random() * 0.25,
                        sag: 0.05 + Math.random() * 0.1,
                        length: 0.2 + Math.random() * 0.3,
                        side: i % 2 === 0 ? -1 : 1,
                        speed: 0.03 + Math.random() * 0.02
                    });
                }

                return {
                    targetCount: 25,

                    spawn: function (w, h) {
                        // Lily pads and leaves on the water surface
                        var isLeaf = Math.random() < 0.4;
                        return {
                            x: w + Math.random() * w * 0.3,
                            y: h * (0.4 + Math.random() * 0.25),
                            size: isLeaf ? (3 + Math.random() * 5) : (8 + Math.random() * 15),
                            speed: 30 + Math.random() * 20,
                            wobbleAmp: 3 + Math.random() * 5,
                            wobbleSpeed: 0.3 + Math.random() * 0.5,
                            wobbleOffset: Math.random() * Math.PI * 2,
                            opacity: 0.2 + Math.random() * 0.3,
                            isLeaf: isLeaf,
                            hue: isLeaf ? (80 + Math.random() * 40) : (110 + Math.random() * 30),
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 0.3
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.x -= p.speed * dt;
                        p.y += Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * p.wobbleAmp * dt;
                        p.rotation += p.rotSpeed * dt;
                        if (p.x < -p.size * 2) return false;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        if (p.isLeaf) {
                            ctx.beginPath();
                            ctx.ellipse(0, 0, p.size, p.size * 0.5, 0, 0, Math.PI * 2);
                        } else {
                            // Lily pad - circle with a wedge cut
                            ctx.beginPath();
                            ctx.arc(0, 0, p.size, 0.15, Math.PI * 2 - 0.15);
                            ctx.lineTo(0, 0);
                            ctx.closePath();
                        }
                        ctx.fillStyle = 'hsla(' + p.hue + ', 40%, 35%, ' + p.opacity + ')';
                        ctx.fill();
                        ctx.restore();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Water surface gradient (looking down at the river)
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#2a5a30');
                        grad.addColorStop(0.3, '#1a6848');
                        grad.addColorStop(0.5, '#1a7858');
                        grad.addColorStop(0.7, '#1a6848');
                        grad.addColorStop(1, '#1a5838');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Water current lines scrolling past
                        ctx.save();
                        ctx.strokeStyle = 'rgba(100, 180, 140, 0.04)';
                        ctx.lineWidth = 1;
                        for (var i = 0; i < 15; i++) {
                            var ly = h * (0.3 + (i / 15) * 0.45);
                            var scrollX = (t * (20 + i * 3)) % w;
                            ctx.beginPath();
                            for (var x = 0; x <= w; x += 4) {
                                var wy = ly + Math.sin((x + scrollX) * 0.01 + i * 2) * 3;
                                if (x === 0) ctx.moveTo(x, wy);
                                else ctx.lineTo(x, wy);
                            }
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Dappled light through canopy
                        for (var i = 0; i < 12; i++) {
                            var dx = ((Math.sin(i * 5.3 + t * 0.04) * 0.5 + 0.5) * 1.2 - 0.1) * w;
                            var dy = (Math.sin(i * 3.7 + t * 0.03 + 1.5) * 0.5 + 0.5) * h * 0.6;
                            var dr = 20 + Math.sin(i * 2.1 + t * 0.2) * 10;
                            var dOp = 0.03 + Math.sin(t * 0.3 + i * 1.8) * 0.015;
                            var dGrad = ctx.createRadialGradient(dx, dy, 0, dx, dy, dr);
                            dGrad.addColorStop(0, 'rgba(200, 240, 180, ' + dOp + ')');
                            dGrad.addColorStop(1, 'rgba(160, 220, 140, 0)');
                            ctx.beginPath();
                            ctx.arc(dx, dy, dr, 0, Math.PI * 2);
                            ctx.fillStyle = dGrad;
                            ctx.fill();
                        }

                        // Riverbank edges scrolling past (parallax layers)
                        for (var l = bankLayers.length - 1; l >= 0; l--) {
                            var bl = bankLayers[l];
                            var scrollSpeed = 15 * bl.depth;
                            var scroll = t * scrollSpeed;
                            // Top bank
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            for (var x = 0; x <= w; x += 4) {
                                var bankY = h * bl.y + Math.sin((x + scroll) * 0.008 + l * 2) * 15 + Math.sin((x + scroll) * 0.02 + l * 4) * 5;
                                ctx.lineTo(x, bankY);
                            }
                            ctx.lineTo(w, 0);
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(' + bl.color + ', 0.35)';
                            ctx.fill();
                            // Bottom bank (mirrored)
                            ctx.beginPath();
                            ctx.moveTo(0, h);
                            for (var x = 0; x <= w; x += 4) {
                                var bankY2 = h * (1 - bl.y + 0.15) + Math.sin((x + scroll * 1.1) * 0.008 + l * 3 + 1) * 15;
                                ctx.lineTo(x, bankY2);
                            }
                            ctx.lineTo(w, h);
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(' + bl.color + ', 0.3)';
                            ctx.fill();
                        }
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Overhanging branches passing overhead
                        for (var i = 0; i < branches.length; i++) {
                            var br = branches[i];
                            var bx = ((br.xOffset - t * br.speed) % 2.5) * w;
                            if (bx < -w * 0.4 || bx > w * 1.4) continue;
                            var startX = br.side > 0 ? bx : bx;
                            var startY = br.y * h;
                            var endX = startX + br.side * br.length * w;
                            var endY = startY + br.sag * h;
                            ctx.beginPath();
                            ctx.moveTo(startX, startY);
                            ctx.quadraticCurveTo(startX + br.side * br.length * w * 0.5, endY + br.sag * h * 0.5, endX, endY);
                            ctx.strokeStyle = 'rgba(30, 50, 20, 0.15)';
                            ctx.lineWidth = 3;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                            // Leaves on branch
                            for (var j = 0; j < 5; j++) {
                                var frac = (j + 1) / 6;
                                var lx = startX + (endX - startX) * frac + Math.sin(t * 0.5 + i + j) * 3;
                                var ly = startY + (endY - startY) * frac + Math.sin(frac * Math.PI) * br.sag * h * 0.3;
                                ctx.beginPath();
                                ctx.ellipse(lx, ly, 5, 3, t * 0.2 + j, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(40, 80, 30, 0.12)';
                                ctx.fill();
                            }
                        }
                    }
                };
            })();

            // --- Soaring theme ---
            // Gliding over rolling hills with parallax layers, clouds at eye level
            themes.soaring = {
                targetCount: 15,

                spawn: function (w, h) {
                    // Wispy clouds passing by at eye level
                    return {
                        x: w + Math.random() * w * 0.5,
                        y: h * (0.15 + Math.random() * 0.35),
                        rx: 40 + Math.random() * 80,
                        ry: 10 + Math.random() * 20,
                        speed: 40 + Math.random() * 60,
                        opacity: 0.06 + Math.random() * 0.08,
                        blobs: 2 + Math.floor(Math.random() * 3)
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.x -= p.speed * dt;
                    if (p.x < -p.rx * 3) return false;
                    return true;
                },

                draw: function (p, ctx) {
                    for (var b = 0; b < p.blobs; b++) {
                        var ox = (b - p.blobs * 0.5) * p.rx * 0.5;
                        var oy = Math.sin(b * 2.3) * p.ry * 0.3;
                        ctx.beginPath();
                        ctx.ellipse(p.x + ox, p.y + oy, p.rx * (0.5 + b * 0.15), p.ry * (0.7 + b * 0.1), 0, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(240, 245, 255, ' + p.opacity + ')';
                        ctx.fill();
                    }
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Sky gradient - looking slightly downward
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#4a80c0');
                    grad.addColorStop(0.2, '#6098d0');
                    grad.addColorStop(0.4, '#80b0dd');
                    grad.addColorStop(0.55, '#a0c8e8');
                    grad.addColorStop(0.65, '#90b8a0');
                    grad.addColorStop(1, '#608848');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Rolling hill layers (parallax, scrolling right to left)
                    var hillLayers = [
                        { y: 0.62, amp: 40, freq: 0.002, speed: 5, color: '70, 120, 60', opacity: 0.15 },
                        { y: 0.68, amp: 35, freq: 0.003, speed: 10, color: '60, 110, 50', opacity: 0.2 },
                        { y: 0.74, amp: 30, freq: 0.004, speed: 18, color: '50, 100, 40', opacity: 0.25 },
                        { y: 0.80, amp: 25, freq: 0.005, speed: 30, color: '45, 90, 35', opacity: 0.3 },
                        { y: 0.86, amp: 20, freq: 0.007, speed: 50, color: '40, 80, 30', opacity: 0.35 },
                        { y: 0.92, amp: 15, freq: 0.01, speed: 80, color: '35, 70, 28', opacity: 0.4 }
                    ];

                    for (var l = 0; l < hillLayers.length; l++) {
                        var hl = hillLayers[l];
                        var scroll = t * hl.speed;
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (var x = 0; x <= w; x += 3) {
                            var hy = h * hl.y
                                + Math.sin((x + scroll) * hl.freq) * hl.amp
                                + Math.sin((x + scroll) * hl.freq * 2.3 + l * 1.5) * hl.amp * 0.4
                                + Math.cos((x + scroll) * hl.freq * 0.5 + l * 3) * hl.amp * 0.25;
                            ctx.lineTo(x, hy);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(' + hl.color + ', ' + hl.opacity + ')';
                        ctx.fill();
                    }

                    // Patchwork field patterns on nearer hills
                    for (var i = 0; i < 10; i++) {
                        var scroll = t * 40;
                        var fx = ((i * 0.12 + Math.sin(i * 3.7) * 0.03 - scroll * 0.001) % 1.2 - 0.1) * w;
                        var fy = h * (0.78 + Math.sin(i * 5.1) * 0.04);
                        var fw = w * (0.03 + Math.sin(i * 2.3) * 0.01);
                        var fh = h * 0.02;
                        ctx.fillStyle = 'rgba(' + (35 + i * 3) + ', ' + (75 + i * 5) + ', ' + (25 + i * 2) + ', 0.08)';
                        ctx.fillRect(fx, fy, fw, fh);
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Cruising theme ---
            // Flying through clouds with volumetric layers and sun halos
            themes.cruising = {
                targetCount: 0,

                spawn: function (w, h) { return { x: 0, y: 0 }; },
                update: function (p, dt, w, h, state) { return true; },
                draw: function (p, ctx, state) {},

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Blue sky gradient
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#3068b0');
                    grad.addColorStop(0.4, '#5088c8');
                    grad.addColorStop(0.7, '#70a0d8');
                    grad.addColorStop(1, '#90b8e4');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Sun position (upper right, behind clouds)
                    var sunX = w * 0.75;
                    var sunY = h * 0.2;
                    var sunGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, Math.min(w, h) * 0.4);
                    sunGlow.addColorStop(0, 'rgba(255, 250, 230, 0.15)');
                    sunGlow.addColorStop(0.2, 'rgba(255, 240, 200, 0.08)');
                    sunGlow.addColorStop(0.5, 'rgba(255, 230, 180, 0.03)');
                    sunGlow.addColorStop(1, 'rgba(255, 220, 160, 0)');
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, Math.min(w, h) * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = sunGlow;
                    ctx.fill();
                },

                drawForeground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Cloud layers at different depths scrolling past
                    var cloudLayers = [
                        { speed: 12, y: 0.1, count: 4, scale: 1.5, opacity: 0.06 },
                        { speed: 25, y: 0.25, count: 5, scale: 1.2, opacity: 0.08 },
                        { speed: 45, y: 0.4, count: 6, scale: 1.0, opacity: 0.1 },
                        { speed: 70, y: 0.55, count: 5, scale: 0.8, opacity: 0.12 },
                        { speed: 100, y: 0.7, count: 4, scale: 0.6, opacity: 0.1 },
                        { speed: 140, y: 0.85, count: 3, scale: 0.5, opacity: 0.08 }
                    ];

                    for (var l = 0; l < cloudLayers.length; l++) {
                        var cl = cloudLayers[l];
                        for (var c = 0; c < cl.count; c++) {
                            var seed = l * 10 + c;
                            var baseX = (Math.sin(seed * 5.7 + 0.3) * 0.5 + 0.5) * w * 2;
                            var cx = ((baseX - t * cl.speed) % (w * 1.8)) - w * 0.4;
                            var cy = cl.y * h + Math.sin(seed * 3.1 + 0.8) * h * 0.06;

                            // Cloud as overlapping soft ellipses
                            var cloudW = (60 + Math.sin(seed * 2.3) * 30) * cl.scale;
                            var cloudH = (20 + Math.sin(seed * 4.1) * 10) * cl.scale;

                            for (var b = 0; b < 4; b++) {
                                var bx = cx + (b - 1.5) * cloudW * 0.35;
                                var by = cy + Math.sin(b * 2.7 + seed) * cloudH * 0.2;
                                var brx = cloudW * (0.4 + b * 0.08);
                                var bry = cloudH * (0.5 + b * 0.1);
                                ctx.beginPath();
                                ctx.ellipse(bx, by, brx, bry, 0, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(240, 245, 255, ' + cl.opacity + ')';
                                ctx.fill();
                            }

                            // Sun halo effect when cloud is near the sun
                            var sunX = w * 0.75;
                            var sunY = h * 0.2;
                            var distToSun = Math.sqrt((cx - sunX) * (cx - sunX) + (cy - sunY) * (cy - sunY));
                            if (distToSun < w * 0.3) {
                                var haloOp = (1 - distToSun / (w * 0.3)) * 0.04 * cl.opacity * 8;
                                var haloGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cloudW);
                                haloGrad.addColorStop(0, 'rgba(255, 245, 220, ' + haloOp + ')');
                                haloGrad.addColorStop(1, 'rgba(255, 240, 200, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy, cloudW, 0, Math.PI * 2);
                                ctx.fillStyle = haloGrad;
                                ctx.fill();
                            }
                        }
                    }

                    // Subtle vignette at edges to enhance the "window" feeling
                    var vigGrad = ctx.createRadialGradient(w * 0.5, h * 0.5, Math.min(w, h) * 0.3, w * 0.5, h * 0.5, Math.max(w, h) * 0.7);
                    vigGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.03)');
                    ctx.fillStyle = vigGrad;
                    ctx.fillRect(0, 0, w, h);
                }
            };

            // --- Tunnelling theme ---
            // Stars streaming outward from central vanishing point (starfield warp)
            themes.tunnelling = (function () {
                var STAR_COUNT = 200;
                var stars = [];
                var inited = false;

                function initStars() {
                    stars.length = 0;
                    for (var i = 0; i < STAR_COUNT; i++) {
                        stars.push({
                            x: (Math.random() - 0.5) * 2,
                            y: (Math.random() - 0.5) * 2,
                            z: Math.random() * 3,
                            prevSx: 0, prevSy: 0,
                            hasPrev: false
                        });
                    }
                    inited = true;
                }

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        initStars();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        // Deep black
                        ctx.fillStyle = '#010104';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        if (!inited) initStars();
                        var t = state.timeElapsed;
                        var cx = w * 0.5;
                        var cy = h * 0.5;
                        // Speed varies gently
                        var speed = 0.8 + Math.sin(t * 0.15) * 0.3 + Math.sin(t * 0.37 + 1.2) * 0.2;

                        for (var i = 0; i < stars.length; i++) {
                            var s = stars[i];
                            // Move star toward viewer
                            s.z -= speed * dt;
                            if (s.z <= 0.01) {
                                s.x = (Math.random() - 0.5) * 2;
                                s.y = (Math.random() - 0.5) * 2;
                                s.z = 2.5 + Math.random() * 0.5;
                                s.hasPrev = false;
                                continue;
                            }

                            // Project to screen
                            var sx = cx + (s.x / s.z) * w * 0.5;
                            var sy = cy + (s.y / s.z) * h * 0.5;

                            // Check bounds
                            if (sx < -10 || sx > w + 10 || sy < -10 || sy > h + 10) {
                                s.x = (Math.random() - 0.5) * 2;
                                s.y = (Math.random() - 0.5) * 2;
                                s.z = 2.5 + Math.random() * 0.5;
                                s.hasPrev = false;
                                continue;
                            }

                            var brightness = Math.min(1, (3 - s.z) / 2);
                            var size = Math.max(0.5, (1 - s.z / 3) * 3);

                            // Draw streak from previous to current position
                            if (s.hasPrev) {
                                ctx.beginPath();
                                ctx.moveTo(s.prevSx, s.prevSy);
                                ctx.lineTo(sx, sy);
                                ctx.strokeStyle = 'rgba(200, 220, 255, ' + (brightness * 0.5) + ')';
                                ctx.lineWidth = size * 0.7;
                                ctx.lineCap = 'round';
                                ctx.stroke();
                            }

                            // Star point
                            ctx.beginPath();
                            ctx.arc(sx, sy, size, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(230, 240, 255, ' + brightness + ')';
                            ctx.fill();

                            s.prevSx = sx;
                            s.prevSy = sy;
                            s.hasPrev = true;
                        }

                        // Occasional colour streaks
                        for (var i = 0; i < 3; i++) {
                            var streakPhase = Math.sin(t * 0.2 + i * 2.3);
                            if (streakPhase < 0.7) continue;
                            var sAngle = t * 0.3 + i * Math.PI * 0.67;
                            var sLen = (streakPhase - 0.7) * 300;
                            var sx1 = cx + Math.cos(sAngle) * 20;
                            var sy1 = cy + Math.sin(sAngle) * 20;
                            var sx2 = cx + Math.cos(sAngle) * (20 + sLen);
                            var sy2 = cy + Math.sin(sAngle) * (20 + sLen);
                            var hues = [200, 280, 340];
                            ctx.beginPath();
                            ctx.moveTo(sx1, sy1);
                            ctx.lineTo(sx2, sy2);
                            ctx.strokeStyle = 'hsla(' + hues[i] + ', 70%, 60%, ' + ((streakPhase - 0.7) * 0.15) + ')';
                            ctx.lineWidth = 1.5;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                        }

                        // Central glow
                        var cGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
                        cGrad.addColorStop(0, 'rgba(180, 200, 255, 0.06)');
                        cGrad.addColorStop(1, 'rgba(120, 150, 220, 0)');
                        ctx.beginPath();
                        ctx.arc(cx, cy, 30, 0, Math.PI * 2);
                        ctx.fillStyle = cGrad;
                        ctx.fill();
                    }
                };
            })();

            // --- Coasting theme ---
            // Night drive with perspective road, streetlights, distant city glow
            themes.coasting = (function () {
                // Road lines state
                var ROAD_LINE_COUNT = 12;

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark night sky
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#060814');
                        grad.addColorStop(0.3, '#0a0e1a');
                        grad.addColorStop(0.45, '#0c1020');
                        grad.addColorStop(0.5, '#101828');
                        grad.addColorStop(1, '#141c2a');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Distant city glow on the horizon
                        var horizonY = h * 0.48;
                        var cityGlow = ctx.createRadialGradient(w * 0.5, horizonY, 0, w * 0.5, horizonY, w * 0.5);
                        cityGlow.addColorStop(0, 'rgba(255, 180, 80, 0.06)');
                        cityGlow.addColorStop(0.4, 'rgba(255, 150, 60, 0.03)');
                        cityGlow.addColorStop(1, 'rgba(255, 120, 40, 0)');
                        ctx.beginPath();
                        ctx.arc(w * 0.5, horizonY, w * 0.5, 0, Math.PI * 2);
                        ctx.fillStyle = cityGlow;
                        ctx.fill();

                        // Stars in the sky
                        for (var i = 0; i < 40; i++) {
                            var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                            var sy = (Math.sin(i * 11.1 + 2.1) * 0.5 + 0.5) * h * 0.4;
                            var sOp = (Math.sin(t * (0.4 + i * 0.03) + i * 1.5) * 0.5 + 0.5) * 0.3;
                            ctx.beginPath();
                            ctx.arc(sx, sy, 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 255, 255, ' + sOp + ')';
                            ctx.fill();
                        }

                        // Road surface (perspective trapezoid)
                        var roadTop = horizonY;
                        var roadTopW = w * 0.02;
                        var roadBottomW = w * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(w * 0.5 - roadTopW, roadTop);
                        ctx.lineTo(w * 0.5 + roadTopW, roadTop);
                        ctx.lineTo(w * 0.5 + roadBottomW, h);
                        ctx.lineTo(w * 0.5 - roadBottomW, h);
                        ctx.closePath();
                        ctx.fillStyle = '#1a1a22';
                        ctx.fill();

                        // Road edge lines
                        ctx.beginPath();
                        ctx.moveTo(w * 0.5 - roadTopW, roadTop);
                        ctx.lineTo(w * 0.5 - roadBottomW, h);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(w * 0.5 + roadTopW, roadTop);
                        ctx.lineTo(w * 0.5 + roadBottomW, h);
                        ctx.stroke();
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        var horizonY = h * 0.48;
                        var speed = 60;

                        // Centre dashed road lines scrolling toward viewer
                        var dashLen = 0.08;
                        var gapLen = 0.06;
                        var cycleLen = dashLen + gapLen;
                        var scrollOffset = (t * speed * 0.01) % cycleLen;

                        for (var d = 0; d < 20; d++) {
                            var zStart = scrollOffset + d * cycleLen;
                            var zEnd = zStart + dashLen;
                            if (zStart > 2) break;

                            // Perspective: convert z to screen y
                            var y1 = horizonY + (h - horizonY) / (1 + zStart * 3);
                            var y2 = horizonY + (h - horizonY) / (1 + zEnd * 3);
                            if (y1 > h || y2 < horizonY) continue;
                            y1 = Math.max(horizonY, y1);
                            y2 = Math.min(h, y2);

                            var lineW1 = 1 + (y1 - horizonY) / (h - horizonY) * 3;
                            var lineOp = 0.1 + (y1 - horizonY) / (h - horizonY) * 0.15;

                            ctx.beginPath();
                            ctx.moveTo(w * 0.5, y1);
                            ctx.lineTo(w * 0.5, y2);
                            ctx.strokeStyle = 'rgba(255, 255, 200, ' + lineOp + ')';
                            ctx.lineWidth = lineW1;
                            ctx.stroke();
                        }

                        // Streetlights passing overhead
                        var lightSpacing = 0.3;
                        var lightScroll = (t * speed * 0.005) % lightSpacing;
                        for (var l = 0; l < 8; l++) {
                            var lz = lightScroll + l * lightSpacing;
                            if (lz > 2) break;
                            var ly = horizonY + (h - horizonY) / (1 + lz * 3);
                            if (ly > h || ly < horizonY) continue;
                            var perspective = (ly - horizonY) / (h - horizonY);
                            var lx = w * 0.5 + (w * 0.02 + perspective * w * 0.35) * (l % 2 === 0 ? -1 : 1);
                            var lightR = 3 + perspective * 8;
                            var lightOp = 0.05 + perspective * 0.15;

                            // Light pole (thin line)
                            ctx.beginPath();
                            ctx.moveTo(lx, ly);
                            ctx.lineTo(lx, ly - lightR * 3);
                            ctx.strokeStyle = 'rgba(80, 80, 90, ' + (lightOp * 0.5) + ')';
                            ctx.lineWidth = 1 + perspective;
                            ctx.stroke();

                            // Light glow
                            var lgGrad = ctx.createRadialGradient(lx, ly - lightR * 3, 0, lx, ly - lightR * 3, lightR * 4);
                            lgGrad.addColorStop(0, 'rgba(255, 220, 150, ' + lightOp + ')');
                            lgGrad.addColorStop(0.3, 'rgba(255, 200, 120, ' + (lightOp * 0.4) + ')');
                            lgGrad.addColorStop(1, 'rgba(255, 180, 80, 0)');
                            ctx.beginPath();
                            ctx.arc(lx, ly - lightR * 3, lightR * 4, 0, Math.PI * 2);
                            ctx.fillStyle = lgGrad;
                            ctx.fill();
                        }

                        // Fog in headlights
                        var fogGrad = ctx.createRadialGradient(w * 0.5, h, 0, w * 0.5, h * 0.6, h * 0.5);
                        fogGrad.addColorStop(0, 'rgba(200, 200, 180, 0.02)');
                        fogGrad.addColorStop(0.5, 'rgba(180, 180, 160, 0.01)');
                        fogGrad.addColorStop(1, 'rgba(150, 150, 140, 0)');
                        ctx.fillStyle = fogGrad;
                        ctx.fillRect(0, h * 0.4, w, h * 0.6);
                    }
                };
            })();

            // --- Diving theme ---
            // Descending through ocean depth zones, light fading, creatures passing
            themes.diving = {
                targetCount: 30,

                spawn: function (w, h) {
                    // Marine life silhouettes drifting upward past the viewer
                    var types = ['jellyfish', 'fish', 'plankton'];
                    var type = types[Math.floor(Math.random() * types.length)];
                    return {
                        x: Math.random() * w,
                        y: h + 10 + Math.random() * h * 0.3,
                        type: type,
                        size: type === 'plankton' ? (1 + Math.random() * 2) : (5 + Math.random() * 15),
                        speed: 20 + Math.random() * 40,
                        drift: (Math.random() - 0.5) * 15,
                        opacity: 0.06 + Math.random() * 0.12,
                        wobbleSpeed: 0.5 + Math.random() * 1,
                        wobbleOffset: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.y -= p.speed * dt;
                    p.x += (p.drift + Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * 8) * dt;
                    if (p.y < -p.size * 2) return false;
                    return true;
                },

                draw: function (p, ctx, state) {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    if (p.type === 'jellyfish') {
                        // Bell shape
                        var pulse = Math.sin(state.timeElapsed * 2 + p.wobbleOffset) * 0.15;
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size * (1 + pulse), Math.PI, 0);
                        ctx.fillStyle = 'rgba(150, 180, 220, ' + p.opacity + ')';
                        ctx.fill();
                        // Tentacles
                        for (var t = 0; t < 4; t++) {
                            var tx = (t - 1.5) * p.size * 0.4;
                            ctx.beginPath();
                            ctx.moveTo(tx, 0);
                            ctx.quadraticCurveTo(tx + Math.sin(state.timeElapsed * 1.5 + t) * 5, p.size * 0.8, tx + Math.sin(state.timeElapsed + t * 2) * 3, p.size * 1.5);
                            ctx.strokeStyle = 'rgba(150, 180, 220, ' + (p.opacity * 0.5) + ')';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    } else if (p.type === 'fish') {
                        ctx.beginPath();
                        ctx.ellipse(0, 0, p.size, p.size * 0.4, 0, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(120, 150, 180, ' + p.opacity + ')';
                        ctx.fill();
                        // Tail
                        ctx.beginPath();
                        ctx.moveTo(p.size * 0.8, 0);
                        ctx.lineTo(p.size * 1.3, -p.size * 0.3);
                        ctx.lineTo(p.size * 1.3, p.size * 0.3);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(140, 170, 200, ' + p.opacity + ')';
                        ctx.fill();
                    }
                    ctx.restore();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Depth zones - colour shifts over time (cycling through depths)
                    var depthCycle = (t * 0.03) % 1;
                    var hue1 = 190 - depthCycle * 30;
                    var light1 = 45 - depthCycle * 30;
                    var light2 = 35 - depthCycle * 25;
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, 'hsl(' + hue1 + ', 50%, ' + Math.max(5, light1) + '%)');
                    grad.addColorStop(0.5, 'hsl(' + (hue1 - 10) + ', 45%, ' + Math.max(3, light2) + '%)');
                    grad.addColorStop(1, 'hsl(' + (hue1 - 20) + ', 40%, ' + Math.max(2, light2 - 5) + '%)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Light shafts from above (narrow and fade with depth)
                    var shaftIntensity = Math.max(0, 1 - depthCycle * 1.5);
                    if (shaftIntensity > 0) {
                        for (var i = 0; i < 5; i++) {
                            var sx = w * (0.15 + i * 0.18 + Math.sin(t * 0.1 + i * 2) * 0.03);
                            var spread = w * 0.02 * (1 + depthCycle * 2);
                            var shaftGrad = ctx.createLinearGradient(sx, 0, sx, h * (0.4 + depthCycle * 0.3));
                            shaftGrad.addColorStop(0, 'rgba(150, 200, 255, ' + (0.04 * shaftIntensity) + ')');
                            shaftGrad.addColorStop(1, 'rgba(100, 160, 220, 0)');
                            ctx.beginPath();
                            ctx.moveTo(sx - spread, 0);
                            ctx.lineTo(sx + spread, 0);
                            ctx.lineTo(sx + spread * 4, h * 0.6);
                            ctx.lineTo(sx - spread * 4, h * 0.6);
                            ctx.closePath();
                            ctx.fillStyle = shaftGrad;
                            ctx.fill();
                        }
                    }

                    // Bubbles rising past (from our descent disturbing water)
                    for (var i = 0; i < 8; i++) {
                        var bx = w * (0.3 + Math.sin(i * 5.3 + t * 0.1) * 0.2);
                        var by = ((h + i * h * 0.15 - t * 30) % (h * 1.3)) - h * 0.15;
                        var bSize = 2 + Math.sin(i * 3.1) * 1;
                        ctx.beginPath();
                        ctx.arc(bx, by, bSize, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(180, 210, 240, 0.08)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Ascending theme ---
            // Rising through atmosphere layers from ground haze to stars
            themes.ascending = {
                targetCount: 40,

                spawn: function (w, h) {
                    // Particles: mix of cloud wisps and stars
                    var isStar = Math.random() < 0.5;
                    return {
                        x: Math.random() * w,
                        y: Math.random() * h,
                        size: isStar ? (0.5 + Math.random() * 1.5) : (15 + Math.random() * 40),
                        speed: 15 + Math.random() * 30,
                        opacity: isStar ? (0.1 + Math.random() * 0.4) : (0.03 + Math.random() * 0.05),
                        isStar: isStar,
                        twinkleSpeed: 1 + Math.random() * 2,
                        twinkleOffset: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    // Everything drifts downward (we're rising)
                    p.y += p.speed * dt;
                    if (p.y > h + p.size * 2) return false;
                    return true;
                },

                draw: function (p, ctx, state) {
                    if (p.isStar) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.opacity * (0.4 + twinkle * 0.6);
                        if (op < 0.03) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + op + ')';
                        ctx.fill();
                    } else {
                        // Cloud wisp
                        ctx.beginPath();
                        ctx.ellipse(p.x, p.y, p.size, p.size * 0.3, 0, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(220, 230, 245, ' + p.opacity + ')';
                        ctx.fill();
                    }
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Sky darkens as we climb (cycle through altitude)
                    var altCycle = (t * 0.02) % 1;
                    var topHue = 210;
                    var topLight = Math.max(3, 50 - altCycle * 48);
                    var botLight = Math.max(5, 60 - altCycle * 45);
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, 'hsl(' + topHue + ', 40%, ' + topLight + '%)');
                    grad.addColorStop(0.6, 'hsl(' + (topHue + 5) + ', 35%, ' + ((topLight + botLight) * 0.5) + '%)');
                    grad.addColorStop(1, 'hsl(' + (topHue + 10) + ', 30%, ' + botLight + '%)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Horizon curvature becomes visible at high altitude
                    if (altCycle > 0.5) {
                        var curveAmount = (altCycle - 0.5) * 2;
                        var curveY = h * (0.85 + curveAmount * 0.1);
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        ctx.quadraticCurveTo(w * 0.5, curveY, w, h);
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(100, 150, 200, ' + (curveAmount * 0.06) + ')';
                        ctx.fill();
                        // Thin atmosphere line at horizon
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        ctx.quadraticCurveTo(w * 0.5, curveY, w, h);
                        ctx.strokeStyle = 'rgba(150, 200, 255, ' + (curveAmount * 0.08) + ')';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    // Ground haze falling away below
                    if (altCycle < 0.6) {
                        var hazeOp = (1 - altCycle / 0.6) * 0.1;
                        var hazeGrad = ctx.createLinearGradient(0, h * 0.7, 0, h);
                        hazeGrad.addColorStop(0, 'rgba(200, 210, 220, 0)');
                        hazeGrad.addColorStop(1, 'rgba(200, 210, 220, ' + hazeOp + ')');
                        ctx.fillStyle = hazeGrad;
                        ctx.fillRect(0, 0, w, h);
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Wandering theme ---
            // Walking through endless forest with parallax tree trunks, light shafts, fireflies
            themes.wandering = (function () {
                // Tree layer configs for parallax
                var treeLayers = [
                    { count: 4, depth: 0.2, spacing: 0.28, widthMin: 0.025, widthMax: 0.04, opacity: 0.08 },
                    { count: 5, depth: 0.4, spacing: 0.22, widthMin: 0.02, widthMax: 0.035, opacity: 0.12 },
                    { count: 6, depth: 0.65, spacing: 0.18, widthMin: 0.015, widthMax: 0.03, opacity: 0.18 },
                    { count: 5, depth: 0.85, spacing: 0.22, widthMin: 0.018, widthMax: 0.035, opacity: 0.25 }
                ];

                // Fireflies
                var fireflies = [];
                for (var i = 0; i < 10; i++) {
                    fireflies.push({
                        x: Math.random(),
                        y: 0.3 + Math.random() * 0.5,
                        pulseSpeed: 0.6 + Math.random() * 1.5,
                        pulseOffset: Math.random() * Math.PI * 2,
                        driftX: 0.01 + Math.random() * 0.02,
                        driftY: 0.005 + Math.random() * 0.01,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2
                    });
                }

                return {
                    targetCount: 20,

                    spawn: function (w, h) {
                        // Dust motes in the air
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.5 + Math.random() * 1.5,
                            opacity: 0.05 + Math.random() * 0.1,
                            twinkleSpeed: 0.5 + Math.random() * 1.5,
                            twinkleOffset: Math.random() * Math.PI * 2,
                            driftX: (Math.random() - 0.5) * 3,
                            driftY: -(1 + Math.random() * 2)
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.x += p.driftX * dt;
                        p.y += p.driftY * dt;
                        if (p.y < -5) return false;
                        if (p.x < -5) p.x = w + 5;
                        if (p.x > w + 5) p.x = -5;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.opacity * (0.3 + twinkle * 0.7);
                        if (op < 0.01) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(220, 230, 200, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Deep forest green gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#1a2a18');
                        grad.addColorStop(0.3, '#1e3220');
                        grad.addColorStop(0.6, '#223828');
                        grad.addColorStop(1, '#1a3020');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Light shafts between the trees
                        for (var i = 0; i < 5; i++) {
                            var shaftX = ((i * 0.22 + Math.sin(i * 3.7) * 0.05 + t * 0.01) % 1.3 - 0.15) * w;
                            var shaftW = w * 0.02;
                            var shaftOp = 0.03 + Math.sin(t * 0.2 + i * 2.1) * 0.015;
                            var shaftGrad = ctx.createLinearGradient(shaftX, 0, shaftX, h);
                            shaftGrad.addColorStop(0, 'rgba(200, 220, 160, ' + shaftOp + ')');
                            shaftGrad.addColorStop(0.5, 'rgba(180, 200, 140, ' + (shaftOp * 0.5) + ')');
                            shaftGrad.addColorStop(1, 'rgba(160, 180, 120, 0)');
                            ctx.beginPath();
                            ctx.moveTo(shaftX - shaftW, 0);
                            ctx.lineTo(shaftX + shaftW, 0);
                            ctx.lineTo(shaftX + shaftW * 4, h);
                            ctx.lineTo(shaftX - shaftW * 4, h);
                            ctx.closePath();
                            ctx.fillStyle = shaftGrad;
                            ctx.fill();
                        }

                        // Parallax tree trunk layers scrolling past
                        for (var l = 0; l < treeLayers.length; l++) {
                            var layer = treeLayers[l];
                            var scrollSpeed = 8 * layer.depth;
                            var scroll = t * scrollSpeed;

                            for (var tr = 0; tr < layer.count; tr++) {
                                var seed = l * 20 + tr;
                                var baseX = (Math.sin(seed * 4.7 + 0.3) * 0.5 + 0.5) * layer.spacing + tr * layer.spacing;
                                var tx = ((baseX - scroll * 0.01) % 1.2 - 0.1) * w;
                                var tw = w * (layer.widthMin + Math.sin(seed * 3.1) * (layer.widthMax - layer.widthMin) * 0.5);

                                // Trunk
                                ctx.fillStyle = 'rgba(30, 25, 18, ' + layer.opacity + ')';
                                ctx.fillRect(tx, 0, tw, h);

                                // Subtle bark texture
                                for (var b = 0; b < 5; b++) {
                                    var barkY = (b / 5) * h;
                                    ctx.fillStyle = 'rgba(20, 18, 12, ' + (layer.opacity * 0.3) + ')';
                                    ctx.fillRect(tx, barkY, tw, 2);
                                }
                            }
                        }

                        // Ground foliage at the bottom
                        ctx.beginPath();
                        ctx.moveTo(0, h);
                        for (var x = 0; x <= w; x += 3) {
                            var gy = h * 0.92 + Math.sin(x * 0.02 + t * 0.5) * 5 + Math.sin(x * 0.05 + t * 0.3) * 3;
                            ctx.lineTo(x, gy);
                        }
                        ctx.lineTo(w, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(20, 40, 15, 0.3)';
                        ctx.fill();
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Fireflies
                        for (var i = 0; i < fireflies.length; i++) {
                            var ff = fireflies[i];
                            var fx = (ff.x + Math.sin(t * ff.driftX + ff.phaseX) * 0.1) * w;
                            var fy = (ff.y + Math.sin(t * ff.driftY + ff.phaseY) * 0.05) * h;
                            var pulse = Math.sin(t * ff.pulseSpeed + ff.pulseOffset);
                            var fOp = Math.max(0, pulse) * 0.2;
                            if (fOp < 0.02) continue;
                            var ffGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, 10);
                            ffGrad.addColorStop(0, 'rgba(200, 240, 100, ' + fOp + ')');
                            ffGrad.addColorStop(0.4, 'rgba(160, 210, 60, ' + (fOp * 0.4) + ')');
                            ffGrad.addColorStop(1, 'rgba(120, 180, 40, 0)');
                            ctx.beginPath();
                            ctx.arc(fx, fy, 10, 0, Math.PI * 2);
                            ctx.fillStyle = ffGrad;
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(fx, fy, 1.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(230, 255, 140, ' + (fOp * 0.7) + ')';
                            ctx.fill();
                        }

                        // Mushrooms on the ground (scrolling past slowly)
                        var mushScroll = t * 5;
                        for (var i = 0; i < 6; i++) {
                            var mx = ((i * 0.18 + Math.sin(i * 3.7) * 0.04 - mushScroll * 0.005) % 1.2 - 0.1) * w;
                            var my = h * (0.92 + Math.sin(i * 5.1) * 0.02);
                            var mSize = 4 + Math.sin(i * 2.3) * 2;
                            // Cap
                            ctx.beginPath();
                            ctx.arc(mx, my - mSize, mSize, Math.PI, 0);
                            ctx.fillStyle = 'rgba(180, 80, 60, 0.08)';
                            ctx.fill();
                            // Stem
                            ctx.fillStyle = 'rgba(200, 190, 170, 0.06)';
                            ctx.fillRect(mx - 1, my - mSize, 2, mSize);
                        }
                    }
                };
            })();

            // --- Sailing theme ---
            // View from a boat on open ocean with rolling waves and rocking motion
            themes.sailing = (function () {
                // Seabird state
                var birds = [];
                for (var i = 0; i < 3; i++) {
                    birds.push({
                        x: Math.random(),
                        y: 0.15 + Math.random() * 0.2,
                        speed: 0.02 + Math.random() * 0.02,
                        wingSpeed: 2 + Math.random() * 2,
                        wingOffset: Math.random() * Math.PI * 2,
                        size: 6 + Math.random() * 4
                    });
                }

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Gentle rocking motion (whole scene oscillates)
                        var rockAngle = Math.sin(t * 0.4) * 0.008 + Math.sin(t * 0.67 + 1.2) * 0.005;
                        var rockY = Math.sin(t * 0.5 + 0.3) * 5;

                        ctx.save();
                        ctx.translate(w * 0.5, h * 0.5);
                        ctx.rotate(rockAngle);
                        ctx.translate(-w * 0.5, -h * 0.5 + rockY);

                        // Sky gradient
                        var skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                        skyGrad.addColorStop(0, '#4878b0');
                        skyGrad.addColorStop(0.4, '#6898c8');
                        skyGrad.addColorStop(0.7, '#88b0d8');
                        skyGrad.addColorStop(1, '#a8c8e4');
                        ctx.fillStyle = skyGrad;
                        ctx.fillRect(-20, -20, w + 40, h * 0.52);

                        // Horizon line
                        var horizonY = h * 0.48;

                        // Ocean with rolling waves toward the viewer
                        var oceanGrad = ctx.createLinearGradient(0, horizonY, 0, h + 20);
                        oceanGrad.addColorStop(0, '#2868a0');
                        oceanGrad.addColorStop(0.3, '#1a5888');
                        oceanGrad.addColorStop(0.6, '#184878');
                        oceanGrad.addColorStop(1, '#143868');
                        ctx.fillStyle = oceanGrad;
                        ctx.fillRect(-20, horizonY, w + 40, h);

                        // Wave layers rolling toward the viewer (perspective)
                        var waveLayers = [
                            { y: 0.50, amp: 5, freq: 0.008, speed: 0.15, opacity: 0.04 },
                            { y: 0.55, amp: 8, freq: 0.006, speed: 0.2, opacity: 0.05 },
                            { y: 0.62, amp: 12, freq: 0.005, speed: 0.25, opacity: 0.06 },
                            { y: 0.70, amp: 16, freq: 0.004, speed: 0.3, opacity: 0.07 },
                            { y: 0.78, amp: 20, freq: 0.003, speed: 0.35, opacity: 0.08 },
                            { y: 0.86, amp: 25, freq: 0.0025, speed: 0.4, opacity: 0.09 },
                            { y: 0.94, amp: 30, freq: 0.002, speed: 0.45, opacity: 0.1 }
                        ];

                        for (var l = 0; l < waveLayers.length; l++) {
                            var wl = waveLayers[l];
                            var baseY = h * wl.y;
                            ctx.beginPath();
                            ctx.moveTo(-20, h + 20);
                            for (var x = -20; x <= w + 20; x += 3) {
                                var wy = baseY
                                    + Math.sin(x * wl.freq + t * wl.speed) * wl.amp
                                    + Math.sin(x * wl.freq * 2.3 + t * wl.speed * 1.4 + l) * wl.amp * 0.4;
                                ctx.lineTo(x, wy);
                            }
                            ctx.lineTo(w + 20, h + 20);
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(30, 80, 140, ' + wl.opacity + ')';
                            ctx.fill();

                            // Foam/whitecap highlights on wave crests
                            if (l > 2) {
                                for (var x = 0; x <= w; x += 8) {
                                    var wy = baseY + Math.sin(x * wl.freq + t * wl.speed) * wl.amp;
                                    var crest = Math.sin(x * wl.freq + t * wl.speed);
                                    if (crest > 0.6) {
                                        var foamOp = (crest - 0.6) * wl.opacity * 2;
                                        ctx.beginPath();
                                        ctx.arc(x, wy, 2, 0, Math.PI * 2);
                                        ctx.fillStyle = 'rgba(220, 240, 255, ' + foamOp + ')';
                                        ctx.fill();
                                    }
                                }
                            }
                        }

                        // Sun reflection on water
                        var sunX = w * 0.65;
                        for (var i = 0; i < 15; i++) {
                            var refY = horizonY + 10 + i * 8;
                            var refW = 3 + i * 2;
                            var refOp = 0.06 - i * 0.003;
                            var refX = sunX + Math.sin(t * 0.8 + i * 0.5) * (5 + i * 2);
                            ctx.beginPath();
                            ctx.ellipse(refX, refY, refW, 1.5, 0, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 240, 200, ' + refOp + ')';
                            ctx.fill();
                        }

                        ctx.restore();

                        // Sun in the sky (not affected by rocking)
                        var sunGlow = ctx.createRadialGradient(w * 0.65, h * 0.18, 0, w * 0.65, h * 0.18, Math.min(w, h) * 0.15);
                        sunGlow.addColorStop(0, 'rgba(255, 248, 230, 0.2)');
                        sunGlow.addColorStop(0.3, 'rgba(255, 240, 200, 0.08)');
                        sunGlow.addColorStop(1, 'rgba(255, 230, 180, 0)');
                        ctx.beginPath();
                        ctx.arc(w * 0.65, h * 0.18, Math.min(w, h) * 0.15, 0, Math.PI * 2);
                        ctx.fillStyle = sunGlow;
                        ctx.fill();
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Seabirds gliding past
                        for (var i = 0; i < birds.length; i++) {
                            var b = birds[i];
                            var bx = ((b.x + t * b.speed) % 1.4 - 0.2) * w;
                            var by = b.y * h + Math.sin(t * 0.3 + i * 2) * 10;
                            var wing = Math.sin(t * b.wingSpeed + b.wingOffset) * 0.4;

                            ctx.save();
                            ctx.translate(bx, by);
                            ctx.strokeStyle = 'rgba(30, 30, 40, 0.12)';
                            ctx.lineWidth = 1.5;
                            ctx.lineCap = 'round';
                            // Left wing
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(-b.size * 0.5, -b.size * wing, -b.size, -b.size * wing * 0.5);
                            ctx.stroke();
                            // Right wing
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(b.size * 0.5, -b.size * wing, b.size, -b.size * wing * 0.5);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                };
            })();

            // --- Streaming theme ---
            // Flowing with a mountain stream, rocks scrolling past, foam and spray
            themes.streaming = {
                targetCount: 35,

                spawn: function (w, h) {
                    // Foam/spray particles
                    var isSpray = Math.random() < 0.3;
                    return {
                        x: Math.random() * w,
                        y: -10 - Math.random() * h * 0.2,
                        size: isSpray ? (1 + Math.random() * 2) : (0.5 + Math.random() * 1.5),
                        speed: 80 + Math.random() * 60,
                        drift: (Math.random() - 0.5) * 20,
                        opacity: isSpray ? (0.15 + Math.random() * 0.2) : (0.05 + Math.random() * 0.1),
                        isSpray: isSpray,
                        wobbleSpeed: 1 + Math.random() * 2,
                        wobbleOffset: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.y += p.speed * dt;
                    p.x += (p.drift + Math.sin(state.timeElapsed * p.wobbleSpeed + p.wobbleOffset) * 10) * dt;
                    if (p.y > h + 10) return false;
                    if (p.x < -5) p.x = w + 5;
                    if (p.x > w + 5) p.x = -5;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(230, 245, 255, ' + p.opacity + ')';
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Water base gradient (looking down at rushing water)
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#2a6878');
                    grad.addColorStop(0.3, '#287088');
                    grad.addColorStop(0.6, '#267898');
                    grad.addColorStop(1, '#2470a0');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Water flow lines scrolling downward (we're flowing with the stream)
                    var flowSpeed = 100;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(140, 200, 220, 0.04)';
                    ctx.lineWidth = 1;
                    for (var i = 0; i < 20; i++) {
                        var lx = w * (i / 20) + Math.sin(i * 3.7) * 20;
                        var scrollY = (t * flowSpeed) % h;
                        ctx.beginPath();
                        for (var y = -h; y <= h * 2; y += 4) {
                            var yy = (y + scrollY) % (h * 1.5) - h * 0.25;
                            var wx = lx + Math.sin(y * 0.01 + t * 0.5 + i * 2) * 10;
                            if (y === -h) ctx.moveTo(wx, yy);
                            else ctx.lineTo(wx, yy);
                        }
                        ctx.stroke();
                    }
                    ctx.restore();

                    // Sky reflection patches on smooth water
                    for (var i = 0; i < 8; i++) {
                        var rx = (Math.sin(i * 5.3 + t * 0.04) * 0.5 + 0.5) * w;
                        var ry = ((Math.sin(i * 3.7 + 0.8) * 0.5 + 0.5) * h + t * 40) % (h * 1.2) - h * 0.1;
                        var rSize = 20 + Math.sin(i * 2.1 + t * 0.2) * 10;
                        var rOp = 0.02 + Math.sin(t * 0.3 + i * 1.8) * 0.01;
                        ctx.beginPath();
                        ctx.ellipse(rx, ry, rSize, rSize * 0.4, 0, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(160, 210, 240, ' + rOp + ')';
                        ctx.fill();
                    }

                    // Rocks scrolling past (looking down at the streambed)
                    for (var i = 0; i < 12; i++) {
                        var rockX = (Math.sin(i * 6.7 + 0.9) * 0.5 + 0.5) * w;
                        var rockScroll = (t * 50 + i * h * 0.12) % (h * 1.3);
                        var rockY = rockScroll - h * 0.15;
                        var rockRx = 12 + Math.sin(i * 3.1) * 8;
                        var rockRy = 8 + Math.sin(i * 4.3) * 5;
                        var rockOp = 0.06 + Math.sin(i * 2.7) * 0.02;

                        ctx.beginPath();
                        ctx.ellipse(rockX, rockY, rockRx, rockRy, Math.sin(i * 1.9) * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(60, 80, 70, ' + rockOp + ')';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(80, 100, 90, ' + (rockOp * 0.5) + ')';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }

                    // Mossy bank edges scrolling past on left and right
                    var bankScroll = t * 40;
                    // Left bank
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    for (var y = 0; y <= h; y += 3) {
                        var bx = w * 0.08 + Math.sin((y + bankScroll) * 0.008 + 0.5) * 15 + Math.sin((y + bankScroll) * 0.02 + 2) * 5;
                        ctx.lineTo(bx, y);
                    }
                    ctx.lineTo(0, h);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(40, 70, 35, 0.25)';
                    ctx.fill();
                    // Right bank
                    ctx.beginPath();
                    ctx.moveTo(w, 0);
                    for (var y = 0; y <= h; y += 3) {
                        var bx = w * 0.92 + Math.sin((y + bankScroll * 1.1) * 0.008 + 3) * 15;
                        ctx.lineTo(bx, y);
                    }
                    ctx.lineTo(w, h);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(40, 70, 35, 0.2)';
                    ctx.fill();
                },

                drawForeground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // White foam patches where water hits rocks
                    for (var i = 0; i < 6; i++) {
                        var rockX = (Math.sin(i * 6.7 + 0.9) * 0.5 + 0.5) * w;
                        var rockScroll = (t * 50 + i * h * 0.12) % (h * 1.3);
                        var rockY = rockScroll - h * 0.15;
                        // Foam behind (downstream of) the rock
                        var foamY = rockY + 15;
                        for (var f = 0; f < 5; f++) {
                            var fx = rockX + (Math.random() - 0.5) * 20;
                            var fy = foamY + f * 4 + Math.sin(t * 3 + i + f) * 3;
                            ctx.beginPath();
                            ctx.arc(fx, fy, 1.5 + Math.sin(f * 2 + t) * 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(230, 250, 255, 0.06)';
                            ctx.fill();
                        }
                    }
                }
            };

            // --- Supernova theme ---
            // Star exploding with shockwave, ejected material, debris filaments
            themes.supernova = (function () {
                // Explosion cycle (repeats)
                var CYCLE_DURATION = 18;

                // Debris filaments
                var filaments = [];
                for (var i = 0; i < 20; i++) {
                    filaments.push({
                        angle: (i / 20) * Math.PI * 2 + (Math.random() - 0.5) * 0.3,
                        speed: 0.06 + Math.random() * 0.08,
                        length: 0.03 + Math.random() * 0.05,
                        width: 1 + Math.random() * 2,
                        hue: [0, 30, 200, 50, 340][i % 5]
                    });
                }

                return {
                    targetCount: 100,

                    spawn: function (w, h) {
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.3 + Math.random() * 1.5,
                            baseOpacity: 0.2 + Math.random() * 0.5,
                            twinkleSpeed: 0.5 + Math.random() * 2,
                            twinkleOffset: Math.random() * Math.PI * 2,
                            shakeAmp: Math.random() * 3
                        };
                    },

                    update: function (p, dt, w, h, state) { return true; },

                    draw: function (p, ctx, state) {
                        var t = state.timeElapsed;
                        var cycle = (t % CYCLE_DURATION) / CYCLE_DURATION;
                        var twinkle = Math.sin(t * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.baseOpacity * (0.4 + twinkle * 0.6);
                        // Stars shake during the shockwave
                        var shakeIntensity = cycle > 0.15 && cycle < 0.4 ? (1 - (cycle - 0.15) / 0.25) * 3 : 0;
                        var sx = p.x + Math.sin(t * 20 + p.twinkleOffset) * shakeIntensity * p.shakeAmp;
                        var sy = p.y + Math.cos(t * 18 + p.twinkleOffset * 2) * shakeIntensity * p.shakeAmp;
                        if (op < 0.04) return;
                        ctx.beginPath();
                        ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        // Dark space
                        ctx.fillStyle = '#020208';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        var cycle = (t % CYCLE_DURATION) / CYCLE_DURATION;
                        var cx = w * 0.5;
                        var cy = h * 0.5;
                        var minDim = Math.min(w, h);
                        var maxDim = Math.max(w, h);

                        // Phase 1: Star brightens (0-0.1)
                        if (cycle < 0.1) {
                            var brightPhase = cycle / 0.1;
                            var coreR = minDim * (0.01 + brightPhase * 0.03);
                            var coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR * 3);
                            coreGrad.addColorStop(0, 'rgba(255, 255, 250, ' + (0.3 + brightPhase * 0.6) + ')');
                            coreGrad.addColorStop(0.3, 'rgba(255, 240, 200, ' + (0.1 + brightPhase * 0.3) + ')');
                            coreGrad.addColorStop(1, 'rgba(255, 200, 150, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, coreR * 3, 0, Math.PI * 2);
                            ctx.fillStyle = coreGrad;
                            ctx.fill();
                        }

                        // Phase 2: Explosion (0.1-0.5) - shockwave expanding
                        if (cycle >= 0.1 && cycle < 0.5) {
                            var explPhase = (cycle - 0.1) / 0.4;
                            var blastR = explPhase * maxDim * 0.8;
                            var fadeOut = 1 - explPhase;

                            // White flash
                            if (explPhase < 0.15) {
                                var flashOp = (1 - explPhase / 0.15) * 0.4;
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + flashOp + ')';
                                ctx.fillRect(0, 0, w, h);
                            }

                            // Expanding bright core
                            var coreR = minDim * (0.03 + explPhase * 0.08) * fadeOut;
                            if (coreR > 1) {
                                var cGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
                                cGrad.addColorStop(0, 'rgba(255, 255, 250, ' + (fadeOut * 0.8) + ')');
                                cGrad.addColorStop(0.5, 'rgba(255, 220, 150, ' + (fadeOut * 0.3) + ')');
                                cGrad.addColorStop(1, 'rgba(255, 180, 80, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
                                ctx.fillStyle = cGrad;
                                ctx.fill();
                            }

                            // Shockwave ring
                            var ringWidth = 5 + explPhase * 15;
                            var ringOp = fadeOut * 0.3;
                            ctx.beginPath();
                            ctx.arc(cx, cy, blastR, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(150, 200, 255, ' + ringOp + ')';
                            ctx.lineWidth = ringWidth;
                            ctx.stroke();

                            // Ejected material layers
                            var layers = [
                                { r: 0.9, hue: 10, sat: 80, light: 50 },
                                { r: 0.7, hue: 220, sat: 60, light: 55 },
                                { r: 0.5, hue: 40, sat: 70, light: 50 }
                            ];
                            for (var l = 0; l < layers.length; l++) {
                                var lr = blastR * layers[l].r;
                                var lOp = fadeOut * 0.08;
                                var lGrad = ctx.createRadialGradient(cx, cy, lr * 0.5, cx, cy, lr);
                                lGrad.addColorStop(0, 'hsla(' + layers[l].hue + ', ' + layers[l].sat + '%, ' + layers[l].light + '%, 0)');
                                lGrad.addColorStop(0.7, 'hsla(' + layers[l].hue + ', ' + layers[l].sat + '%, ' + layers[l].light + '%, ' + lOp + ')');
                                lGrad.addColorStop(1, 'hsla(' + layers[l].hue + ', ' + layers[l].sat + '%, ' + layers[l].light + '%, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy, lr, 0, Math.PI * 2);
                                ctx.fillStyle = lGrad;
                                ctx.fill();
                            }

                            // Debris filaments stretching into space
                            for (var i = 0; i < filaments.length; i++) {
                                var f = filaments[i];
                                var fDist = blastR * f.speed * 10;
                                var fLen = minDim * f.length * explPhase;
                                var fx = cx + Math.cos(f.angle) * fDist;
                                var fy = cy + Math.sin(f.angle) * fDist;
                                var fEndX = fx + Math.cos(f.angle) * fLen;
                                var fEndY = fy + Math.sin(f.angle) * fLen;
                                var fOp = fadeOut * 0.15;
                                ctx.beginPath();
                                ctx.moveTo(fx, fy);
                                ctx.lineTo(fEndX, fEndY);
                                ctx.strokeStyle = 'hsla(' + f.hue + ', 70%, 60%, ' + fOp + ')';
                                ctx.lineWidth = f.width;
                                ctx.lineCap = 'round';
                                ctx.stroke();
                            }
                        }

                        // Phase 3: Aftermath glow / nebula remnant (0.5-1.0)
                        if (cycle >= 0.5) {
                            var afterPhase = (cycle - 0.5) / 0.5;
                            var remnantOp = (1 - afterPhase) * 0.06;
                            var remnantR = maxDim * (0.3 + afterPhase * 0.2);
                            if (remnantOp > 0.005) {
                                var rGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, remnantR);
                                rGrad.addColorStop(0, 'rgba(200, 100, 50, ' + remnantOp + ')');
                                rGrad.addColorStop(0.4, 'rgba(100, 60, 150, ' + (remnantOp * 0.6) + ')');
                                rGrad.addColorStop(1, 'rgba(50, 80, 180, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy, remnantR, 0, Math.PI * 2);
                                ctx.fillStyle = rGrad;
                                ctx.fill();
                            }
                        }
                    }
                };
            })();

            // --- Maelstrom theme ---
            // Massive ocean whirlpool with spiraling water, foam, debris
            themes.maelstrom = {
                targetCount: 60,

                spawn: function (w, h) {
                    // Foam and debris particles caught in the vortex
                    var angle = Math.random() * Math.PI * 2;
                    var dist = 0.15 + Math.random() * 0.35;
                    return {
                        angle: angle,
                        dist: dist,
                        size: 1 + Math.random() * 3,
                        orbitSpeed: 0.3 + (1 - dist) * 1.5,
                        inwardSpeed: 0.01 + Math.random() * 0.02,
                        opacity: 0.15 + Math.random() * 0.3,
                        isDebris: Math.random() < 0.2
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.angle += p.orbitSpeed * dt;
                    p.dist -= p.inwardSpeed * dt;
                    if (p.dist < 0.02) {
                        p.dist = 0.15 + Math.random() * 0.35;
                        p.angle = Math.random() * Math.PI * 2;
                    }
                    return true;
                },

                draw: function (p, ctx, state) {
                    var w = ctx.canvas.width;
                    var h = ctx.canvas.height;
                    var cx = w * 0.5;
                    var cy = h * 0.5;
                    var minDim = Math.min(w, h);
                    var px = cx + Math.cos(p.angle) * p.dist * minDim;
                    var py = cy + Math.sin(p.angle) * p.dist * minDim;
                    ctx.beginPath();
                    ctx.arc(px, py, p.size, 0, Math.PI * 2);
                    if (p.isDebris) {
                        ctx.fillStyle = 'rgba(100, 80, 50, ' + p.opacity + ')';
                    } else {
                        ctx.fillStyle = 'rgba(220, 240, 255, ' + p.opacity + ')';
                    }
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    var cx = w * 0.5;
                    var cy = h * 0.5;
                    var minDim = Math.min(w, h);

                    // Dark ocean base
                    var grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, minDim * 0.6);
                    grad.addColorStop(0, '#080c18');
                    grad.addColorStop(0.3, '#0c1828');
                    grad.addColorStop(0.6, '#142840');
                    grad.addColorStop(1, '#1a3858');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Concentric rotating wave rings
                    for (var r = 0; r < 12; r++) {
                        var ringDist = (r / 12) * minDim * 0.5;
                        var rotSpeed = 0.5 + (1 - r / 12) * 1.5;
                        ctx.beginPath();
                        for (var a = 0; a <= Math.PI * 2; a += 0.05) {
                            var wobble = Math.sin(a * 6 + t * rotSpeed + r * 0.8) * (5 + r * 2);
                            var px = cx + Math.cos(a + t * rotSpeed * 0.3) * (ringDist + wobble);
                            var py = cy + Math.sin(a + t * rotSpeed * 0.3) * (ringDist + wobble);
                            if (a === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.strokeStyle = 'rgba(80, 140, 180, ' + (0.03 + (1 - r / 12) * 0.04) + ')';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }

                    // Dark churning centre
                    var darkGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, minDim * 0.08);
                    darkGrad.addColorStop(0, 'rgba(0, 0, 5, 0.6)');
                    darkGrad.addColorStop(0.5, 'rgba(5, 10, 20, 0.3)');
                    darkGrad.addColorStop(1, 'rgba(10, 20, 40, 0)');
                    ctx.beginPath();
                    ctx.arc(cx, cy, minDim * 0.08, 0, Math.PI * 2);
                    ctx.fillStyle = darkGrad;
                    ctx.fill();

                    // Spiral arms of water
                    ctx.save();
                    ctx.translate(cx, cy);
                    for (var arm = 0; arm < 3; arm++) {
                        ctx.beginPath();
                        var armOffset = arm * Math.PI * 2 / 3;
                        for (var s = 0; s < 80; s++) {
                            var frac = s / 80;
                            var spiralAngle = armOffset + frac * Math.PI * 4 + t * 0.4;
                            var spiralR = frac * minDim * 0.45;
                            var sx = Math.cos(spiralAngle) * spiralR;
                            var sy = Math.sin(spiralAngle) * spiralR;
                            if (s === 0) ctx.moveTo(sx, sy);
                            else ctx.lineTo(sx, sy);
                        }
                        ctx.strokeStyle = 'rgba(60, 120, 160, 0.06)';
                        ctx.lineWidth = 3 + Math.sin(t + arm) * 1;
                        ctx.stroke();
                    }
                    ctx.restore();
                },

                drawForeground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    var cx = w * 0.5;
                    var cy = h * 0.5;
                    var minDim = Math.min(w, h);
                    // Spray particles flying outward from the vortex edge
                    for (var i = 0; i < 15; i++) {
                        var angle = t * 0.8 + i * Math.PI * 2 / 15;
                        var dist = minDim * (0.35 + Math.sin(t * 2 + i * 1.7) * 0.05);
                        var sprayDist = 10 + Math.sin(t * 3 + i * 2.3) * 8;
                        var sx = cx + Math.cos(angle) * (dist + sprayDist);
                        var sy = cy + Math.sin(angle) * (dist + sprayDist);
                        var sOp = 0.04 + Math.sin(t * 2 + i) * 0.02;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(200, 230, 255, ' + sOp + ')';
                        ctx.fill();
                    }
                }
            };

            // --- Earthquake theme ---
            // Ground splitting with cracks, shuddering terrain, dust, glowing fissures
            themes.earthquake = (function () {
                // Jolt state
                var joltTimer = 2 + Math.random() * 3;
                var joltIntensity = 0;
                var joltDecay = 3;

                // Crack configs
                var cracks = [];
                for (var i = 0; i < 12; i++) {
                    var segs = [];
                    var sx = (Math.sin(i * 5.3 + 0.7) * 0.5 + 0.5) * 0.8 + 0.1;
                    var sy = 0.45 + Math.sin(i * 3.1) * 0.08;
                    for (var s = 0; s < 6; s++) {
                        segs.push({
                            dx: (Math.random() - 0.5) * 0.06,
                            dy: 0.02 + Math.random() * 0.04
                        });
                        sx += segs[s].dx;
                        sy += segs[s].dy;
                    }
                    cracks.push({
                        startX: (Math.sin(i * 5.3 + 0.7) * 0.5 + 0.5) * 0.8 + 0.1,
                        startY: 0.45 + Math.sin(i * 3.1) * 0.08,
                        segments: segs,
                        width: 1 + Math.random() * 2,
                        glowWidth: 4 + Math.random() * 6,
                        speed: 0.5 + Math.random() * 1
                    });
                }

                return {
                    targetCount: 40,

                    spawn: function (w, h) {
                        // Dust and debris particles
                        return {
                            x: Math.random() * w,
                            y: h * (0.4 + Math.random() * 0.2),
                            vx: (Math.random() - 0.5) * 40,
                            vy: -(20 + Math.random() * 60),
                            size: 1 + Math.random() * 3,
                            opacity: 0.1 + Math.random() * 0.2,
                            gravity: 50 + Math.random() * 50,
                            life: 0,
                            maxLife: 2 + Math.random() * 3
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.life += dt;
                        if (p.life >= p.maxLife) return false;
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        p.vy += p.gravity * dt;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var fade = p.life > p.maxLife * 0.6 ? (1 - (p.life - p.maxLife * 0.6) / (p.maxLife * 0.4)) : 1;
                        var op = p.opacity * fade;
                        if (op < 0.02) return;
                        // Apply screen shake
                        var shakeX = Math.sin(state.timeElapsed * 25) * joltIntensity * 2;
                        var shakeY = Math.cos(state.timeElapsed * 22) * joltIntensity * 2;
                        ctx.beginPath();
                        ctx.arc(p.x + shakeX, p.y + shakeY, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(160, 130, 100, ' + op + ')';
                        ctx.fill();
                    },

                    onActivate: function () {
                        joltTimer = 1;
                        joltIntensity = 0;
                    },

                    drawBackground: function (ctx, w, h, state, dt) {
                        var t = state.timeElapsed;
                        var shakeX = Math.sin(t * 25) * joltIntensity * 4;
                        var shakeY = Math.cos(t * 22) * joltIntensity * 4;

                        ctx.save();
                        ctx.translate(shakeX, shakeY);

                        // Terrain gradient
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#4a5868');
                        grad.addColorStop(0.35, '#687868');
                        grad.addColorStop(0.5, '#586850');
                        grad.addColorStop(0.7, '#4a5838');
                        grad.addColorStop(1, '#3a4828');
                        ctx.fillStyle = grad;
                        ctx.fillRect(-10, -10, w + 20, h + 20);

                        // Ground crack fissures with orange glow
                        for (var i = 0; i < cracks.length; i++) {
                            var c = cracks[i];
                            var progress = Math.min(1, (t * c.speed * 0.3) % 2);
                            if (progress > 1) progress = 2 - progress;
                            var px = c.startX * w;
                            var py = c.startY * h;

                            // Glow underneath
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            for (var s = 0; s < c.segments.length * progress; s++) {
                                var seg = c.segments[Math.min(s, c.segments.length - 1)];
                                px += seg.dx * w;
                                py += seg.dy * h;
                                ctx.lineTo(px, py);
                            }
                            ctx.strokeStyle = 'rgba(255, 120, 20, 0.1)';
                            ctx.lineWidth = c.glowWidth + Math.sin(t * 2 + i) * 2;
                            ctx.lineCap = 'round';
                            ctx.stroke();

                            // Crack line
                            px = c.startX * w;
                            py = c.startY * h;
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            for (var s = 0; s < c.segments.length * progress; s++) {
                                var seg = c.segments[Math.min(s, c.segments.length - 1)];
                                px += seg.dx * w;
                                py += seg.dy * h;
                                ctx.lineTo(px, py);
                            }
                            ctx.strokeStyle = 'rgba(255, 180, 60, 0.2)';
                            ctx.lineWidth = c.width;
                            ctx.stroke();
                        }

                        // Dust clouds along the cracks
                        for (var i = 0; i < 20; i++) {
                            var dx = (Math.sin(i * 6.3 + t * 0.1) * 0.5 + 0.5) * w;
                            var dy = h * (0.45 + Math.sin(i * 3.7 + 0.4) * 0.15) - Math.sin(t * 0.5 + i) * 15;
                            var dOp = 0.02 + Math.sin(t * 0.4 + i * 2.1) * 0.01;
                            var dr = 15 + Math.sin(i * 2.3 + t * 0.3) * 8;
                            ctx.beginPath();
                            ctx.arc(dx, dy, dr, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(140, 120, 90, ' + dOp + ')';
                            ctx.fill();
                        }

                        ctx.restore();
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        // Periodic jolts
                        joltTimer -= dt;
                        if (joltTimer <= 0) {
                            joltIntensity = 0.5 + Math.random() * 0.5;
                            joltTimer = 2 + Math.random() * 4;
                        }
                        joltIntensity = Math.max(0, joltIntensity - joltDecay * dt);
                    }
                };
            })();

            // --- Erupting theme ---
            // Plinian volcanic eruption with ash column, pyroclastic flows, lava bombs, lightning
            themes.erupting = (function () {
                // Lava bomb state
                var lavaBombs = [];
                var bombTimer = 0.3;
                // Ash lightning
                var ashLightning = { active: false, opacity: 0, timer: 3 + Math.random() * 5 };

                return {
                    targetCount: 80,

                    spawn: function (w, h) {
                        // Ash/tephra raining down
                        return {
                            x: Math.random() * w,
                            y: -Math.random() * h * 0.2,
                            size: 0.5 + Math.random() * 2,
                            speed: 30 + Math.random() * 50,
                            drift: (Math.random() - 0.5) * 20,
                            opacity: 0.08 + Math.random() * 0.15
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.y += p.speed * dt;
                        p.x += p.drift * dt;
                        if (p.y > h + 5) return false;
                        return true;
                    },

                    draw: function (p, ctx) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(100, 80, 70, ' + p.opacity + ')';
                        ctx.fill();
                    },

                    onActivate: function () {
                        lavaBombs.length = 0;
                        bombTimer = 0.3;
                        ashLightning.active = false;
                        ashLightning.timer = 3 + Math.random() * 5;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark ominous sky
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#1a1210');
                        grad.addColorStop(0.3, '#2a1810');
                        grad.addColorStop(0.5, '#3a2015');
                        grad.addColorStop(0.7, '#4a2818');
                        grad.addColorStop(1, '#2a1510');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Red/orange underlighting from the eruption
                        var eruptGlow = ctx.createRadialGradient(w * 0.5, h * 0.7, 0, w * 0.5, h * 0.4, h * 0.6);
                        eruptGlow.addColorStop(0, 'rgba(255, 80, 10, 0.12)');
                        eruptGlow.addColorStop(0.4, 'rgba(200, 50, 5, 0.06)');
                        eruptGlow.addColorStop(1, 'rgba(100, 20, 0, 0)');
                        ctx.fillStyle = eruptGlow;
                        ctx.fillRect(0, 0, w, h);

                        // Volcano silhouette
                        var volcX = w * 0.5;
                        var volcBaseY = h * 0.85;
                        var volcTopY = h * 0.55;
                        ctx.beginPath();
                        ctx.moveTo(0, volcBaseY);
                        ctx.lineTo(volcX - w * 0.05, volcTopY);
                        ctx.lineTo(volcX + w * 0.05, volcTopY);
                        ctx.lineTo(w, volcBaseY);
                        ctx.lineTo(w, h);
                        ctx.lineTo(0, h);
                        ctx.closePath();
                        ctx.fillStyle = '#1a1008';
                        ctx.fill();

                        // Crater glow
                        var craterGlow = ctx.createRadialGradient(volcX, volcTopY, 0, volcX, volcTopY, w * 0.06);
                        craterGlow.addColorStop(0, 'rgba(255, 150, 30, 0.4)');
                        craterGlow.addColorStop(0.5, 'rgba(255, 80, 10, 0.15)');
                        craterGlow.addColorStop(1, 'rgba(200, 40, 0, 0)');
                        ctx.beginPath();
                        ctx.arc(volcX, volcTopY, w * 0.06, 0, Math.PI * 2);
                        ctx.fillStyle = craterGlow;
                        ctx.fill();

                        // Massive ash column billowing upward
                        for (var i = 0; i < 15; i++) {
                            var frac = i / 15;
                            var colY = volcTopY - frac * h * 0.5;
                            var spread = w * (0.03 + frac * 0.15);
                            var colX = volcX + Math.sin(t * 0.3 + frac * 5) * spread * 0.3;
                            var colR = spread * (0.6 + Math.sin(t * 0.5 + i * 1.3) * 0.2);
                            var colOp = 0.08 * (1 - frac * 0.5);
                            ctx.beginPath();
                            ctx.arc(colX, colY, colR, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(60, 50, 45, ' + colOp + ')';
                            ctx.fill();
                        }

                        // Pyroclastic flows racing down the sides
                        for (var side = -1; side <= 1; side += 2) {
                            var flowX = volcX + side * w * 0.04;
                            ctx.beginPath();
                            ctx.moveTo(flowX, volcTopY + h * 0.05);
                            for (var s = 0; s < 15; s++) {
                                var frac = s / 15;
                                var fx = flowX + side * frac * w * 0.2 + Math.sin(t * 0.8 + s * 2 + side) * 10;
                                var fy = volcTopY + h * 0.05 + frac * (volcBaseY - volcTopY);
                                ctx.lineTo(fx, fy);
                            }
                            ctx.strokeStyle = 'rgba(200, 80, 20, 0.08)';
                            ctx.lineWidth = 15 + Math.sin(t + side) * 5;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var volcX = w * 0.5;
                        var volcTopY = h * 0.55;

                        // Lava bombs arcing through the sky
                        bombTimer -= dt;
                        if (bombTimer <= 0) {
                            var angle = -Math.PI * 0.25 - Math.random() * Math.PI * 0.5;
                            var speed = 150 + Math.random() * 200;
                            lavaBombs.push({
                                x: volcX + (Math.random() - 0.5) * 20,
                                y: volcTopY,
                                vx: Math.cos(angle) * speed * (Math.random() < 0.5 ? 1 : -1),
                                vy: Math.sin(angle) * speed,
                                size: 2 + Math.random() * 4,
                                life: 0,
                                maxLife: 2 + Math.random() * 2
                            });
                            bombTimer = 0.1 + Math.random() * 0.4;
                        }
                        for (var i = lavaBombs.length - 1; i >= 0; i--) {
                            var lb = lavaBombs[i];
                            lb.life += dt;
                            if (lb.life >= lb.maxLife || lb.y > h + 10) {
                                lavaBombs.splice(i, 1);
                                continue;
                            }
                            lb.x += lb.vx * dt;
                            lb.y += lb.vy * dt;
                            lb.vy += 80 * dt;
                            var bOp = 0.6 * (1 - lb.life / lb.maxLife);
                            ctx.beginPath();
                            ctx.arc(lb.x, lb.y, lb.size, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 150, 20, ' + bOp + ')';
                            ctx.fill();
                            // Glow
                            ctx.beginPath();
                            ctx.arc(lb.x, lb.y, lb.size * 3, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 100, 10, ' + (bOp * 0.1) + ')';
                            ctx.fill();
                        }

                        // Lightning within the ash cloud
                        ashLightning.timer -= dt;
                        if (!ashLightning.active && ashLightning.timer <= 0) {
                            ashLightning.active = true;
                            ashLightning.opacity = 0.2 + Math.random() * 0.2;
                            ashLightning.timer = 2 + Math.random() * 4;
                        }
                        if (ashLightning.active) {
                            ctx.fillStyle = 'rgba(255, 220, 180, ' + ashLightning.opacity + ')';
                            ctx.fillRect(0, 0, w, h * 0.4);
                            ashLightning.opacity -= 3 * dt;
                            if (ashLightning.opacity <= 0) { ashLightning.active = false; }
                        }
                    }
                };
            })();

            // --- Tornado theme ---
            // Violent twister with rotating funnel, debris, dark clouds, lightning
            themes.tornado = (function () {
                // Debris particles orbiting the funnel
                var DEBRIS_COUNT = 50;
                var debris = [];
                var debrisInited = false;
                var lightningState = { active: false, opacity: 0, timer: 5 + Math.random() * 8 };

                function initDebris() {
                    debris.length = 0;
                    for (var i = 0; i < DEBRIS_COUNT; i++) {
                        debris.push({
                            angle: Math.random() * Math.PI * 2,
                            height: Math.random(),
                            dist: 0.3 + Math.random() * 0.7,
                            speed: 2 + Math.random() * 4,
                            size: 1 + Math.random() * 3,
                            opacity: 0.1 + Math.random() * 0.2
                        });
                    }
                    debrisInited = true;
                }

                return {
                    targetCount: 80,

                    spawn: function (w, h) {
                        // Rain particles
                        return {
                            x: Math.random() * w + w * 0.15,
                            y: -Math.random() * h * 0.2,
                            speed: 250 + Math.random() * 150,
                            windDrift: 80 + Math.random() * 60,
                            length: 10 + Math.random() * 15,
                            opacity: 0.08 + Math.random() * 0.12
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.y += p.speed * dt;
                        p.x -= p.windDrift * dt;
                        if (p.y > h + 20 || p.x < -20) return false;
                        return true;
                    },

                    draw: function (p, ctx) {
                        var angle = Math.atan2(p.speed, -p.windDrift);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + Math.cos(angle) * p.length, p.y + Math.sin(angle) * p.length);
                        ctx.strokeStyle = 'rgba(150, 160, 170, ' + p.opacity + ')';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    },

                    onActivate: function () {
                        initDebris();
                        lightningState.active = false;
                        lightningState.timer = 5 + Math.random() * 8;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark green-grey storm sky
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#1a2018');
                        grad.addColorStop(0.2, '#222820');
                        grad.addColorStop(0.4, '#2a3028');
                        grad.addColorStop(0.6, '#283028');
                        grad.addColorStop(1, '#1a2018');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Roiling cloud base
                        for (var i = 0; i < 8; i++) {
                            var cx = ((i * 0.14 + Math.sin(i * 3.7 + t * 0.03) * 0.04)) * w;
                            var cy = h * (0.08 + Math.sin(i * 2.3 + t * 0.05) * 0.03);
                            var cr = w * (0.12 + Math.sin(i * 4.1) * 0.04);
                            ctx.beginPath();
                            ctx.ellipse(cx, cy, cr, cr * 0.4, 0, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(20, 25, 18, 0.3)';
                            ctx.fill();
                        }
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        if (!debrisInited) initDebris();
                        var t = state.timeElapsed;

                        // Funnel cloud
                        var funnelTopX = w * (0.5 + Math.sin(t * 0.15) * 0.05);
                        var funnelTopY = h * 0.12;
                        var funnelBotX = w * (0.5 + Math.sin(t * 0.2 + 1) * 0.08);
                        var funnelBotY = h * 0.85;
                        var topWidth = w * 0.12;
                        var botWidth = w * 0.02;

                        // Draw funnel as tapered rotating shape
                        for (var seg = 0; seg < 30; seg++) {
                            var frac = seg / 30;
                            var fx = funnelTopX + (funnelBotX - funnelTopX) * frac;
                            var fy = funnelTopY + (funnelBotY - funnelTopY) * frac;
                            var fw = topWidth + (botWidth - topWidth) * frac;
                            var rotation = Math.sin(t * 2 + frac * 5) * fw * 0.3;
                            ctx.beginPath();
                            ctx.ellipse(fx + rotation, fy, fw, fw * 0.15, 0, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(30, 35, 28, ' + (0.04 + (1 - frac) * 0.03) + ')';
                            ctx.fill();
                        }

                        // Debris orbiting the funnel
                        for (var i = 0; i < debris.length; i++) {
                            var d = debris[i];
                            d.angle += d.speed * dt;
                            var frac = d.height;
                            var fx = funnelTopX + (funnelBotX - funnelTopX) * frac;
                            var fy = funnelTopY + (funnelBotY - funnelTopY) * frac;
                            var fw = (topWidth + (botWidth - topWidth) * frac) * d.dist;
                            var dx = fx + Math.cos(d.angle) * fw;
                            var dy = fy + Math.sin(d.angle) * fw * 0.2;
                            ctx.beginPath();
                            ctx.arc(dx, dy, d.size, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(80, 70, 50, ' + d.opacity + ')';
                            ctx.fill();
                        }

                        // Lightning
                        lightningState.timer -= dt;
                        if (!lightningState.active && lightningState.timer <= 0) {
                            lightningState.active = true;
                            lightningState.opacity = 0.25 + Math.random() * 0.2;
                            lightningState.timer = 4 + Math.random() * 8;
                        }
                        if (lightningState.active) {
                            ctx.fillStyle = 'rgba(200, 210, 220, ' + lightningState.opacity + ')';
                            ctx.fillRect(0, 0, w, h);
                            lightningState.opacity -= 3.5 * dt;
                            if (lightningState.opacity <= 0) { lightningState.active = false; }
                        }
                    }
                };
            })();

            // --- Avalanche theme ---
            // Wall of snow cascading down with powder cloud and swept debris
            themes.avalanche = {
                targetCount: 100,

                spawn: function (w, h) {
                    // Snow chunks tumbling
                    return {
                        x: Math.random() * w,
                        y: -10 - Math.random() * h * 0.3,
                        size: 2 + Math.random() * 8,
                        speed: 120 + Math.random() * 180,
                        drift: (Math.random() - 0.5) * 40,
                        opacity: 0.15 + Math.random() * 0.3,
                        rotation: Math.random() * Math.PI * 2,
                        rotSpeed: (Math.random() - 0.5) * 5,
                        bounce: Math.random() * Math.PI * 2
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.y += p.speed * dt;
                    p.x += (p.drift + Math.sin(state.timeElapsed * 2 + p.bounce) * 15) * dt;
                    p.rotation += p.rotSpeed * dt;
                    if (p.y > h + p.size * 2) return false;
                    return true;
                },

                draw: function (p, ctx) {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.beginPath();
                    // Irregular chunk shape
                    ctx.moveTo(-p.size * 0.5, -p.size * 0.3);
                    ctx.lineTo(p.size * 0.4, -p.size * 0.5);
                    ctx.lineTo(p.size * 0.5, p.size * 0.2);
                    ctx.lineTo(-p.size * 0.2, p.size * 0.5);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(235, 240, 250, ' + p.opacity + ')';
                    ctx.fill();
                    ctx.restore();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Mountain backdrop
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#7088a0');
                    grad.addColorStop(0.3, '#8898a8');
                    grad.addColorStop(0.5, '#a0b0c0');
                    grad.addColorStop(1, '#c0ccd8');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Mountain silhouettes
                    ctx.beginPath();
                    ctx.moveTo(0, h * 0.5);
                    ctx.lineTo(w * 0.15, h * 0.2);
                    ctx.lineTo(w * 0.3, h * 0.35);
                    ctx.lineTo(w * 0.5, h * 0.1);
                    ctx.lineTo(w * 0.7, h * 0.3);
                    ctx.lineTo(w * 0.85, h * 0.15);
                    ctx.lineTo(w, h * 0.4);
                    ctx.lineTo(w, h);
                    ctx.lineTo(0, h);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(60, 70, 80, 0.15)';
                    ctx.fill();

                    // Powder cloud billowing ahead of the main mass
                    for (var i = 0; i < 10; i++) {
                        var pcY = h * (0.2 + i * 0.06) + Math.sin(t * 0.8 + i * 2) * 15;
                        var pcX = w * (0.3 + Math.sin(i * 3.7 + t * 0.2) * 0.2);
                        var pcR = 40 + Math.sin(i * 2.1 + t * 0.5) * 20;
                        var pcOp = 0.04 + Math.sin(t * 0.3 + i) * 0.02;
                        ctx.beginPath();
                        ctx.arc(pcX, pcY, pcR, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(220, 230, 245, ' + pcOp + ')';
                        ctx.fill();
                    }

                    // Dense white wall rolling down
                    var wallY = ((t * 60) % (h * 1.5)) - h * 0.2;
                    var wallGrad = ctx.createLinearGradient(0, wallY - h * 0.15, 0, wallY + h * 0.2);
                    wallGrad.addColorStop(0, 'rgba(230, 240, 250, 0)');
                    wallGrad.addColorStop(0.3, 'rgba(230, 240, 250, 0.06)');
                    wallGrad.addColorStop(0.5, 'rgba(240, 245, 255, 0.1)');
                    wallGrad.addColorStop(0.7, 'rgba(230, 240, 250, 0.06)');
                    wallGrad.addColorStop(1, 'rgba(220, 235, 248, 0)');
                    ctx.fillStyle = wallGrad;
                    ctx.fillRect(0, wallY - h * 0.15, w, h * 0.35);
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Meteor theme ---
            // Asteroid impact with fireball streak, expanding dome of light, shockwave, debris
            themes.meteor = (function () {
                var CYCLE = 14;

                return {
                    targetCount: 60,

                    spawn: function (w, h) {
                        return {
                            x: Math.random() * w,
                            y: Math.random() * h,
                            size: 0.3 + Math.random() * 1.2,
                            baseOpacity: 0.2 + Math.random() * 0.5,
                            twinkleSpeed: 0.5 + Math.random() * 2,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                    },

                    update: function (p, dt, w, h, state) { return true; },

                    draw: function (p, ctx, state) {
                        var twinkle = Math.sin(state.timeElapsed * p.twinkleSpeed + p.twinkleOffset);
                        var op = p.baseOpacity * (0.4 + twinkle * 0.6);
                        if (op < 0.04) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        ctx.fillStyle = '#040310';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        var cycle = (t % CYCLE) / CYCLE;
                        var maxDim = Math.max(w, h);

                        // Phase 1: Fireball streaks across (0-0.2)
                        if (cycle < 0.2) {
                            var streakPhase = cycle / 0.2;
                            var startX = w * 0.9;
                            var startY = h * 0.05;
                            var endX = w * 0.35;
                            var endY = h * 0.65;
                            var fx = startX + (endX - startX) * streakPhase;
                            var fy = startY + (endY - startY) * streakPhase;
                            var trailLen = Math.min(streakPhase, 0.5) * maxDim * 0.3;
                            var dx = (endX - startX);
                            var dy = (endY - startY);
                            var dist = Math.sqrt(dx * dx + dy * dy);
                            var nx = -dx / dist;
                            var ny = -dy / dist;

                            // Trail
                            var trGrad = ctx.createLinearGradient(fx, fy, fx + nx * trailLen, fy + ny * trailLen);
                            trGrad.addColorStop(0, 'rgba(255, 200, 50, 0.4)');
                            trGrad.addColorStop(0.3, 'rgba(255, 120, 20, 0.15)');
                            trGrad.addColorStop(1, 'rgba(200, 60, 10, 0)');
                            ctx.beginPath();
                            ctx.moveTo(fx - ny * 8, fy + nx * 8);
                            ctx.lineTo(fx + ny * 8, fy - nx * 8);
                            ctx.lineTo(fx + nx * trailLen, fy + ny * trailLen);
                            ctx.closePath();
                            ctx.fillStyle = trGrad;
                            ctx.fill();

                            // Fireball head
                            var fbGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, 20);
                            fbGrad.addColorStop(0, 'rgba(255, 255, 240, 0.8)');
                            fbGrad.addColorStop(0.3, 'rgba(255, 200, 80, 0.4)');
                            fbGrad.addColorStop(1, 'rgba(255, 120, 20, 0)');
                            ctx.beginPath();
                            ctx.arc(fx, fy, 20, 0, Math.PI * 2);
                            ctx.fillStyle = fbGrad;
                            ctx.fill();
                        }

                        // Phase 2: Impact (0.2-0.6)
                        if (cycle >= 0.2 && cycle < 0.6) {
                            var impPhase = (cycle - 0.2) / 0.4;
                            var impX = w * 0.35;
                            var impY = h * 0.65;
                            var fadeOut = 1 - impPhase;

                            // Flash
                            if (impPhase < 0.1) {
                                ctx.fillStyle = 'rgba(255, 240, 200, ' + ((1 - impPhase / 0.1) * 0.5) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }

                            // Expanding dome of light
                            var domeR = impPhase * maxDim * 0.6;
                            var domeGrad = ctx.createRadialGradient(impX, impY, domeR * 0.8, impX, impY, domeR);
                            domeGrad.addColorStop(0, 'rgba(255, 200, 100, 0)');
                            domeGrad.addColorStop(0.8, 'rgba(255, 180, 60, ' + (fadeOut * 0.08) + ')');
                            domeGrad.addColorStop(1, 'rgba(255, 150, 30, 0)');
                            ctx.beginPath();
                            ctx.arc(impX, impY, domeR, 0, Math.PI * 2);
                            ctx.fillStyle = domeGrad;
                            ctx.fill();

                            // Shockwave ring
                            ctx.beginPath();
                            ctx.arc(impX, impY, domeR, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(255, 220, 180, ' + (fadeOut * 0.2) + ')';
                            ctx.lineWidth = 3 + impPhase * 10;
                            ctx.stroke();

                            // Ejecta arcing in all directions
                            for (var i = 0; i < 20; i++) {
                                var eAngle = (i / 20) * Math.PI * 2 + Math.sin(i * 3.7) * 0.3;
                                var eSpeed = 0.3 + Math.sin(i * 2.3) * 0.15;
                                var eDist = impPhase * maxDim * eSpeed;
                                var eGravity = eDist * 0.1;
                                var ex = impX + Math.cos(eAngle) * eDist;
                                var ey = impY + Math.sin(eAngle) * eDist + eGravity;
                                var eOp = fadeOut * 0.2;
                                ctx.beginPath();
                                ctx.arc(ex, ey, 2 + Math.sin(i) * 1, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(255, 180, 60, ' + eOp + ')';
                                ctx.fill();
                            }
                        }

                        // Phase 3: Sky turns orange, debris rain (0.6-1.0)
                        if (cycle >= 0.6) {
                            var afterPhase = (cycle - 0.6) / 0.4;
                            var skyOp = (1 - afterPhase) * 0.05;
                            ctx.fillStyle = 'rgba(200, 100, 30, ' + skyOp + ')';
                            ctx.fillRect(0, 0, w, h);
                        }
                    }
                };
            })();

            // --- Tsunami theme ---
            // Towering wave rising and curling with foam, spray, darkened sky
            themes.tsunami = {
                targetCount: 40,

                spawn: function (w, h) {
                    // Spray particles
                    return {
                        x: Math.random() * w,
                        y: h * (0.2 + Math.random() * 0.4),
                        size: 1 + Math.random() * 3,
                        vx: (Math.random() - 0.5) * 30,
                        vy: -(10 + Math.random() * 30),
                        opacity: 0.1 + Math.random() * 0.15,
                        gravity: 20 + Math.random() * 20,
                        life: 0,
                        maxLife: 2 + Math.random() * 3
                    };
                },

                update: function (p, dt, w, h, state) {
                    p.life += dt;
                    if (p.life >= p.maxLife) return false;
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.vy += p.gravity * dt;
                    return true;
                },

                draw: function (p, ctx) {
                    var fade = p.life > p.maxLife * 0.5 ? (1 - (p.life - p.maxLife * 0.5) / (p.maxLife * 0.5)) : 1;
                    var op = p.opacity * fade;
                    if (op < 0.02) return;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(200, 230, 255, ' + op + ')';
                    ctx.fill();
                },

                drawBackground: function (ctx, w, h, state) {
                    var t = state.timeElapsed;
                    // Dark storm sky
                    var grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#18202a');
                    grad.addColorStop(0.25, '#202830');
                    grad.addColorStop(0.4, '#283038');
                    grad.addColorStop(0.5, '#1a4060');
                    grad.addColorStop(0.7, '#184870');
                    grad.addColorStop(1, '#103858');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);

                    // Towering wave wall - cycles between building and cresting
                    var waveCycle = (t * 0.08) % 1;
                    var waveHeight = h * (0.4 + waveCycle * 0.2);
                    var waveTopY = h - waveHeight;

                    // Wave body
                    ctx.beginPath();
                    ctx.moveTo(0, h);
                    for (var x = 0; x <= w; x += 3) {
                        var wy = waveTopY
                            + Math.sin(x * 0.004 + t * 0.3) * 20
                            + Math.sin(x * 0.01 + t * 0.5) * 10
                            + Math.pow(Math.sin(x * 0.002 + t * 0.15), 2) * 30;
                        ctx.lineTo(x, wy);
                    }
                    ctx.lineTo(w, h);
                    ctx.closePath();
                    var waveGrad = ctx.createLinearGradient(0, waveTopY, 0, h);
                    waveGrad.addColorStop(0, 'rgba(20, 60, 100, 0.5)');
                    waveGrad.addColorStop(0.3, 'rgba(15, 50, 85, 0.4)');
                    waveGrad.addColorStop(1, 'rgba(10, 40, 70, 0.3)');
                    ctx.fillStyle = waveGrad;
                    ctx.fill();

                    // Curling crest (breaking wave lip)
                    var crestY = waveTopY - 10;
                    ctx.beginPath();
                    for (var x = 0; x <= w; x += 3) {
                        var cy = crestY + Math.sin(x * 0.004 + t * 0.3) * 20 + Math.sin(x * 0.01 + t * 0.5) * 10;
                        var curl = Math.sin(x * 0.003 + t * 0.2) * 15;
                        if (x === 0) ctx.moveTo(x, cy);
                        else ctx.lineTo(x, cy + curl);
                    }
                    ctx.strokeStyle = 'rgba(200, 230, 255, 0.15)';
                    ctx.lineWidth = 4;
                    ctx.stroke();

                    // Foam on the crest
                    for (var i = 0; i < 30; i++) {
                        var fx = (Math.sin(i * 5.7 + t * 0.5) * 0.5 + 0.5) * w;
                        var fy = crestY + Math.sin(fx * 0.004 + t * 0.3) * 20 + Math.sin(i * 3.1 + t) * 8;
                        var fSize = 2 + Math.sin(i * 2.3) * 1.5;
                        ctx.beginPath();
                        ctx.arc(fx, fy, fSize, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(230, 245, 255, 0.08)';
                        ctx.fill();
                    }
                },

                drawForeground: function (ctx, w, h, state) {}
            };

            // --- Bolts theme ---
            // Violent electrical storm with branching lightning, rain, screen shake
            themes.bolts = (function () {
                var bolts = [];
                var boltTimer = 0.5 + Math.random() * 1;
                var screenShake = 0;

                function createBolt(w, h) {
                    var startX = w * (0.1 + Math.random() * 0.8);
                    var segments = [];
                    var x = startX;
                    var y = 0;
                    var segCount = 8 + Math.floor(Math.random() * 8);
                    for (var s = 0; s < segCount; s++) {
                        var nx = x + (Math.random() - 0.5) * 80;
                        var ny = y + (h / segCount) * (0.8 + Math.random() * 0.4);
                        segments.push({ x1: x, y1: y, x2: nx, y2: ny });
                        // Branches
                        if (Math.random() < 0.3) {
                            var bx = nx + (Math.random() - 0.5) * 60;
                            var by = ny + h / segCount * (0.3 + Math.random() * 0.4);
                            segments.push({ x1: nx, y1: ny, x2: bx, y2: by, branch: true });
                        }
                        x = nx;
                        y = ny;
                    }
                    return { segments: segments, life: 0, maxLife: 0.15 + Math.random() * 0.15 };
                }

                return {
                    targetCount: 120,

                    spawn: function (w, h) {
                        return {
                            x: Math.random() * w + w * 0.1,
                            y: -Math.random() * h * 0.2,
                            speed: 350 + Math.random() * 200,
                            windDrift: 40 + Math.random() * 40,
                            length: 8 + Math.random() * 12,
                            opacity: 0.1 + Math.random() * 0.2
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.y += p.speed * dt;
                        p.x -= p.windDrift * dt;
                        if (p.y > h + 20 || p.x < -20) return false;
                        return true;
                    },

                    draw: function (p, ctx) {
                        var angle = Math.atan2(p.speed, -p.windDrift);
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + Math.cos(angle) * p.length, p.y + Math.sin(angle) * p.length);
                        ctx.strokeStyle = 'rgba(180, 195, 210, ' + p.opacity + ')';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    },

                    onActivate: function () {
                        bolts.length = 0;
                        boltTimer = 0.5 + Math.random() * 1;
                        screenShake = 0;
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        var shX = Math.sin(t * 30) * screenShake * 3;
                        var shY = Math.cos(t * 27) * screenShake * 3;
                        ctx.save();
                        ctx.translate(shX, shY);
                        // Very dark purple-grey sky
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#100c18');
                        grad.addColorStop(0.3, '#18142a');
                        grad.addColorStop(0.6, '#1a1830');
                        grad.addColorStop(1, '#141020');
                        ctx.fillStyle = grad;
                        ctx.fillRect(-10, -10, w + 20, h + 20);
                        // Heavy clouds
                        for (var i = 0; i < 6; i++) {
                            var cx = (i * 0.18 + Math.sin(i * 3.1 + t * 0.02) * 0.03) * w;
                            var cy = h * (0.05 + Math.sin(i * 2.7) * 0.03);
                            var cr = w * (0.14 + Math.sin(i * 4.3) * 0.04);
                            ctx.beginPath();
                            ctx.ellipse(cx, cy, cr, cr * 0.35, 0, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(18, 15, 28, 0.4)';
                            ctx.fill();
                        }
                        ctx.restore();
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;

                        // Spawn bolts
                        boltTimer -= dt;
                        if (boltTimer <= 0) {
                            bolts.push(createBolt(w, h));
                            screenShake = 0.8;
                            boltTimer = 0.3 + Math.random() * 1.5;
                            // Sometimes double-strike
                            if (Math.random() < 0.3) {
                                bolts.push(createBolt(w, h));
                            }
                        }

                        screenShake = Math.max(0, screenShake - 2 * dt);

                        // Draw bolts
                        for (var b = bolts.length - 1; b >= 0; b--) {
                            var bolt = bolts[b];
                            bolt.life += dt;
                            if (bolt.life >= bolt.maxLife) {
                                bolts.splice(b, 1);
                                continue;
                            }
                            var bFade = 1 - bolt.life / bolt.maxLife;

                            // Screen flash
                            if (bolt.life < 0.05) {
                                ctx.fillStyle = 'rgba(200, 210, 255, ' + (bFade * 0.15) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }

                            for (var s = 0; s < bolt.segments.length; s++) {
                                var seg = bolt.segments[s];
                                var isBranch = seg.branch;
                                // Bright core
                                ctx.beginPath();
                                ctx.moveTo(seg.x1, seg.y1);
                                ctx.lineTo(seg.x2, seg.y2);
                                ctx.strokeStyle = 'rgba(220, 230, 255, ' + (bFade * (isBranch ? 0.4 : 0.7)) + ')';
                                ctx.lineWidth = isBranch ? 1 : 2.5;
                                ctx.lineCap = 'round';
                                ctx.stroke();
                                // Purple glow
                                ctx.beginPath();
                                ctx.moveTo(seg.x1, seg.y1);
                                ctx.lineTo(seg.x2, seg.y2);
                                ctx.strokeStyle = 'rgba(150, 120, 255, ' + (bFade * (isBranch ? 0.1 : 0.2)) + ')';
                                ctx.lineWidth = isBranch ? 4 : 8;
                                ctx.stroke();
                            }
                        }
                    }
                };
            })();

            // --- Solar Flare theme ---
            // Massive coronal mass ejection with plasma arcs, roiling surface, particle streams
            themes.solarflare = (function () {
                // Plasma arc configs
                var arcs = [];
                for (var i = 0; i < 6; i++) {
                    arcs.push({
                        angle: (Math.sin(i * 4.3 + 0.7) * 0.5 + 0.5) * Math.PI - Math.PI * 0.5,
                        height: 0.15 + (Math.sin(i * 2.9) * 0.5 + 0.5) * 0.2,
                        width: 0.05 + (Math.sin(i * 3.7) * 0.5 + 0.5) * 0.08,
                        speed: 0.3 + Math.sin(i * 5.1) * 0.15,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                return {
                    targetCount: 50,

                    spawn: function (w, h) {
                        // Particle streams blasting outward
                        var angle = -Math.PI * 0.15 - Math.random() * Math.PI * 0.7;
                        var speed = 50 + Math.random() * 100;
                        return {
                            x: w * 0.5 + (Math.random() - 0.5) * w * 0.1,
                            y: h * 0.75,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: 0.5 + Math.random() * 2,
                            opacity: 0.15 + Math.random() * 0.25,
                            life: 0,
                            maxLife: 2 + Math.random() * 4
                        };
                    },

                    update: function (p, dt, w, h, state) {
                        p.life += dt;
                        if (p.life >= p.maxLife) return false;
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        return true;
                    },

                    draw: function (p, ctx, state) {
                        var fade = p.life > p.maxLife * 0.5 ? (1 - (p.life - p.maxLife * 0.5) / (p.maxLife * 0.5)) : 1;
                        var op = p.opacity * fade;
                        if (op < 0.02) return;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 200, 80, ' + op + ')';
                        ctx.fill();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        var t = state.timeElapsed;
                        // Dark space above, sun surface below
                        var grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, '#0a0408');
                        grad.addColorStop(0.4, '#1a0808');
                        grad.addColorStop(0.6, '#802800');
                        grad.addColorStop(0.75, '#c04800');
                        grad.addColorStop(0.85, '#e06800');
                        grad.addColorStop(1, '#ff8800');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, w, h);

                        // Convection cells on the sun's surface
                        var surfaceY = h * 0.7;
                        for (var i = 0; i < 25; i++) {
                            var cx = (Math.sin(i * 5.3 + t * 0.02 + 0.7) * 0.5 + 0.5) * w;
                            var cy = surfaceY + (Math.sin(i * 3.1 + 0.4) * 0.5 + 0.5) * h * 0.25;
                            var cr = 15 + Math.sin(i * 2.7 + t * 0.3) * 8;
                            var cOp = 0.04 + Math.sin(t * 0.5 + i * 1.3) * 0.02;
                            ctx.beginPath();
                            ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(255, 180, 50, ' + cOp + ')';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }

                        // Bright eruption point
                        var eruptX = w * 0.5;
                        var eruptY = h * 0.72;
                        var pulse = Math.sin(t * 1.5) * 0.03;
                        var eGrad = ctx.createRadialGradient(eruptX, eruptY, 0, eruptX, eruptY, w * 0.08);
                        eGrad.addColorStop(0, 'rgba(255, 255, 230, ' + (0.4 + pulse) + ')');
                        eGrad.addColorStop(0.3, 'rgba(255, 220, 120, ' + (0.2 + pulse) + ')');
                        eGrad.addColorStop(1, 'rgba(255, 150, 50, 0)');
                        ctx.beginPath();
                        ctx.arc(eruptX, eruptY, w * 0.08, 0, Math.PI * 2);
                        ctx.fillStyle = eGrad;
                        ctx.fill();

                        // Plasma arcs looping outward along magnetic field lines
                        for (var i = 0; i < arcs.length; i++) {
                            var arc = arcs[i];
                            var animPhase = Math.sin(t * arc.speed + arc.phase);
                            var arcH = arc.height * h * (0.7 + animPhase * 0.3);
                            var arcW = arc.width * w;
                            var arcAngle = arc.angle + Math.sin(t * 0.1 + i * 2) * 0.1;

                            ctx.save();
                            ctx.translate(eruptX, eruptY);
                            ctx.rotate(arcAngle);

                            // Draw arc as a curved line
                            ctx.beginPath();
                            for (var s = 0; s <= 20; s++) {
                                var frac = s / 20;
                                var ax = (frac - 0.5) * arcW * 2;
                                var ay = -Math.sin(frac * Math.PI) * arcH;
                                if (s === 0) ctx.moveTo(ax, ay);
                                else ctx.lineTo(ax, ay);
                            }
                            var arcOp = 0.1 + animPhase * 0.05;
                            ctx.strokeStyle = 'rgba(255, 180, 60, ' + arcOp + ')';
                            ctx.lineWidth = 3 + animPhase * 2;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                            // Hot core of arc
                            ctx.strokeStyle = 'rgba(255, 240, 180, ' + (arcOp * 0.5) + ')';
                            ctx.lineWidth = 1;
                            ctx.stroke();

                            ctx.restore();
                        }

                        // Coronal glow above the surface
                        var coronaGrad = ctx.createLinearGradient(0, h * 0.5, 0, h * 0.75);
                        coronaGrad.addColorStop(0, 'rgba(255, 150, 50, 0)');
                        coronaGrad.addColorStop(0.5, 'rgba(255, 120, 30, 0.03)');
                        coronaGrad.addColorStop(1, 'rgba(255, 100, 20, 0.06)');
                        ctx.fillStyle = coronaGrad;
                        ctx.fillRect(0, h * 0.5, w, h * 0.25);
                    },

                    drawForeground: function (ctx, w, h, state) {}
                };
            })();

            // --- Voyager theme ---
            // Epic interplanetary journey: surface  launch  space  hyperspace  decelerate  planet approach  descent  surface (loops)
            themes.voyager = (function () {
                // Phase durations (seconds)
                var PHASES = [
                    { name: 'surface', duration: 6 },
                    { name: 'ascent', duration: 8 },
                    { name: 'space', duration: 5 },
                    { name: 'hyperEntry', duration: 3 },
                    { name: 'hyperspace', duration: 7 },
                    { name: 'decelerate', duration: 5 },
                    { name: 'arrival', duration: 4 },
                    { name: 'descent', duration: 8 }
                ];
                var TOTAL_CYCLE = 0;
                for (var i = 0; i < PHASES.length; i++) TOTAL_CYCLE += PHASES[i].duration;

                // Starfield
                var STAR_COUNT = 300;
                var stars = [];

                // Origin planet colours (reds/oranges  Mars-like)
                var originSky = ['#c46030', '#a04020', '#601810'];
                var originGround = ['#8b4513', '#6b3410', '#4a2008'];
                // Destination planet colours (blues/greens  Earth-like)
                var destSky = ['#4080c0', '#2060a0', '#102040'];
                var destGround = ['#2a6040', '#1a4a30', '#0a2a18'];

                // Terrain mountains (procedural, seeded)
                var originMountains = [];
                var destMountains = [];
                for (var i = 0; i < 30; i++) {
                    originMountains.push({
                        x: i / 30,
                        h: 0.08 + (Math.sin(i * 3.7 + 0.5) * 0.5 + 0.5) * 0.18,
                        w: 0.04 + (Math.sin(i * 5.3) * 0.5 + 0.5) * 0.06
                    });
                    destMountains.push({
                        x: i / 30,
                        h: 0.06 + (Math.sin(i * 4.1 + 2.3) * 0.5 + 0.5) * 0.14,
                        w: 0.05 + (Math.sin(i * 6.7 + 1.1) * 0.5 + 0.5) * 0.05
                    });
                }

                function initStars() {
                    stars.length = 0;
                    for (var i = 0; i < STAR_COUNT; i++) {
                        stars.push({
                            x: (Math.random() - 0.5) * 2,
                            y: (Math.random() - 0.5) * 2,
                            z: Math.random() * 3,
                            prevSx: 0, prevSy: 0,
                            hasPrev: false,
                            hue: Math.random() < 0.1 ? (180 + Math.random() * 60) : 0,
                            bright: 0.3 + Math.random() * 0.7
                        });
                    }
                }

                function getPhaseInfo(t) {
                    var cycleT = t % TOTAL_CYCLE;
                    var elapsed = 0;
                    for (var i = 0; i < PHASES.length; i++) {
                        if (cycleT < elapsed + PHASES[i].duration) {
                            return {
                                index: i,
                                name: PHASES[i].name,
                                progress: (cycleT - elapsed) / PHASES[i].duration,
                                phaseTime: cycleT - elapsed
                            };
                        }
                        elapsed += PHASES[i].duration;
                    }
                    return { index: 0, name: 'surface', progress: 0, phaseTime: 0 };
                }

                function smoothstep(a, b, t) {
                    t = Math.max(0, Math.min(1, (t - a) / (b - a)));
                    return t * t * (3 - 2 * t);
                }

                function lerpColor(c1, c2, t) {
                    // Parse hex colours and lerp
                    var r1 = parseInt(c1.substr(1, 2), 16), g1 = parseInt(c1.substr(3, 2), 16), b1 = parseInt(c1.substr(5, 2), 16);
                    var r2 = parseInt(c2.substr(1, 2), 16), g2 = parseInt(c2.substr(3, 2), 16), b2 = parseInt(c2.substr(5, 2), 16);
                    var r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
                    return 'rgb(' + r + ',' + g + ',' + b + ')';
                }

                function drawTerrain(ctx, w, h, mountains, groundColors, skyHorizonColor, scrollOffset, heightScale) {
                    // Mountain silhouettes
                    ctx.beginPath();
                    ctx.moveTo(0, h);
                    for (var i = 0; i < mountains.length; i++) {
                        var m = mountains[i];
                        var mx = ((m.x + scrollOffset * 0.01) % 1.2 - 0.1) * w;
                        var mh = m.h * h * heightScale;
                        ctx.lineTo(mx - m.w * w, h);
                        ctx.lineTo(mx, h - mh);
                        ctx.lineTo(mx + m.w * w, h);
                    }
                    ctx.lineTo(w, h);
                    ctx.closePath();
                    ctx.fillStyle = groundColors[0];
                    ctx.fill();

                    // Ground base
                    ctx.fillStyle = groundColors[1];
                    ctx.fillRect(0, h * 0.92, w, h * 0.08);

                    // Horizon glow
                    var hGrad = ctx.createLinearGradient(0, h * 0.7, 0, h * 0.85);
                    hGrad.addColorStop(0, 'rgba(0,0,0,0)');
                    hGrad.addColorStop(1, skyHorizonColor);
                    ctx.fillStyle = hGrad;
                    ctx.fillRect(0, h * 0.7, w, h * 0.15);
                }

                function drawPlanetSphere(ctx, cx, cy, radius, colors) {
                    // Planet disc with atmosphere
                    var pGrad = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.1, cx, cy, radius);
                    pGrad.addColorStop(0, colors[0]);
                    pGrad.addColorStop(0.6, colors[1]);
                    pGrad.addColorStop(1, colors[2]);
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.fillStyle = pGrad;
                    ctx.fill();

                    // Atmosphere rim
                    var aGrad = ctx.createRadialGradient(cx, cy, radius * 0.85, cx, cy, radius * 1.15);
                    aGrad.addColorStop(0, 'rgba(150, 200, 255, 0)');
                    aGrad.addColorStop(0.5, 'rgba(150, 200, 255, 0.08)');
                    aGrad.addColorStop(1, 'rgba(150, 200, 255, 0)');
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius * 1.15, 0, Math.PI * 2);
                    ctx.fillStyle = aGrad;
                    ctx.fill();
                }

                return {
                    targetCount: 0,

                    spawn: function (w, h) { return { x: 0, y: 0 }; },
                    update: function (p, dt, w, h, state) { return true; },
                    draw: function (p, ctx, state) {},

                    onActivate: function () {
                        initStars();
                    },

                    drawBackground: function (ctx, w, h, state) {
                        ctx.fillStyle = '#020206';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        if (stars.length === 0) initStars();
                        var t = state.timeElapsed;
                        var phase = getPhaseInfo(t);
                        var p = phase.progress;
                        var cx = w * 0.5;
                        var cy = h * 0.5;

                        // ===================== PHASE: SURFACE =====================
                        if (phase.name === 'surface') {
                            // Standing on an alien planet, looking up at the sky
                            // Sky fades from rusty horizon to dark zenith
                            var skyGrad = ctx.createLinearGradient(0, 0, 0, h);
                            skyGrad.addColorStop(0, '#180808');
                            skyGrad.addColorStop(0.4, originSky[1]);
                            skyGrad.addColorStop(0.7, originSky[0]);
                            skyGrad.addColorStop(1, '#602810');
                            ctx.fillStyle = skyGrad;
                            ctx.fillRect(0, 0, w, h);

                            // A few stars visible in the dark sky
                            for (var i = 0; i < 40; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h * 0.5;
                                var twinkle = Math.sin(t * (1 + i * 0.1) + i * 3.3) * 0.5 + 0.5;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.5 + twinkle * 0.8, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(255, 230, 200, ' + (0.1 + twinkle * 0.3) + ')';
                                ctx.fill();
                            }

                            // Terrain with slow scroll
                            drawTerrain(ctx, w, h, originMountains, originGround, 'rgba(160, 80, 30, 0.1)', t * 0.5, 1.0);

                            // Rumble/shake near end (launch imminent)
                            if (p > 0.7) {
                                var shake = (p - 0.7) / 0.3;
                                var shakeAmt = shake * 3;
                                // Glow from below (rocket engines)
                                var engineGlow = ctx.createRadialGradient(cx, h, 0, cx, h, h * 0.4 * shake);
                                engineGlow.addColorStop(0, 'rgba(255, 200, 100, ' + (shake * 0.15) + ')');
                                engineGlow.addColorStop(0.5, 'rgba(255, 120, 40, ' + (shake * 0.08) + ')');
                                engineGlow.addColorStop(1, 'rgba(255, 80, 20, 0)');
                                ctx.fillStyle = engineGlow;
                                ctx.fillRect(0, 0, w, h);
                            }

                            // Flash white at very end
                            if (p > 0.92) {
                                var flash = (p - 0.92) / 0.08;
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + (flash * 0.4) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        // ===================== PHASE: ASCENT =====================
                        else if (phase.name === 'ascent') {
                            // Launching upward  sky darkens, terrain shrinks below, atmosphere thins
                            // Sky transition: rusty planet sky  black space
                            var skyDark = smoothstep(0, 0.8, p);
                            var skyGrad = ctx.createLinearGradient(0, 0, 0, h);
                            skyGrad.addColorStop(0, lerpColor('#180808', '#020206', skyDark));
                            skyGrad.addColorStop(0.5, lerpColor(originSky[1], '#050510', skyDark));
                            skyGrad.addColorStop(1, lerpColor(originSky[0], '#0a0a14', skyDark));
                            ctx.fillStyle = skyGrad;
                            ctx.fillRect(0, 0, w, h);

                            // Stars become visible as sky darkens
                            if (skyDark > 0.2) {
                                var starVis = (skyDark - 0.2) / 0.8;
                                for (var i = 0; i < 80; i++) {
                                    var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                    var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h * 0.7;
                                    var twinkle = Math.sin(t * (1 + i * 0.1) + i * 3.3) * 0.5 + 0.5;
                                    ctx.beginPath();
                                    ctx.arc(sx, sy, 0.5 + twinkle * 0.5, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(255, 240, 220, ' + (starVis * (0.1 + twinkle * 0.3)) + ')';
                                    ctx.fill();
                                }
                            }

                            // Planet surface receding below  curved horizon dropping
                            var horizonY = h * (0.7 + p * 0.5);  // Drops below screen
                            var curveAmt = 0.1 + p * 0.4;  // Curvature increases
                            if (horizonY < h + 200) {
                                ctx.beginPath();
                                ctx.moveTo(-w * 0.2, h + 100);
                                ctx.quadraticCurveTo(cx, horizonY, w * 1.2, h + 100);
                                ctx.closePath();
                                var planetGrad = ctx.createLinearGradient(0, horizonY, 0, h + 100);
                                planetGrad.addColorStop(0, originGround[0]);
                                planetGrad.addColorStop(0.4, originGround[1]);
                                planetGrad.addColorStop(1, originGround[2]);
                                ctx.fillStyle = planetGrad;
                                ctx.fill();

                                // Atmosphere glow at the limb
                                var atmosY = horizonY - 5;
                                var atmosGrad = ctx.createLinearGradient(0, atmosY - 20, 0, atmosY + 10);
                                atmosGrad.addColorStop(0, 'rgba(255, 150, 80, 0)');
                                atmosGrad.addColorStop(0.5, 'rgba(255, 150, 80, ' + (0.15 * (1 - p)) + ')');
                                atmosGrad.addColorStop(1, 'rgba(255, 100, 40, 0)');
                                ctx.fillStyle = atmosGrad;
                                ctx.fillRect(0, atmosY - 20, w, 30);
                            }

                            // Cloud layers whipping past
                            if (p < 0.5) {
                                var cloudFade = 1 - p / 0.5;
                                for (var i = 0; i < 8; i++) {
                                    var cloudY = (h * 0.3 + i * h * 0.08 + phase.phaseTime * 200) % (h * 1.5) - h * 0.25;
                                    var cloudX = (Math.sin(i * 5.7 + 1.3) * 0.5 + 0.5) * w;
                                    var cloudW = 60 + Math.sin(i * 3.1) * 30;
                                    ctx.beginPath();
                                    ctx.ellipse(cloudX, cloudY, cloudW, 8, 0, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(200, 160, 130, ' + (cloudFade * 0.06) + ')';
                                    ctx.fill();
                                }
                            }

                            // Engine glow fading out
                            var engineFade = 1 - smoothstep(0, 0.3, p);
                            if (engineFade > 0) {
                                var eGlow = ctx.createRadialGradient(cx, h, 0, cx, h, h * 0.3);
                                eGlow.addColorStop(0, 'rgba(255, 200, 100, ' + (engineFade * 0.1) + ')');
                                eGlow.addColorStop(1, 'rgba(255, 100, 30, 0)');
                                ctx.fillStyle = eGlow;
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        // ===================== PHASE: SPACE =====================
                        else if (phase.name === 'space') {
                            // Cruising through space  peaceful starfield, origin planet shrinking behind
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);

                            // Gentle starfield (static, slight drift)
                            for (var i = 0; i < stars.length; i++) {
                                var s = stars[i];
                                var sx = ((s.x * 0.5 + 0.5) * w + t * 2 * (s.z * 0.3 + 0.1)) % w;
                                var sy = ((s.y * 0.5 + 0.5) * h + t * 0.5 * (s.z * 0.2)) % h;
                                var bright = s.bright * (0.5 + Math.sin(t * 0.7 + i * 2.3) * 0.3);
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4 + s.z * 0.3, 0, Math.PI * 2);
                                if (s.hue > 0) {
                                    ctx.fillStyle = 'hsla(' + s.hue + ', 50%, 70%, ' + (bright * 0.6) + ')';
                                } else {
                                    ctx.fillStyle = 'rgba(220, 230, 255, ' + (bright * 0.5) + ')';
                                }
                                ctx.fill();
                            }

                            // Origin planet shrinking behind (bottom-left)
                            var planetR = Math.max(5, w * 0.15 * (1 - p));
                            var planetX = w * (0.3 - p * 0.15);
                            var planetY = h * (0.7 + p * 0.1);
                            drawPlanetSphere(ctx, planetX, planetY, planetR, [originSky[0], originGround[0], originGround[2]]);

                            // Nebula wisps passing
                            for (var i = 0; i < 4; i++) {
                                var nx = ((Math.sin(i * 4.7) * 0.5 + 0.5) * w + t * 8) % (w * 1.4) - w * 0.2;
                                var ny = (Math.sin(i * 3.3 + 1.7) * 0.5 + 0.5) * h;
                                var nGrad = ctx.createRadialGradient(nx, ny, 0, nx, ny, 40 + Math.sin(i * 2.9) * 15);
                                var nHue = 200 + i * 40;
                                nGrad.addColorStop(0, 'hsla(' + nHue + ', 40%, 50%, 0.02)');
                                nGrad.addColorStop(1, 'hsla(' + nHue + ', 40%, 30%, 0)');
                                ctx.beginPath();
                                ctx.arc(nx, ny, 50, 0, Math.PI * 2);
                                ctx.fillStyle = nGrad;
                                ctx.fill();
                            }
                        }

                        // ===================== PHASE: HYPER ENTRY =====================
                        else if (phase.name === 'hyperEntry') {
                            // Stars stretch into streaks, blue-shift, tunnel forms
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);

                            var stretch = smoothstep(0, 1, p);  // 0 to 1 over this phase
                            var speed = 0.5 + stretch * 4;

                            for (var i = 0; i < stars.length; i++) {
                                var s = stars[i];
                                s.z -= speed * dt;
                                if (s.z <= 0.01) {
                                    s.x = (Math.random() - 0.5) * 2;
                                    s.y = (Math.random() - 0.5) * 2;
                                    s.z = 2.5 + Math.random() * 0.5;
                                    s.hasPrev = false;
                                    continue;
                                }

                                var sx = cx + (s.x / s.z) * w * 0.5;
                                var sy = cy + (s.y / s.z) * h * 0.5;

                                if (sx < -50 || sx > w + 50 || sy < -50 || sy > h + 50) {
                                    s.x = (Math.random() - 0.5) * 2;
                                    s.y = (Math.random() - 0.5) * 2;
                                    s.z = 2.5 + Math.random() * 0.5;
                                    s.hasPrev = false;
                                    continue;
                                }

                                var brightness = Math.min(1, (3 - s.z) / 2) * s.bright;
                                var streakLen = stretch * 20;

                                // Draw streaked star
                                if (s.hasPrev && streakLen > 1) {
                                    ctx.beginPath();
                                    ctx.moveTo(s.prevSx, s.prevSy);
                                    ctx.lineTo(sx, sy);
                                    // Blue-shift as speed increases
                                    var bShift = stretch;
                                    var r = Math.round(200 * (1 - bShift * 0.6));
                                    var g = Math.round(220 * (1 - bShift * 0.2));
                                    var b = 255;
                                    ctx.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + (brightness * 0.6) + ')';
                                    ctx.lineWidth = 0.5 + (1 - s.z / 3) * 2;
                                    ctx.lineCap = 'round';
                                    ctx.stroke();
                                }

                                ctx.beginPath();
                                ctx.arc(sx, sy, Math.max(0.3, (1 - s.z / 3) * 2), 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(180, 210, 255, ' + brightness + ')';
                                ctx.fill();

                                s.prevSx = sx;
                                s.prevSy = sy;
                                s.hasPrev = true;
                            }

                            // Growing central tunnel glow
                            var glowR = 30 + stretch * 80;
                            var cGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
                            cGrad.addColorStop(0, 'rgba(150, 180, 255, ' + (stretch * 0.12) + ')');
                            cGrad.addColorStop(0.5, 'rgba(100, 140, 255, ' + (stretch * 0.05) + ')');
                            cGrad.addColorStop(1, 'rgba(60, 100, 220, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, glowR, 0, Math.PI * 2);
                            ctx.fillStyle = cGrad;
                            ctx.fill();

                            // Flash at the end
                            if (p > 0.85) {
                                var flash = (p - 0.85) / 0.15;
                                ctx.fillStyle = 'rgba(200, 220, 255, ' + (flash * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        // ===================== PHASE: HYPERSPACE =====================
                        else if (phase.name === 'hyperspace') {
                            // Full warp tunnel with colour streaks, energy ribbons
                            ctx.fillStyle = '#010108';
                            ctx.fillRect(0, 0, w, h);

                            var speed = 4.5;

                            // Stars as long streaks
                            for (var i = 0; i < stars.length; i++) {
                                var s = stars[i];
                                s.z -= speed * dt;
                                if (s.z <= 0.01) {
                                    s.x = (Math.random() - 0.5) * 2;
                                    s.y = (Math.random() - 0.5) * 2;
                                    s.z = 2.5 + Math.random() * 0.5;
                                    s.hasPrev = false;
                                    continue;
                                }

                                var sx = cx + (s.x / s.z) * w * 0.5;
                                var sy = cy + (s.y / s.z) * h * 0.5;

                                if (sx < -100 || sx > w + 100 || sy < -100 || sy > h + 100) {
                                    s.x = (Math.random() - 0.5) * 2;
                                    s.y = (Math.random() - 0.5) * 2;
                                    s.z = 2.5 + Math.random() * 0.5;
                                    s.hasPrev = false;
                                    continue;
                                }

                                var brightness = Math.min(1, (3 - s.z) / 2) * s.bright;

                                if (s.hasPrev) {
                                    ctx.beginPath();
                                    ctx.moveTo(s.prevSx, s.prevSy);
                                    ctx.lineTo(sx, sy);
                                    ctx.strokeStyle = 'rgba(140, 170, 255, ' + (brightness * 0.5) + ')';
                                    ctx.lineWidth = 0.5 + (1 - s.z / 3) * 2.5;
                                    ctx.lineCap = 'round';
                                    ctx.stroke();
                                }

                                ctx.beginPath();
                                ctx.arc(sx, sy, Math.max(0.3, (1 - s.z / 3) * 1.5), 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 220, 255, ' + brightness + ')';
                                ctx.fill();

                                s.prevSx = sx;
                                s.prevSy = sy;
                                s.hasPrev = true;
                            }

                            // Coloured energy ribbons spiralling around the tunnel
                            for (var r = 0; r < 5; r++) {
                                var ribbonHue = (t * 30 + r * 72) % 360;
                                var ribbonPhase = t * 1.5 + r * Math.PI * 0.4;
                                ctx.beginPath();
                                for (var s = 0; s <= 40; s++) {
                                    var frac = s / 40;
                                    var dist = 20 + frac * Math.min(w, h) * 0.45;
                                    var angle = ribbonPhase + frac * Math.PI * 3;
                                    var rx = cx + Math.cos(angle) * dist;
                                    var ry = cy + Math.sin(angle) * dist * 0.6;
                                    if (s === 0) ctx.moveTo(rx, ry);
                                    else ctx.lineTo(rx, ry);
                                }
                                ctx.strokeStyle = 'hsla(' + ribbonHue + ', 70%, 60%, 0.06)';
                                ctx.lineWidth = 2 + Math.sin(t + r) * 1;
                                ctx.lineCap = 'round';
                                ctx.stroke();
                            }

                            // Central warp glow
                            var cGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 60);
                            cGrad.addColorStop(0, 'rgba(180, 200, 255, 0.1)');
                            cGrad.addColorStop(0.4, 'rgba(120, 150, 255, 0.04)');
                            cGrad.addColorStop(1, 'rgba(80, 100, 220, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, 60, 0, Math.PI * 2);
                            ctx.fillStyle = cGrad;
                            ctx.fill();

                            // Occasional bright flashes along the tunnel
                            for (var i = 0; i < 3; i++) {
                                var flashPhase = Math.sin(t * 2.3 + i * 2.1);
                                if (flashPhase > 0.85) {
                                    var fAngle = t * 0.7 + i * Math.PI * 0.67;
                                    var fDist = 50 + (flashPhase - 0.85) * 400;
                                    var fx = cx + Math.cos(fAngle) * fDist;
                                    var fy = cy + Math.sin(fAngle) * fDist * 0.6;
                                    var fGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, 15);
                                    fGrad.addColorStop(0, 'rgba(200, 220, 255, 0.15)');
                                    fGrad.addColorStop(1, 'rgba(150, 180, 255, 0)');
                                    ctx.beginPath();
                                    ctx.arc(fx, fy, 15, 0, Math.PI * 2);
                                    ctx.fillStyle = fGrad;
                                    ctx.fill();
                                }
                            }
                        }

                        // ===================== PHASE: DECELERATE =====================
                        else if (phase.name === 'decelerate') {
                            // Streaks shorten, a dot appears and grows  destination planet
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);

                            var slowdown = smoothstep(0, 1, p);  // 01
                            var speed = 4.5 * (1 - slowdown * 0.85);  // Fastslow

                            for (var i = 0; i < stars.length; i++) {
                                var s = stars[i];
                                s.z -= speed * dt;
                                if (s.z <= 0.01) {
                                    s.x = (Math.random() - 0.5) * 2;
                                    s.y = (Math.random() - 0.5) * 2;
                                    s.z = 2.5 + Math.random() * 0.5;
                                    s.hasPrev = false;
                                    continue;
                                }

                                var sx = cx + (s.x / s.z) * w * 0.5;
                                var sy = cy + (s.y / s.z) * h * 0.5;

                                if (sx < -50 || sx > w + 50 || sy < -50 || sy > h + 50) {
                                    s.x = (Math.random() - 0.5) * 2;
                                    s.y = (Math.random() - 0.5) * 2;
                                    s.z = 2.5 + Math.random() * 0.5;
                                    s.hasPrev = false;
                                    continue;
                                }

                                var brightness = Math.min(1, (3 - s.z) / 2) * s.bright;
                                var streakFade = 1 - slowdown;

                                if (s.hasPrev && streakFade > 0.1) {
                                    ctx.beginPath();
                                    ctx.moveTo(s.prevSx, s.prevSy);
                                    ctx.lineTo(sx, sy);
                                    ctx.strokeStyle = 'rgba(180, 200, 255, ' + (brightness * 0.4 * streakFade) + ')';
                                    ctx.lineWidth = 0.5 + (1 - s.z / 3) * 2 * streakFade;
                                    ctx.lineCap = 'round';
                                    ctx.stroke();
                                }

                                ctx.beginPath();
                                ctx.arc(sx, sy, Math.max(0.3, (1 - s.z / 3) * (1 + streakFade)), 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(220, 230, 255, ' + brightness + ')';
                                ctx.fill();

                                s.prevSx = sx;
                                s.prevSy = sy;
                                s.hasPrev = true;
                            }

                            // Fading energy ribbons
                            if (slowdown < 0.7) {
                                var ribbonFade = 1 - slowdown / 0.7;
                                for (var r = 0; r < 3; r++) {
                                    var ribbonHue = (t * 30 + r * 72) % 360;
                                    var ribbonPhase = t * 1.5 * (1 - slowdown * 0.5) + r * Math.PI * 0.4;
                                    ctx.beginPath();
                                    for (var s = 0; s <= 30; s++) {
                                        var frac = s / 30;
                                        var dist = 20 + frac * Math.min(w, h) * 0.35;
                                        var angle = ribbonPhase + frac * Math.PI * 2.5;
                                        var rx = cx + Math.cos(angle) * dist;
                                        var ry = cy + Math.sin(angle) * dist * 0.6;
                                        if (s === 0) ctx.moveTo(rx, ry);
                                        else ctx.lineTo(rx, ry);
                                    }
                                    ctx.strokeStyle = 'hsla(' + ribbonHue + ', 60%, 55%, ' + (0.04 * ribbonFade) + ')';
                                    ctx.lineWidth = 1.5;
                                    ctx.stroke();
                                }
                            }

                            // Destination planet dot appearing and growing
                            var dotAppear = smoothstep(0.15, 1, p);
                            var dotR = 1 + dotAppear * 12;
                            drawPlanetSphere(ctx, cx, cy, dotR, [destSky[0], destGround[0], destGround[2]]);

                            // Central glow fading
                            var glowFade = 1 - slowdown;
                            if (glowFade > 0) {
                                var cGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                                cGrad.addColorStop(0, 'rgba(150, 180, 255, ' + (glowFade * 0.06) + ')');
                                cGrad.addColorStop(1, 'rgba(80, 100, 220, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy, 40, 0, Math.PI * 2);
                                ctx.fillStyle = cGrad;
                                ctx.fill();
                            }
                        }

                        // ===================== PHASE: ARRIVAL =====================
                        else if (phase.name === 'arrival') {
                            // Drop out of hyperspace  planet rushes toward us and fills the view
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);

                            // Static starfield behind
                            for (var i = 0; i < 120; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                var twinkle = Math.sin(t * 0.5 + i * 2.3) * 0.5 + 0.5;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4 + twinkle * 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(220, 230, 255, ' + (0.15 + twinkle * 0.2) + ')';
                                ctx.fill();
                            }

                            // Planet growing rapidly  from small disc to filling most of the screen
                            var grow = smoothstep(0, 1, p);
                            var planetR = 15 + grow * Math.max(w, h) * 0.7;
                            // Planet drops slightly below centre as we approach
                            var planetCY = cy + grow * h * 0.2;
                            drawPlanetSphere(ctx, cx, planetCY, planetR, [destSky[0], destGround[0], destGround[2]]);

                            // Cloud bands on the planet
                            if (planetR > 50) {
                                ctx.save();
                                ctx.beginPath();
                                ctx.arc(cx, planetCY, planetR, 0, Math.PI * 2);
                                ctx.clip();
                                for (var i = 0; i < 8; i++) {
                                    var bandY = planetCY - planetR + (i / 8) * planetR * 2;
                                    var bandH = planetR * 0.05;
                                    var bandOp = 0.03 + Math.sin(i * 2.3 + t * 0.1) * 0.01;
                                    ctx.beginPath();
                                    ctx.ellipse(cx + Math.sin(i * 3.7 + t * 0.05) * 10, bandY, planetR * 0.9, bandH, 0, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(255, 255, 255, ' + bandOp + ')';
                                    ctx.fill();
                                }
                                ctx.restore();
                            }

                            // Atmospheric entry glow at the end
                            if (p > 0.7) {
                                var entryGlow = (p - 0.7) / 0.3;
                                var eGrad = ctx.createRadialGradient(cx, h * 0.3, 0, cx, h * 0.3, h * 0.6);
                                eGrad.addColorStop(0, 'rgba(255, 180, 100, ' + (entryGlow * 0.15) + ')');
                                eGrad.addColorStop(0.5, 'rgba(255, 120, 60, ' + (entryGlow * 0.08) + ')');
                                eGrad.addColorStop(1, 'rgba(255, 80, 30, 0)');
                                ctx.fillStyle = eGrad;
                                ctx.fillRect(0, 0, w, h);
                            }

                            // Flash into descent
                            if (p > 0.9) {
                                var flash = (p - 0.9) / 0.1;
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + (flash * 0.5) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        // ===================== PHASE: DESCENT =====================
                        else if (phase.name === 'descent') {
                            // Descending through atmosphere to the new planet's surface
                            // Sky lightens, clouds appear, terrain rises to meet us
                            var skyLight = smoothstep(0, 0.7, p);
                            var skyGrad = ctx.createLinearGradient(0, 0, 0, h);
                            skyGrad.addColorStop(0, lerpColor('#020210', destSky[2], skyLight));
                            skyGrad.addColorStop(0.4, lerpColor('#050515', destSky[1], skyLight));
                            skyGrad.addColorStop(0.7, lerpColor('#0a0a20', destSky[0], skyLight));
                            skyGrad.addColorStop(1, lerpColor('#101030', '#80c0a0', skyLight));
                            ctx.fillStyle = skyGrad;
                            ctx.fillRect(0, 0, w, h);

                            // Stars fading as atmosphere thickens
                            if (skyLight < 0.8) {
                                var starFade = 1 - skyLight / 0.8;
                                for (var i = 0; i < 60; i++) {
                                    var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                    var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h * 0.5;
                                    ctx.beginPath();
                                    ctx.arc(sx, sy, 0.5, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (starFade * 0.2) + ')';
                                    ctx.fill();
                                }
                            }

                            // Clouds appearing and rushing upward
                            if (p > 0.15) {
                                var cloudIntensity = smoothstep(0.15, 0.5, p);
                                for (var i = 0; i < 10; i++) {
                                    var cloudY = h - ((phase.phaseTime * 80 + i * h * 0.15) % (h * 1.3)) + h * 0.3;
                                    var cloudX = (Math.sin(i * 5.7 + 1.3) * 0.5 + 0.5) * w;
                                    var cloudW = 80 + Math.sin(i * 3.1) * 40;
                                    ctx.beginPath();
                                    ctx.ellipse(cloudX, cloudY, cloudW, 12, 0, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(220, 240, 250, ' + (cloudIntensity * 0.05) + ')';
                                    ctx.fill();
                                }
                            }

                            // Terrain rising from below
                            var terrainRise = smoothstep(0.35, 1, p);
                            if (terrainRise > 0) {
                                // Curved horizon rising
                                var horizonY = h + h * 0.4 * (1 - terrainRise);
                                ctx.beginPath();
                                ctx.moveTo(-w * 0.2, h + 50);
                                ctx.quadraticCurveTo(cx, horizonY, w * 1.2, h + 50);
                                ctx.closePath();
                                ctx.fillStyle = destGround[0];
                                ctx.fill();

                                // Mountains appearing
                                if (terrainRise > 0.3) {
                                    var mtScale = (terrainRise - 0.3) / 0.7;
                                    drawTerrain(ctx, w, h, destMountains, destGround, 'rgba(60, 120, 80, 0.08)', t * 0.3, mtScale * 0.6);
                                }

                                // Atmosphere haze near horizon
                                var hazeGrad = ctx.createLinearGradient(0, horizonY - 40, 0, horizonY + 10);
                                hazeGrad.addColorStop(0, 'rgba(160, 200, 180, 0)');
                                hazeGrad.addColorStop(1, 'rgba(160, 200, 180, ' + (terrainRise * 0.08) + ')');
                                ctx.fillStyle = hazeGrad;
                                ctx.fillRect(0, horizonY - 40, w, 50);
                            }

                            // Re-entry heat dissipating
                            if (p < 0.2) {
                                var heat = 1 - p / 0.2;
                                ctx.fillStyle = 'rgba(255, 200, 150, ' + (heat * 0.1) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }

                            // Fade to surface phase at end
                            if (p > 0.9) {
                                var fade = (p - 0.9) / 0.1;
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + (fade * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }
                    }
                };
            })();

            // --- Odyssey theme ---
            // Deep ocean dive: surface  sunlit  twilight  midnight  abyss  ascent  breach
            themes.odyssey = (function () {
                var PHASES = [
                    { name: 'surface', duration: 5 },
                    { name: 'sunlit', duration: 6 },
                    { name: 'twilight', duration: 6 },
                    { name: 'midnight', duration: 7 },
                    { name: 'abyss', duration: 7 },
                    { name: 'ascent', duration: 8 },
                    { name: 'breach', duration: 4 }
                ];
                var TOTAL = 0;
                for (var i = 0; i < PHASES.length; i++) TOTAL += PHASES[i].duration;

                // Bioluminescent creatures
                var bioCreatures = [];
                for (var i = 0; i < 20; i++) {
                    bioCreatures.push({
                        x: Math.random(), y: Math.random(),
                        size: 2 + Math.random() * 6,
                        hue: 180 + Math.random() * 60,
                        pulseSpeed: 0.5 + Math.random() * 2,
                        pulseOff: Math.random() * Math.PI * 2,
                        driftX: (Math.random() - 0.5) * 0.02,
                        driftY: (Math.random() - 0.5) * 0.01,
                        tentacles: Math.random() < 0.4
                    });
                }

                function getPhase(t) {
                    var ct = t % TOTAL, el = 0;
                    for (var i = 0; i < PHASES.length; i++) {
                        if (ct < el + PHASES[i].duration)
                            return { name: PHASES[i].name, progress: (ct - el) / PHASES[i].duration, time: ct - el };
                        el += PHASES[i].duration;
                    }
                    return { name: 'surface', progress: 0, time: 0 };
                }

                function sm(a, b, t) { t = Math.max(0, Math.min(1, (t - a) / (b - a))); return t * t * (3 - 2 * t); }

                function drawWaves(ctx, w, h, t, baseY, amp, count, color) {
                    for (var i = 0; i < count; i++) {
                        ctx.beginPath();
                        var waveY = baseY + i * 6;
                        for (var x = 0; x <= w; x += 4) {
                            var y = waveY + Math.sin(x * 0.008 + t * (0.8 + i * 0.2) + i * 1.5) * amp
                                          + Math.sin(x * 0.015 + t * 1.2 + i * 0.7) * amp * 0.5;
                            if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                }

                function drawBubbles(ctx, w, h, t, count, rise, op) {
                    for (var i = 0; i < count; i++) {
                        var bx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                        var by = h - ((t * rise + i * h * 0.1) % (h * 1.2)) + h * 0.1;
                        var br = 1 + Math.sin(i * 3.1) * 0.8;
                        ctx.beginPath();
                        ctx.arc(bx + Math.sin(t * 1.5 + i * 2) * 5, by, br, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(200, 230, 255, ' + op + ')';
                        ctx.fill();
                    }
                }

                return {
                    targetCount: 0,
                    spawn: function () { return { x: 0, y: 0 }; },
                    update: function () { return true; },
                    draw: function () {},
                    onActivate: function () {},

                    drawBackground: function (ctx, w, h, state) {
                        ctx.fillStyle = '#040810';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var ph = getPhase(t);
                        var p = ph.progress;
                        var cx = w * 0.5, cy = h * 0.5;

                        if (ph.name === 'surface') {
                            // Ocean surface: sky above, water below, gentle waves
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.45);
                            skyG.addColorStop(0, '#1a3050');
                            skyG.addColorStop(1, '#305878');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h * 0.45);
                            var waterG = ctx.createLinearGradient(0, h * 0.45, 0, h);
                            waterG.addColorStop(0, '#1a5070');
                            waterG.addColorStop(1, '#0a2840');
                            ctx.fillStyle = waterG;
                            ctx.fillRect(0, h * 0.45, w, h * 0.55);

                            // Sun reflection
                            var sunX = w * 0.6, sunY = h * 0.15;
                            var sG = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 60);
                            sG.addColorStop(0, 'rgba(255, 230, 180, 0.3)');
                            sG.addColorStop(1, 'rgba(255, 200, 130, 0)');
                            ctx.fillStyle = sG;
                            ctx.fillRect(0, 0, w, h * 0.45);

                            drawWaves(ctx, w, h, t, h * 0.43, 8, 5, 'rgba(100, 180, 220, 0.08)');

                            // Submerge at end
                            if (p > 0.6) {
                                var sub = (p - 0.6) / 0.4;
                                ctx.fillStyle = 'rgba(10, 40, 70, ' + (sub * 0.6) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'sunlit') {
                            // Bright blue water, light rays from above, fish shadows
                            var wG = ctx.createLinearGradient(0, 0, 0, h);
                            var darkening = sm(0, 1, p);
                            var topR = Math.round(20 - darkening * 10), topG2 = Math.round(100 - darkening * 40), topB = Math.round(140 - darkening * 40);
                            var botR = Math.round(8 - darkening * 4), botG2 = Math.round(50 - darkening * 25), botB = Math.round(90 - darkening * 30);
                            wG.addColorStop(0, 'rgb(' + topR + ',' + topG2 + ',' + topB + ')');
                            wG.addColorStop(1, 'rgb(' + botR + ',' + botG2 + ',' + botB + ')');
                            ctx.fillStyle = wG;
                            ctx.fillRect(0, 0, w, h);

                            // Light rays from surface
                            var rayOp = 0.04 * (1 - darkening * 0.7);
                            for (var i = 0; i < 6; i++) {
                                var rx = w * (0.2 + i * 0.12) + Math.sin(t * 0.3 + i) * 20;
                                ctx.beginPath();
                                ctx.moveTo(rx - 15, 0);
                                ctx.lineTo(rx + 15, 0);
                                ctx.lineTo(rx + 40 + Math.sin(t * 0.5 + i * 2) * 10, h);
                                ctx.lineTo(rx - 10 + Math.sin(t * 0.4 + i * 3) * 10, h);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(100, 200, 255, ' + rayOp + ')';
                                ctx.fill();
                            }

                            // Fish silhouettes
                            for (var i = 0; i < 5; i++) {
                                var fx = ((t * 30 + i * w * 0.25) % (w * 1.4)) - w * 0.2;
                                var fy = h * (0.3 + Math.sin(i * 3.7) * 0.2) + Math.sin(t * 0.8 + i * 2) * 15;
                                var fs = 8 + Math.sin(i * 5.1) * 4;
                                ctx.beginPath();
                                ctx.ellipse(fx, fy, fs, fs * 0.35, 0, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(5, 30, 50, 0.08)';
                                ctx.fill();
                                // Tail
                                ctx.beginPath();
                                ctx.moveTo(fx + fs, fy);
                                ctx.lineTo(fx + fs + fs * 0.5, fy - fs * 0.3);
                                ctx.lineTo(fx + fs + fs * 0.5, fy + fs * 0.3);
                                ctx.closePath();
                                ctx.fill();
                            }

                            drawBubbles(ctx, w, h, t, 12, 25, 0.06);
                        }

                        else if (ph.name === 'twilight') {
                            // Dimming blue, jellyfish silhouettes
                            var darkening = sm(0, 1, p);
                            var wG = ctx.createLinearGradient(0, 0, 0, h);
                            var tR = Math.round(10 - darkening * 6), tGv = Math.round(50 - darkening * 30), tBv = Math.round(90 - darkening * 40);
                            var bR = Math.round(5 - darkening * 3), bGv = Math.round(20 - darkening * 12), bBv = Math.round(60 - darkening * 35);
                            wG.addColorStop(0, 'rgb(' + tR + ',' + tGv + ',' + tBv + ')');
                            wG.addColorStop(1, 'rgb(' + bR + ',' + bGv + ',' + bBv + ')');
                            ctx.fillStyle = wG;
                            ctx.fillRect(0, 0, w, h);

                            // Faint light from above fading
                            var topGlow = (1 - darkening) * 0.03;
                            if (topGlow > 0.005) {
                                var tG = ctx.createLinearGradient(0, 0, 0, h * 0.4);
                                tG.addColorStop(0, 'rgba(60, 120, 160, ' + topGlow + ')');
                                tG.addColorStop(1, 'rgba(30, 60, 80, 0)');
                                ctx.fillStyle = tG;
                                ctx.fillRect(0, 0, w, h * 0.4);
                            }

                            // Jellyfish
                            for (var i = 0; i < 6; i++) {
                                var jx = (Math.sin(i * 5.3 + t * 0.05) * 0.5 + 0.5) * w;
                                var jy = ((t * 12 + i * h * 0.2) % (h * 1.3)) - h * 0.15;
                                jy = h - jy; // Rising
                                var jSize = 12 + Math.sin(i * 3.7) * 6;
                                var pulse = Math.sin(t * 1.2 + i * 2) * 0.3 + 0.7;
                                // Bell
                                ctx.beginPath();
                                ctx.ellipse(jx, jy, jSize * pulse, jSize * 0.6 * pulse, 0, Math.PI, 0);
                                ctx.fillStyle = 'rgba(100, 140, 180, 0.06)';
                                ctx.fill();
                                // Tentacles
                                for (var tn = 0; tn < 4; tn++) {
                                    ctx.beginPath();
                                    var tx = jx + (tn - 1.5) * jSize * 0.3;
                                    ctx.moveTo(tx, jy);
                                    ctx.quadraticCurveTo(tx + Math.sin(t * 2 + i + tn) * 8, jy + jSize * 1.2, tx + Math.sin(t * 1.5 + tn * 3) * 5, jy + jSize * 2);
                                    ctx.strokeStyle = 'rgba(80, 130, 170, 0.04)';
                                    ctx.lineWidth = 1;
                                    ctx.stroke();
                                }
                            }

                            // Marine snow (particles drifting down)
                            for (var i = 0; i < 20; i++) {
                                var mx = (Math.sin(i * 6.7 + t * 0.02) * 0.5 + 0.5) * w;
                                var my = (t * 8 + i * h * 0.06) % h;
                                ctx.beginPath();
                                ctx.arc(mx + Math.sin(t * 0.5 + i) * 3, my, 0.8, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(150, 180, 200, 0.06)';
                                ctx.fill();
                            }
                        }

                        else if (ph.name === 'midnight') {
                            // Pitch black with bioluminescent creatures
                            ctx.fillStyle = '#020408';
                            ctx.fillRect(0, 0, w, h);

                            for (var i = 0; i < bioCreatures.length; i++) {
                                var c = bioCreatures[i];
                                var bx = (c.x + Math.sin(t * c.driftX * 10 + i * 2) * 0.05) * w;
                                var by = (c.y + Math.sin(t * c.driftY * 10 + i * 3) * 0.04) * h;
                                var pulse = Math.sin(t * c.pulseSpeed + c.pulseOff) * 0.5 + 0.5;
                                var glow = pulse * 0.15;

                                // Glow halo
                                var gR = ctx.createRadialGradient(bx, by, 0, bx, by, c.size * 4);
                                gR.addColorStop(0, 'hsla(' + c.hue + ', 80%, 60%, ' + (glow * 0.6) + ')');
                                gR.addColorStop(1, 'hsla(' + c.hue + ', 80%, 40%, 0)');
                                ctx.beginPath();
                                ctx.arc(bx, by, c.size * 4, 0, Math.PI * 2);
                                ctx.fillStyle = gR;
                                ctx.fill();

                                // Body
                                ctx.beginPath();
                                ctx.arc(bx, by, c.size * (0.8 + pulse * 0.2), 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + c.hue + ', 70%, 55%, ' + (glow + 0.03) + ')';
                                ctx.fill();

                                // Tentacles for jellyfish types
                                if (c.tentacles) {
                                    for (var tn = 0; tn < 3; tn++) {
                                        ctx.beginPath();
                                        ctx.moveTo(bx, by + c.size);
                                        ctx.quadraticCurveTo(
                                            bx + Math.sin(t * 1.5 + i + tn * 2) * 10,
                                            by + c.size * 3,
                                            bx + Math.sin(t + tn * 3) * 6,
                                            by + c.size * 5
                                        );
                                        ctx.strokeStyle = 'hsla(' + c.hue + ', 70%, 50%, ' + (glow * 0.4) + ')';
                                        ctx.lineWidth = 0.8;
                                        ctx.stroke();
                                    }
                                }
                            }

                            // Occasional flash (anglerfish lure)
                            var flashPhase = Math.sin(t * 0.4);
                            if (flashPhase > 0.9) {
                                var ff = (flashPhase - 0.9) * 10;
                                var flx = w * 0.3 + Math.sin(t * 0.1) * w * 0.2;
                                var fly = h * 0.5 + Math.sin(t * 0.15 + 1) * h * 0.2;
                                var fG = ctx.createRadialGradient(flx, fly, 0, flx, fly, 25);
                                fG.addColorStop(0, 'rgba(200, 255, 200, ' + (ff * 0.2) + ')');
                                fG.addColorStop(1, 'rgba(100, 200, 150, 0)');
                                ctx.beginPath();
                                ctx.arc(flx, fly, 25, 0, Math.PI * 2);
                                ctx.fillStyle = fG;
                                ctx.fill();
                            }
                        }

                        else if (ph.name === 'abyss') {
                            // Hydrothermal vents, smoky plumes, orange glow
                            ctx.fillStyle = '#020305';
                            ctx.fillRect(0, 0, w, h);

                            // Vent structures on the floor
                            var floorY = h * 0.82;
                            // Rocky floor
                            ctx.beginPath();
                            ctx.moveTo(0, h);
                            for (var x = 0; x <= w; x += 3) {
                                var fy = floorY + Math.sin(x * 0.02 + 0.5) * 8 + Math.sin(x * 0.05 + 1.3) * 4;
                                ctx.lineTo(x, fy);
                            }
                            ctx.lineTo(w, h);
                            ctx.closePath();
                            ctx.fillStyle = '#0a0a08';
                            ctx.fill();

                            // Vent chimneys
                            for (var i = 0; i < 4; i++) {
                                var vx = w * (0.2 + i * 0.2) + Math.sin(i * 5.3) * 20;
                                var vw = 12 + Math.sin(i * 3.1) * 5;
                                var vh = 30 + Math.sin(i * 4.7) * 15;
                                ctx.fillStyle = '#0c0c08';
                                ctx.fillRect(vx - vw / 2, floorY - vh, vw, vh);

                                // Hot glow at vent opening
                                var ventGlow = ctx.createRadialGradient(vx, floorY - vh, 0, vx, floorY - vh, 20);
                                ventGlow.addColorStop(0, 'rgba(255, 120, 30, ' + (0.12 + Math.sin(t * 2 + i * 3) * 0.04) + ')');
                                ventGlow.addColorStop(1, 'rgba(255, 60, 10, 0)');
                                ctx.beginPath();
                                ctx.arc(vx, floorY - vh, 20, 0, Math.PI * 2);
                                ctx.fillStyle = ventGlow;
                                ctx.fill();

                                // Smoke plumes rising
                                for (var s = 0; s < 8; s++) {
                                    var sy = floorY - vh - (t * 20 + s * 25 + i * 40) % (h * 0.7);
                                    var sx = vx + Math.sin(t * 0.8 + s * 1.5 + i) * (10 + s * 2);
                                    var sr = 4 + s * 2;
                                    var sop = Math.max(0, 0.04 - s * 0.004);
                                    ctx.beginPath();
                                    ctx.arc(sx, sy, sr, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(80, 80, 60, ' + sop + ')';
                                    ctx.fill();
                                }
                            }

                            // Scattered bioluminescence
                            for (var i = 0; i < 8; i++) {
                                var c = bioCreatures[i];
                                var bx = (c.x + Math.sin(t * 0.03 + i * 2) * 0.05) * w;
                                var by = (c.y * 0.6 + 0.1) * h;
                                var pulse = Math.sin(t * c.pulseSpeed + c.pulseOff) * 0.5 + 0.5;
                                ctx.beginPath();
                                ctx.arc(bx, by, c.size * 0.6, 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + c.hue + ', 70%, 50%, ' + (pulse * 0.08) + ')';
                                ctx.fill();
                            }
                        }

                        else if (ph.name === 'ascent') {
                            // Rising back through zones  reverse the journey
                            // Blend from dark abyss to twilight to sunlit
                            var zone = p * 3; // 0-1 abyssmidnight, 1-2 twilight, 2-3 sunlit
                            if (zone < 1) {
                                // Abyss to midnight
                                var blend = zone;
                                var wG = ctx.createLinearGradient(0, 0, 0, h);
                                wG.addColorStop(0, 'rgb(' + Math.round(2 + blend * 2) + ',' + Math.round(3 + blend * 2) + ',' + Math.round(5 + blend * 3) + ')');
                                wG.addColorStop(1, 'rgb(2,4,8)');
                                ctx.fillStyle = wG;
                                ctx.fillRect(0, 0, w, h);
                                // Fading bioluminescence
                                for (var i = 0; i < 10; i++) {
                                    var c = bioCreatures[i];
                                    var pulse = Math.sin(t * c.pulseSpeed + c.pulseOff) * 0.5 + 0.5;
                                    var bx = (c.x + Math.sin(t * 0.03 + i) * 0.05) * w;
                                    var by = (c.y + blend * 0.3) * h;
                                    ctx.beginPath();
                                    ctx.arc(bx, by, c.size, 0, Math.PI * 2);
                                    ctx.fillStyle = 'hsla(' + c.hue + ', 70%, 50%, ' + (pulse * 0.08 * (1 - blend * 0.5)) + ')';
                                    ctx.fill();
                                }
                            } else if (zone < 2) {
                                // Midnight to twilight
                                var blend = zone - 1;
                                var wG = ctx.createLinearGradient(0, 0, 0, h);
                                var tR = Math.round(4 + blend * 6), tGv = Math.round(8 + blend * 30), tBv = Math.round(14 + blend * 50);
                                wG.addColorStop(0, 'rgb(' + tR + ',' + tGv + ',' + tBv + ')');
                                wG.addColorStop(1, 'rgb(' + Math.round(2 + blend * 3) + ',' + Math.round(5 + blend * 15) + ',' + Math.round(8 + blend * 30) + ')');
                                ctx.fillStyle = wG;
                                ctx.fillRect(0, 0, w, h);
                                // Jellyfish passing
                                for (var i = 0; i < 4; i++) {
                                    var jx = (Math.sin(i * 5.3 + t * 0.05) * 0.5 + 0.5) * w;
                                    var jy = ((t * 15 + i * h * 0.3) % (h * 1.3)) - h * 0.15;
                                    var jSize = 10 + Math.sin(i * 3.7) * 4;
                                    ctx.beginPath();
                                    ctx.ellipse(jx, jy, jSize, jSize * 0.5, 0, Math.PI, 0);
                                    ctx.fillStyle = 'rgba(100, 160, 200, ' + (blend * 0.04) + ')';
                                    ctx.fill();
                                }
                            } else {
                                // Twilight to sunlit
                                var blend = zone - 2;
                                var wG = ctx.createLinearGradient(0, 0, 0, h);
                                var tR = Math.round(10 + blend * 10), tGv = Math.round(40 + blend * 60), tBv = Math.round(70 + blend * 70);
                                wG.addColorStop(0, 'rgb(' + tR + ',' + tGv + ',' + tBv + ')');
                                wG.addColorStop(1, 'rgb(' + Math.round(5 + blend * 5) + ',' + Math.round(20 + blend * 30) + ',' + Math.round(40 + blend * 50) + ')');
                                ctx.fillStyle = wG;
                                ctx.fillRect(0, 0, w, h);
                                // Light rays returning
                                var rayOp = blend * 0.03;
                                for (var i = 0; i < 5; i++) {
                                    var rx = w * (0.2 + i * 0.15) + Math.sin(t * 0.3 + i) * 15;
                                    ctx.beginPath();
                                    ctx.moveTo(rx - 10, 0); ctx.lineTo(rx + 10, 0);
                                    ctx.lineTo(rx + 30, h); ctx.lineTo(rx - 5, h);
                                    ctx.closePath();
                                    ctx.fillStyle = 'rgba(100, 200, 255, ' + rayOp + ')';
                                    ctx.fill();
                                }
                            }
                            drawBubbles(ctx, w, h, t, 15, 35, 0.05);
                        }

                        else if (ph.name === 'breach') {
                            // Bursting through the surface
                            var rise = sm(0, 0.5, p);
                            var settle = sm(0.5, 1, p);
                            // Water to sky transition
                            var waterLevel = h * (0.5 - rise * 0.5 + settle * 0.05);
                            // Sky
                            var skyG = ctx.createLinearGradient(0, 0, 0, waterLevel);
                            skyG.addColorStop(0, '#1a3050');
                            skyG.addColorStop(1, '#305878');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, waterLevel);
                            // Water
                            var wG = ctx.createLinearGradient(0, waterLevel, 0, h);
                            wG.addColorStop(0, '#1a6080');
                            wG.addColorStop(1, '#0a3050');
                            ctx.fillStyle = wG;
                            ctx.fillRect(0, waterLevel, w, h - waterLevel);

                            drawWaves(ctx, w, h, t, waterLevel - 5, 6, 3, 'rgba(120, 200, 230, 0.06)');

                            // Spray/splash at the breach moment
                            if (p < 0.4) {
                                var splash = 1 - p / 0.4;
                                for (var i = 0; i < 12; i++) {
                                    var sx = cx + (Math.sin(i * 4.3 + 0.7) - 0.5) * 100 * splash;
                                    var sy = waterLevel - Math.abs(Math.sin(i * 2.9 + 0.3)) * 80 * splash;
                                    ctx.beginPath();
                                    ctx.arc(sx, sy, 2 * splash, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(200, 230, 255, ' + (splash * 0.12) + ')';
                                    ctx.fill();
                                }
                            }

                            // Sun
                            var sunX = w * 0.6, sunY = h * 0.15;
                            var sG = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 50);
                            sG.addColorStop(0, 'rgba(255, 230, 180, 0.25)');
                            sG.addColorStop(1, 'rgba(255, 200, 130, 0)');
                            ctx.fillStyle = sG;
                            ctx.fillRect(0, 0, w, h * 0.45);
                        }
                    }
                };
            })();

            // --- Genesis theme ---
            // Birth of a star system: dust  collapse  ignition  disc  planets  cooling  oceans
            themes.genesis = (function () {
                var PHASES = [
                    { name: 'dust', duration: 6 },
                    { name: 'collapse', duration: 6 },
                    { name: 'ignition', duration: 4 },
                    { name: 'disc', duration: 7 },
                    { name: 'planets', duration: 7 },
                    { name: 'cooling', duration: 6 },
                    { name: 'oceans', duration: 6 }
                ];
                var TOTAL = 0;
                for (var i = 0; i < PHASES.length; i++) TOTAL += PHASES[i].duration;

                // Dust motes
                var dustMotes = [];
                for (var i = 0; i < 150; i++) {
                    var angle = Math.random() * Math.PI * 2;
                    var dist = Math.random();
                    dustMotes.push({
                        angle: angle, dist: dist,
                        size: 0.5 + Math.random() * 2,
                        speed: 0.02 + Math.random() * 0.06,
                        bright: 0.2 + Math.random() * 0.6,
                        hue: 20 + Math.random() * 30,
                        radialDrift: (Math.random() - 0.5) * 0.01
                    });
                }

                // Orbiting planets
                var orbitPlanets = [];
                for (var i = 0; i < 5; i++) {
                    orbitPlanets.push({
                        dist: 0.2 + i * 0.15,
                        angle: Math.random() * Math.PI * 2,
                        speed: 0.15 / (1 + i * 0.6),
                        size: 4 + Math.sin(i * 2.7) * 2,
                        hue: [30, 180, 100, 340, 40][i],
                        sat: [40, 50, 40, 30, 45][i]
                    });
                }

                function getPhase(t) {
                    var ct = t % TOTAL, el = 0;
                    for (var i = 0; i < PHASES.length; i++) {
                        if (ct < el + PHASES[i].duration)
                            return { name: PHASES[i].name, progress: (ct - el) / PHASES[i].duration, time: ct - el };
                        el += PHASES[i].duration;
                    }
                    return { name: 'dust', progress: 0, time: 0 };
                }
                function sm(a, b, t) { t = Math.max(0, Math.min(1, (t - a) / (b - a))); return t * t * (3 - 2 * t); }

                return {
                    targetCount: 0,
                    spawn: function () { return { x: 0, y: 0 }; },
                    update: function () { return true; },
                    draw: function () {},
                    onActivate: function () {},

                    drawBackground: function (ctx, w, h) {
                        ctx.fillStyle = '#020204';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var ph = getPhase(t);
                        var p = ph.progress;
                        var cx = w * 0.5, cy = h * 0.5;
                        var minD = Math.min(w, h);

                        if (ph.name === 'dust') {
                            // Dark void with drifting cosmic dust
                            ctx.fillStyle = '#020204';
                            ctx.fillRect(0, 0, w, h);

                            // Background stars
                            for (var i = 0; i < 60; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 210, 230, 0.15)';
                                ctx.fill();
                            }

                            // Dust cloud  particles drift loosely
                            for (var i = 0; i < dustMotes.length; i++) {
                                var m = dustMotes[i];
                                var a = m.angle + t * m.speed * 0.3;
                                var d = m.dist * minD * 0.45;
                                var mx = cx + Math.cos(a) * d + Math.sin(t * 0.1 + i) * 10;
                                var my = cy + Math.sin(a) * d * 0.7 + Math.cos(t * 0.08 + i * 2) * 8;
                                ctx.beginPath();
                                ctx.arc(mx, my, m.size, 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + m.hue + ', 30%, 50%, ' + (m.bright * 0.04) + ')';
                                ctx.fill();
                            }

                            // Nebula glow patches
                            for (var i = 0; i < 5; i++) {
                                var nx = cx + Math.sin(i * 3.7 + 0.5) * minD * 0.2;
                                var ny = cy + Math.cos(i * 4.3 + 1.2) * minD * 0.15;
                                var nG = ctx.createRadialGradient(nx, ny, 0, nx, ny, 60);
                                nG.addColorStop(0, 'hsla(' + (20 + i * 15) + ', 40%, 40%, 0.02)');
                                nG.addColorStop(1, 'hsla(' + (20 + i * 15) + ', 40%, 30%, 0)');
                                ctx.fillStyle = nG;
                                ctx.fillRect(nx - 60, ny - 60, 120, 120);
                            }
                        }

                        else if (ph.name === 'collapse') {
                            // Dust cloud condenses, swirling inward
                            ctx.fillStyle = '#020204';
                            ctx.fillRect(0, 0, w, h);

                            var contract = sm(0, 1, p);
                            var spinUp = 1 + contract * 3;

                            for (var i = 0; i < 60; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 210, 230, 0.12)';
                                ctx.fill();
                            }

                            for (var i = 0; i < dustMotes.length; i++) {
                                var m = dustMotes[i];
                                var a = m.angle + t * m.speed * spinUp;
                                var d = m.dist * minD * 0.45 * (1 - contract * 0.7);
                                var mx = cx + Math.cos(a) * d;
                                var my = cy + Math.sin(a) * d * (0.7 - contract * 0.2);
                                var mBright = m.bright * (0.04 + contract * 0.06);
                                ctx.beginPath();
                                ctx.arc(mx, my, m.size * (1 - contract * 0.3), 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + m.hue + ', ' + (30 + contract * 20) + '%, 50%, ' + mBright + ')';
                                ctx.fill();
                            }

                            // Core brightening
                            var coreGlow = contract * 0.1;
                            var cG = ctx.createRadialGradient(cx, cy, 0, cx, cy, minD * 0.08);
                            cG.addColorStop(0, 'rgba(255, 200, 100, ' + coreGlow + ')');
                            cG.addColorStop(1, 'rgba(255, 150, 50, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, minD * 0.08, 0, Math.PI * 2);
                            ctx.fillStyle = cG;
                            ctx.fill();
                        }

                        else if (ph.name === 'ignition') {
                            // Protostar ignites  flash and intense light
                            ctx.fillStyle = '#020204';
                            ctx.fillRect(0, 0, w, h);

                            var flash = p < 0.3 ? p / 0.3 : 1;
                            var settle = sm(0.3, 1, p);

                            // Background stars dimmed by glare
                            for (var i = 0; i < 40; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 210, 230, ' + (0.1 * (1 - flash * 0.5)) + ')';
                                ctx.fill();
                            }

                            // Remaining dust spiralling tightly
                            for (var i = 0; i < dustMotes.length; i += 2) {
                                var m = dustMotes[i];
                                var a = m.angle + t * m.speed * 4;
                                var d = m.dist * minD * (0.12 + settle * 0.15);
                                var mx = cx + Math.cos(a) * d;
                                var my = cy + Math.sin(a) * d * 0.3;
                                ctx.beginPath();
                                ctx.arc(mx, my, m.size * 0.5, 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + m.hue + ', 50%, 55%, ' + (m.bright * 0.06) + ')';
                                ctx.fill();
                            }

                            // Bright star core
                            var coreR = minD * (0.03 + flash * 0.04 - settle * 0.02);
                            var coreOp = 0.15 + flash * 0.4 - settle * 0.2;
                            var cG = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR * 3);
                            cG.addColorStop(0, 'rgba(255, 255, 240, ' + coreOp + ')');
                            cG.addColorStop(0.3, 'rgba(255, 220, 150, ' + (coreOp * 0.6) + ')');
                            cG.addColorStop(1, 'rgba(255, 150, 50, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, coreR * 3, 0, Math.PI * 2);
                            ctx.fillStyle = cG;
                            ctx.fill();

                            // Initial flash
                            if (p < 0.15) {
                                var ff = 1 - p / 0.15;
                                ctx.fillStyle = 'rgba(255, 255, 230, ' + (ff * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'disc') {
                            // Spinning accretion disc with rocky debris
                            ctx.fillStyle = '#020204';
                            ctx.fillRect(0, 0, w, h);

                            // Stars
                            for (var i = 0; i < 50; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 210, 230, 0.1)';
                                ctx.fill();
                            }

                            // Disc  elliptical ring of dust
                            var discSpread = sm(0, 0.4, p);
                            for (var i = 0; i < dustMotes.length; i++) {
                                var m = dustMotes[i];
                                var a = m.angle + t * m.speed * 3;
                                var d = (0.08 + m.dist * 0.35 * (0.5 + discSpread * 0.5)) * minD;
                                var mx = cx + Math.cos(a) * d;
                                var my = cy + Math.sin(a) * d * 0.2;
                                ctx.beginPath();
                                ctx.arc(mx, my, m.size * 0.6, 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + m.hue + ', 40%, 50%, ' + (m.bright * 0.07) + ')';
                                ctx.fill();
                            }

                            // Central star
                            var cG = ctx.createRadialGradient(cx, cy, 0, cx, cy, minD * 0.06);
                            cG.addColorStop(0, 'rgba(255, 255, 230, 0.35)');
                            cG.addColorStop(0.4, 'rgba(255, 220, 150, 0.15)');
                            cG.addColorStop(1, 'rgba(255, 150, 50, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, minD * 0.06, 0, Math.PI * 2);
                            ctx.fillStyle = cG;
                            ctx.fill();

                            // Disc glow
                            ctx.save();
                            ctx.scale(1, 0.2);
                            var dG = ctx.createRadialGradient(cx, cy * 5, minD * 0.06, cx, cy * 5, minD * 0.4);
                            dG.addColorStop(0, 'rgba(255, 180, 80, 0.03)');
                            dG.addColorStop(0.5, 'rgba(200, 120, 50, 0.015)');
                            dG.addColorStop(1, 'rgba(150, 80, 30, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy * 5, minD * 0.4, 0, Math.PI * 2);
                            ctx.fillStyle = dG;
                            ctx.fill();
                            ctx.restore();
                        }

                        else if (ph.name === 'planets') {
                            // Planets coalescing and orbiting
                            ctx.fillStyle = '#020204';
                            ctx.fillRect(0, 0, w, h);

                            for (var i = 0; i < 50; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 210, 230, 0.1)';
                                ctx.fill();
                            }

                            // Fading disc debris
                            var discFade = 1 - sm(0, 0.5, p);
                            for (var i = 0; i < dustMotes.length; i += 3) {
                                var m = dustMotes[i];
                                var a = m.angle + t * m.speed * 2;
                                var d = (0.08 + m.dist * 0.35) * minD;
                                var mx = cx + Math.cos(a) * d;
                                var my = cy + Math.sin(a) * d * 0.25;
                                ctx.beginPath();
                                ctx.arc(mx, my, m.size * 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + m.hue + ', 30%, 45%, ' + (m.bright * 0.03 * discFade) + ')';
                                ctx.fill();
                            }

                            // Star
                            var cG = ctx.createRadialGradient(cx, cy, 0, cx, cy, minD * 0.05);
                            cG.addColorStop(0, 'rgba(255, 255, 230, 0.3)');
                            cG.addColorStop(0.5, 'rgba(255, 220, 150, 0.1)');
                            cG.addColorStop(1, 'rgba(255, 150, 50, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, minD * 0.05, 0, Math.PI * 2);
                            ctx.fillStyle = cG;
                            ctx.fill();

                            // Orbit lines and planets
                            var appear = sm(0, 0.4, p);
                            for (var i = 0; i < orbitPlanets.length; i++) {
                                var pl = orbitPlanets[i];
                                var od = pl.dist * minD * 0.5;
                                // Orbit path
                                ctx.beginPath();
                                ctx.ellipse(cx, cy, od, od * 0.25, 0, 0, Math.PI * 2);
                                ctx.strokeStyle = 'rgba(100, 120, 150, 0.03)';
                                ctx.lineWidth = 0.5;
                                ctx.stroke();

                                var pa = pl.angle + t * pl.speed;
                                var px = cx + Math.cos(pa) * od;
                                var py = cy + Math.sin(pa) * od * 0.25;
                                var pSize = pl.size * appear;
                                ctx.beginPath();
                                ctx.arc(px, py, pSize, 0, Math.PI * 2);
                                ctx.fillStyle = 'hsla(' + pl.hue + ', ' + pl.sat + '%, 45%, 0.4)';
                                ctx.fill();
                            }
                        }

                        else if (ph.name === 'cooling') {
                            // Zoom into one planet: molten surface cooling
                            var coolDown = sm(0, 1, p);
                            // Background: dark space with star
                            ctx.fillStyle = '#020204';
                            ctx.fillRect(0, 0, w, h);

                            // Planet fills the view
                            var pR = minD * 0.4;
                            // Molten  cooling gradient
                            var hotR = Math.round(180 - coolDown * 140);
                            var hotG = Math.round(60 - coolDown * 30);
                            var hotB = Math.round(10 + coolDown * 30);
                            var pG = ctx.createRadialGradient(cx - pR * 0.2, cy - pR * 0.2, pR * 0.1, cx, cy, pR);
                            pG.addColorStop(0, 'rgb(' + hotR + ',' + hotG + ',' + hotB + ')');
                            pG.addColorStop(0.7, 'rgb(' + Math.round(hotR * 0.6) + ',' + Math.round(hotG * 0.6) + ',' + Math.round(hotB * 0.6) + ')');
                            pG.addColorStop(1, 'rgb(' + Math.round(hotR * 0.3) + ',' + Math.round(hotG * 0.3) + ',' + hotB + ')');
                            ctx.beginPath();
                            ctx.arc(cx, cy, pR, 0, Math.PI * 2);
                            ctx.fillStyle = pG;
                            ctx.fill();

                            // Lava cracks fading
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(cx, cy, pR, 0, Math.PI * 2);
                            ctx.clip();
                            var crackOp = (1 - coolDown) * 0.15;
                            for (var i = 0; i < 15; i++) {
                                ctx.beginPath();
                                var lx = cx + Math.sin(i * 5.3) * pR * 0.7;
                                var ly = cy + Math.cos(i * 4.1) * pR * 0.7;
                                ctx.moveTo(lx, ly);
                                for (var s = 0; s < 4; s++) {
                                    lx += Math.sin(i * 3 + s * 2.7) * 20;
                                    ly += Math.cos(i * 2 + s * 3.1) * 20;
                                    ctx.lineTo(lx, ly);
                                }
                                ctx.strokeStyle = 'rgba(255, 150, 30, ' + crackOp + ')';
                                ctx.lineWidth = 2 * (1 - coolDown);
                                ctx.stroke();
                            }
                            ctx.restore();

                            // Atmosphere forming
                            if (coolDown > 0.5) {
                                var atmosOp = (coolDown - 0.5) * 0.1;
                                var aG = ctx.createRadialGradient(cx, cy, pR * 0.9, cx, cy, pR * 1.1);
                                aG.addColorStop(0, 'rgba(100, 150, 200, 0)');
                                aG.addColorStop(0.5, 'rgba(100, 150, 200, ' + atmosOp + ')');
                                aG.addColorStop(1, 'rgba(100, 150, 200, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy, pR * 1.1, 0, Math.PI * 2);
                                ctx.fillStyle = aG;
                                ctx.fill();
                            }
                        }

                        else if (ph.name === 'oceans') {
                            // First rain, oceans forming
                            var oceanRise = sm(0, 1, p);
                            ctx.fillStyle = '#020204';
                            ctx.fillRect(0, 0, w, h);

                            var pR = minD * 0.4;
                            // Planet surface now dark rock + blue water
                            var rockR = Math.round(40 + (1 - oceanRise) * 40);
                            var rockG = Math.round(30 + oceanRise * 20);
                            var rockB = Math.round(40 + oceanRise * 60);
                            var pG = ctx.createRadialGradient(cx - pR * 0.2, cy - pR * 0.2, pR * 0.1, cx, cy, pR);
                            pG.addColorStop(0, 'rgb(' + rockR + ',' + rockG + ',' + rockB + ')');
                            pG.addColorStop(1, 'rgb(' + Math.round(rockR * 0.5) + ',' + Math.round(rockG * 0.5) + ',' + Math.round(rockB * 0.5) + ')');
                            ctx.beginPath();
                            ctx.arc(cx, cy, pR, 0, Math.PI * 2);
                            ctx.fillStyle = pG;
                            ctx.fill();

                            // Ocean patches forming
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(cx, cy, pR, 0, Math.PI * 2);
                            ctx.clip();
                            for (var i = 0; i < 8; i++) {
                                var ox = cx + Math.sin(i * 4.7 + 0.5) * pR * 0.5;
                                var oy = cy + Math.cos(i * 3.3 + 1.2) * pR * 0.5;
                                var oSize = (15 + Math.sin(i * 2.9) * 10) * oceanRise;
                                ctx.beginPath();
                                ctx.ellipse(ox, oy, oSize, oSize * 0.7, Math.sin(i) * 0.5, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(30, 80, 140, ' + (oceanRise * 0.12) + ')';
                                ctx.fill();
                            }

                            // Rain streaks (early phase)
                            if (p < 0.6) {
                                var rainOp = (1 - p / 0.6) * 0.04;
                                for (var i = 0; i < 30; i++) {
                                    var rx = cx + (Math.sin(i * 6.7 + t * 0.1) - 0.5) * pR * 1.5;
                                    var ry = cy + (Math.cos(i * 4.3 + t * 0.15) - 0.5) * pR * 1.5;
                                    ctx.beginPath();
                                    ctx.moveTo(rx, ry);
                                    ctx.lineTo(rx + 1, ry + 6);
                                    ctx.strokeStyle = 'rgba(150, 200, 230, ' + rainOp + ')';
                                    ctx.lineWidth = 0.5;
                                    ctx.stroke();
                                }
                            }
                            ctx.restore();

                            // Atmosphere
                            var aG = ctx.createRadialGradient(cx, cy, pR * 0.9, cx, cy, pR * 1.12);
                            aG.addColorStop(0, 'rgba(80, 140, 200, 0)');
                            aG.addColorStop(0.5, 'rgba(80, 140, 200, ' + (0.06 + oceanRise * 0.04) + ')');
                            aG.addColorStop(1, 'rgba(80, 140, 200, 0)');
                            ctx.beginPath();
                            ctx.arc(cx, cy, pR * 1.12, 0, Math.PI * 2);
                            ctx.fillStyle = aG;
                            ctx.fill();

                            // Cloud wisps
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(cx, cy, pR, 0, Math.PI * 2);
                            ctx.clip();
                            for (var i = 0; i < 6; i++) {
                                var ca = t * 0.04 + i * Math.PI / 3;
                                var ccx = cx + Math.cos(ca) * pR * 0.4;
                                var ccy = cy + Math.sin(ca) * pR * 0.3;
                                ctx.beginPath();
                                ctx.ellipse(ccx, ccy, 25, 6, ca, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 220, 240, ' + (oceanRise * 0.04) + ')';
                                ctx.fill();
                            }
                            ctx.restore();
                        }
                    }
                };
            })();

            // --- Spelunker theme ---
            // Cave expedition: forest  cave mouth  stalactites  crystal cavern  river  waterfall  underwater  daylight
            themes.spelunker = (function () {
                var PHASES = [
                    { name: 'forest', duration: 5 },
                    { name: 'entrance', duration: 5 },
                    { name: 'stalactites', duration: 6 },
                    { name: 'crystal', duration: 7 },
                    { name: 'river', duration: 6 },
                    { name: 'waterfall', duration: 5 },
                    { name: 'underwater', duration: 5 },
                    { name: 'emerge', duration: 5 }
                ];
                var TOTAL = 0;
                for (var i = 0; i < PHASES.length; i++) TOTAL += PHASES[i].duration;

                // Crystal configs
                var crystals = [];
                for (var i = 0; i < 25; i++) {
                    crystals.push({
                        x: Math.random(), y: 0.2 + Math.random() * 0.6,
                        angle: -Math.PI * 0.3 + Math.random() * Math.PI * 0.6,
                        len: 20 + Math.random() * 40,
                        width: 3 + Math.random() * 6,
                        hue: 180 + Math.random() * 80,
                        bright: 0.3 + Math.random() * 0.5
                    });
                }

                function getPhase(t) {
                    var ct = t % TOTAL, el = 0;
                    for (var i = 0; i < PHASES.length; i++) {
                        if (ct < el + PHASES[i].duration)
                            return { name: PHASES[i].name, progress: (ct - el) / PHASES[i].duration, time: ct - el };
                        el += PHASES[i].duration;
                    }
                    return { name: 'forest', progress: 0, time: 0 };
                }
                function sm(a, b, t) { t = Math.max(0, Math.min(1, (t - a) / (b - a))); return t * t * (3 - 2 * t); }

                function drawStalactites(ctx, w, h, t, op) {
                    for (var i = 0; i < 15; i++) {
                        var sx = (Math.sin(i * 5.7 + 0.3) * 0.5 + 0.5) * w;
                        var sLen = 30 + Math.sin(i * 3.1) * 20;
                        var drip = Math.sin(t * 0.5 + i * 2.3) * 0.5 + 0.5;
                        ctx.beginPath();
                        ctx.moveTo(sx - 4, 0);
                        ctx.lineTo(sx, sLen);
                        ctx.lineTo(sx + 4, 0);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(120, 110, 90, ' + op + ')';
                        ctx.fill();
                        // Drip
                        if (drip > 0.8) {
                            var dy = sLen + (drip - 0.8) * 100;
                            ctx.beginPath();
                            ctx.arc(sx, dy, 1.5, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(150, 180, 200, ' + (op * 0.5) + ')';
                            ctx.fill();
                        }
                    }
                    // Stalagmites from below
                    for (var i = 0; i < 10; i++) {
                        var mx = (Math.sin(i * 4.3 + 1.7) * 0.5 + 0.5) * w;
                        var mLen = 15 + Math.sin(i * 2.9) * 10;
                        ctx.beginPath();
                        ctx.moveTo(mx - 5, h);
                        ctx.lineTo(mx, h - mLen);
                        ctx.lineTo(mx + 5, h);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(100, 95, 75, ' + op + ')';
                        ctx.fill();
                    }
                }

                return {
                    targetCount: 0,
                    spawn: function () { return { x: 0, y: 0 }; },
                    update: function () { return true; },
                    draw: function () {},
                    onActivate: function () {},

                    drawBackground: function (ctx, w, h) {
                        ctx.fillStyle = '#0a0a08';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var ph = getPhase(t);
                        var p = ph.progress;
                        var cx = w * 0.5, cy = h * 0.5;

                        if (ph.name === 'forest') {
                            // Forest clearing with dark cave mouth ahead
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, '#1a3020');
                            skyG.addColorStop(1, '#2a5030');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Forest canopy
                            var groundG = ctx.createLinearGradient(0, h * 0.5, 0, h);
                            groundG.addColorStop(0, '#1a3518');
                            groundG.addColorStop(1, '#0a1a0a');
                            ctx.fillStyle = groundG;
                            ctx.fillRect(0, h * 0.5, w, h * 0.5);

                            // Tree trunks
                            for (var i = 0; i < 8; i++) {
                                var tx = w * (0.05 + i * 0.13) + Math.sin(i * 3.7) * 15;
                                var tw = 6 + Math.sin(i * 2.3) * 3;
                                ctx.fillStyle = 'rgba(40, 30, 20, 0.15)';
                                ctx.fillRect(tx - tw / 2, h * 0.2, tw, h * 0.8);
                                // Foliage
                                ctx.beginPath();
                                ctx.arc(tx, h * 0.25 + Math.sin(i * 4.1) * 15, 20 + Math.sin(i * 2.7) * 10, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(30, 60, 25, 0.1)';
                                ctx.fill();
                            }

                            // Cave mouth  dark opening in the centre
                            var caveW = w * 0.25 + sm(0.5, 1, p) * w * 0.15;
                            var caveH = h * 0.4 + sm(0.5, 1, p) * h * 0.1;
                            ctx.beginPath();
                            ctx.ellipse(cx, h * 0.6, caveW, caveH, 0, 0, Math.PI * 2);
                            ctx.fillStyle = '#050505';
                            ctx.fill();

                            // Light filtering through trees
                            for (var i = 0; i < 4; i++) {
                                var lx = w * (0.2 + i * 0.2);
                                ctx.beginPath();
                                ctx.moveTo(lx - 5, 0); ctx.lineTo(lx + 5, 0);
                                ctx.lineTo(lx + 20, h * 0.6); ctx.lineTo(lx - 10, h * 0.6);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(150, 200, 100, 0.015)';
                                ctx.fill();
                            }

                            // Darken as we approach
                            if (p > 0.6) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.6) / 0.4 * 0.7) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'entrance') {
                            // Entering cave, daylight shrinking behind
                            var dark = sm(0, 1, p);
                            ctx.fillStyle = '#060604';
                            ctx.fillRect(0, 0, w, h);

                            // Daylight opening behind us (shrinking oval of light)
                            var lightR = (1 - dark) * Math.min(w, h) * 0.35;
                            if (lightR > 5) {
                                var lG = ctx.createRadialGradient(cx, cy, 0, cx, cy, lightR);
                                lG.addColorStop(0, 'rgba(180, 200, 160, ' + (0.15 * (1 - dark)) + ')');
                                lG.addColorStop(0.5, 'rgba(100, 130, 80, ' + (0.05 * (1 - dark)) + ')');
                                lG.addColorStop(1, 'rgba(50, 60, 40, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy, lightR, 0, Math.PI * 2);
                                ctx.fillStyle = lG;
                                ctx.fill();
                            }

                            // Rough cave walls hinted
                            ctx.strokeStyle = 'rgba(80, 70, 55, ' + (0.03 + dark * 0.02) + ')';
                            ctx.lineWidth = 2;
                            for (var side = -1; side <= 1; side += 2) {
                                ctx.beginPath();
                                for (var y = 0; y <= h; y += 4) {
                                    var wx = (side === -1 ? w * 0.1 : w * 0.9) + Math.sin(y * 0.02 + t * 0.1) * 15 * side;
                                    if (y === 0) ctx.moveTo(wx, y); else ctx.lineTo(wx, y);
                                }
                                ctx.stroke();
                            }

                            // Faint headlamp cone
                            var lampG = ctx.createRadialGradient(cx, cy, 0, cx, cy * 0.6, h * 0.6);
                            lampG.addColorStop(0, 'rgba(255, 240, 200, ' + (dark * 0.04) + ')');
                            lampG.addColorStop(1, 'rgba(255, 220, 150, 0)');
                            ctx.fillStyle = lampG;
                            ctx.fillRect(0, 0, w, h);
                        }

                        else if (ph.name === 'stalactites') {
                            // Narrow passage with formations
                            ctx.fillStyle = '#080806';
                            ctx.fillRect(0, 0, w, h);

                            // Headlamp light
                            var lampG = ctx.createRadialGradient(cx, cy * 0.7, 0, cx, cy * 0.7, h * 0.5);
                            lampG.addColorStop(0, 'rgba(255, 240, 200, 0.05)');
                            lampG.addColorStop(1, 'rgba(255, 220, 150, 0)');
                            ctx.fillStyle = lampG;
                            ctx.fillRect(0, 0, w, h);

                            // Scrolling stalactites and stalagmites
                            ctx.save();
                            ctx.translate(0, -(ph.time * 15) % 60);
                            drawStalactites(ctx, w, h + 60, t, 0.12);
                            ctx.restore();

                            // Dripping water sounds (visual: drops)
                            for (var i = 0; i < 8; i++) {
                                var dx = (Math.sin(i * 6.7 + 0.3) * 0.5 + 0.5) * w;
                                var dy = (t * 40 + i * h * 0.15) % h;
                                ctx.beginPath();
                                ctx.arc(dx, dy, 1, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(150, 180, 200, 0.06)';
                                ctx.fill();
                            }

                            // Cave walls narrowing and widening
                            var wallOp = 0.2;
                            for (var side = -1; side <= 1; side += 2) {
                                ctx.beginPath();
                                ctx.moveTo(side === -1 ? 0 : w, 0);
                                for (var y = 0; y <= h; y += 3) {
                                    var offset = w * (0.15 + Math.sin(y * 0.01 + ph.time * 0.3) * 0.05);
                                    var wx = side === -1 ? offset : w - offset;
                                    ctx.lineTo(wx, y);
                                }
                                ctx.lineTo(side === -1 ? 0 : w, h);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(50, 45, 35, ' + wallOp + ')';
                                ctx.fill();
                            }
                        }

                        else if (ph.name === 'crystal') {
                            // Vast crystal cavern glittering
                            ctx.fillStyle = '#060810';
                            ctx.fillRect(0, 0, w, h);

                            // Ambient glow from crystals
                            var ambG = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.min(w, h) * 0.5);
                            ambG.addColorStop(0, 'rgba(100, 160, 200, 0.03)');
                            ambG.addColorStop(1, 'rgba(60, 100, 140, 0)');
                            ctx.fillStyle = ambG;
                            ctx.fillRect(0, 0, w, h);

                            // Crystal formations
                            for (var i = 0; i < crystals.length; i++) {
                                var c = crystals[i];
                                var cxp = c.x * w, cyp = c.y * h;
                                var shimmer = Math.sin(t * 1.5 + i * 2.7) * 0.5 + 0.5;
                                var op = c.bright * (0.06 + shimmer * 0.08);

                                ctx.save();
                                ctx.translate(cxp, cyp);
                                ctx.rotate(c.angle);
                                // Crystal body
                                ctx.beginPath();
                                ctx.moveTo(-c.width / 2, 0);
                                ctx.lineTo(0, -c.len);
                                ctx.lineTo(c.width / 2, 0);
                                ctx.closePath();
                                ctx.fillStyle = 'hsla(' + c.hue + ', 50%, 60%, ' + op + ')';
                                ctx.fill();
                                // Bright edge
                                ctx.beginPath();
                                ctx.moveTo(-c.width / 2, 0);
                                ctx.lineTo(0, -c.len);
                                ctx.strokeStyle = 'hsla(' + c.hue + ', 60%, 75%, ' + (op * 0.8) + ')';
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                                ctx.restore();

                                // Sparkle at tip
                                if (shimmer > 0.8) {
                                    var sparkX = cxp + Math.cos(c.angle - Math.PI / 2) * c.len;
                                    var sparkY = cyp + Math.sin(c.angle - Math.PI / 2) * c.len;
                                    var spG = ctx.createRadialGradient(sparkX, sparkY, 0, sparkX, sparkY, 8);
                                    spG.addColorStop(0, 'hsla(' + c.hue + ', 70%, 80%, ' + ((shimmer - 0.8) * 0.5) + ')');
                                    spG.addColorStop(1, 'hsla(' + c.hue + ', 70%, 60%, 0)');
                                    ctx.beginPath();
                                    ctx.arc(sparkX, sparkY, 8, 0, Math.PI * 2);
                                    ctx.fillStyle = spG;
                                    ctx.fill();
                                }
                            }

                            // Cave ceiling and floor
                            ctx.fillStyle = 'rgba(30, 28, 35, 0.25)';
                            ctx.fillRect(0, 0, w, h * 0.05);
                            ctx.fillRect(0, h * 0.95, w, h * 0.05);
                        }

                        else if (ph.name === 'river') {
                            // Underground river carrying us forward
                            ctx.fillStyle = '#060808';
                            ctx.fillRect(0, 0, w, h);

                            // Water surface
                            var waterY = h * 0.55;
                            var waterG = ctx.createLinearGradient(0, waterY, 0, h);
                            waterG.addColorStop(0, 'rgba(20, 50, 60, 0.4)');
                            waterG.addColorStop(1, 'rgba(10, 30, 40, 0.5)');
                            ctx.fillStyle = waterG;
                            ctx.fillRect(0, waterY, w, h - waterY);

                            // Water flow lines
                            for (var i = 0; i < 12; i++) {
                                var wy = waterY + 5 + i * ((h - waterY) / 12);
                                ctx.beginPath();
                                for (var x = 0; x <= w; x += 4) {
                                    var yOff = Math.sin(x * 0.01 + t * 1.5 + i * 0.7) * 3;
                                    if (x === 0) ctx.moveTo(x, wy + yOff); else ctx.lineTo(x, wy + yOff);
                                }
                                ctx.strokeStyle = 'rgba(80, 130, 150, 0.03)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }

                            // Cave ceiling with rough texture
                            var ceilG = ctx.createLinearGradient(0, 0, 0, h * 0.3);
                            ceilG.addColorStop(0, 'rgba(40, 35, 30, 0.4)');
                            ceilG.addColorStop(1, 'rgba(30, 25, 20, 0)');
                            ctx.fillStyle = ceilG;
                            ctx.fillRect(0, 0, w, h * 0.3);

                            // Reflected light on ceiling from water
                            for (var i = 0; i < 10; i++) {
                                var rx = (Math.sin(i * 5.3 + t * 0.4) * 0.5 + 0.5) * w;
                                var ry = h * 0.1 + Math.sin(i * 3.7 + t * 0.6) * h * 0.08;
                                var rSize = 15 + Math.sin(t * 0.8 + i * 2) * 8;
                                ctx.beginPath();
                                ctx.ellipse(rx, ry, rSize, rSize * 0.3, 0, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(60, 120, 140, 0.015)';
                                ctx.fill();
                            }

                            // Passage ahead getting brighter (approaching waterfall)
                            if (p > 0.6) {
                                var ahead = (p - 0.6) / 0.4;
                                var aG = ctx.createRadialGradient(cx, cy, 0, cx, cy, h * 0.3);
                                aG.addColorStop(0, 'rgba(180, 200, 220, ' + (ahead * 0.05) + ')');
                                aG.addColorStop(1, 'rgba(100, 140, 160, 0)');
                                ctx.fillStyle = aG;
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'waterfall') {
                            // Plunging down a waterfall in a cathedral chamber
                            ctx.fillStyle = '#080a0c';
                            ctx.fillRect(0, 0, w, h);

                            // Vast chamber walls
                            for (var side = -1; side <= 1; side += 2) {
                                var wallX = side === -1 ? w * 0.05 : w * 0.95;
                                ctx.beginPath();
                                for (var y = 0; y <= h; y += 3) {
                                    ctx.lineTo(wallX + Math.sin(y * 0.015 + 0.5) * 10 * side, y);
                                }
                                ctx.strokeStyle = 'rgba(70, 65, 55, 0.06)';
                                ctx.lineWidth = 3;
                                ctx.stroke();
                            }

                            // Waterfall streams
                            for (var i = 0; i < 6; i++) {
                                var fx = cx + (i - 2.5) * 20;
                                ctx.beginPath();
                                for (var y = 0; y <= h; y += 3) {
                                    var wobble = Math.sin(y * 0.02 + t * 3 + i * 1.5) * (3 + y * 0.005);
                                    if (y === 0) ctx.moveTo(fx + wobble, y); else ctx.lineTo(fx + wobble, y);
                                }
                                ctx.strokeStyle = 'rgba(160, 200, 220, 0.04)';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                            }

                            // Mist/spray
                            for (var i = 0; i < 15; i++) {
                                var mx = cx + (Math.sin(i * 4.7 + t * 0.5) - 0.5) * w * 0.4;
                                var my = (t * 60 + i * h * 0.08) % h;
                                var mSize = 15 + Math.sin(i * 2.9 + t) * 8;
                                ctx.beginPath();
                                ctx.arc(mx, my, mSize, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(180, 210, 230, 0.012)';
                                ctx.fill();
                            }

                            // Pool glow at bottom
                            var poolG = ctx.createRadialGradient(cx, h, 0, cx, h, h * 0.3);
                            poolG.addColorStop(0, 'rgba(80, 150, 180, 0.06)');
                            poolG.addColorStop(1, 'rgba(40, 80, 100, 0)');
                            ctx.fillStyle = poolG;
                            ctx.fillRect(0, h * 0.7, w, h * 0.3);
                        }

                        else if (ph.name === 'underwater') {
                            // Underwater passage with filtered light
                            var lightUp = sm(0, 1, p);
                            var wG = ctx.createLinearGradient(0, 0, 0, h);
                            var tBright = Math.round(15 + lightUp * 15);
                            wG.addColorStop(0, 'rgb(8,' + tBright + ',' + Math.round(tBright * 1.3) + ')');
                            wG.addColorStop(1, 'rgb(5,' + Math.round(tBright * 0.7) + ',' + Math.round(tBright * 1.1) + ')');
                            ctx.fillStyle = wG;
                            ctx.fillRect(0, 0, w, h);

                            // Light rays from ahead
                            var rayOp = lightUp * 0.03;
                            for (var i = 0; i < 5; i++) {
                                var rx = cx + (i - 2) * w * 0.12;
                                ctx.beginPath();
                                ctx.moveTo(rx - 8, 0); ctx.lineTo(rx + 8, 0);
                                ctx.lineTo(rx + 25, h); ctx.lineTo(rx - 15, h);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(100, 200, 220, ' + rayOp + ')';
                                ctx.fill();
                            }

                            // Bubbles
                            for (var i = 0; i < 15; i++) {
                                var bx = (Math.sin(i * 5.3 + t * 0.1) * 0.5 + 0.5) * w;
                                var by = h - ((t * 30 + i * h * 0.08) % (h * 1.1));
                                ctx.beginPath();
                                ctx.arc(bx + Math.sin(t + i * 2) * 5, by, 1.5 + Math.sin(i * 2.7) * 0.8, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(180, 220, 240, 0.06)';
                                ctx.fill();
                            }

                            // Rock passage edges
                            for (var side = -1; side <= 1; side += 2) {
                                ctx.beginPath();
                                var baseX = side === -1 ? w * 0.15 : w * 0.85;
                                for (var y = 0; y <= h; y += 3) {
                                    ctx.lineTo(baseX + Math.sin(y * 0.015 + 1.3) * 15 * side, y);
                                }
                                ctx.lineTo(side === -1 ? 0 : w, h);
                                ctx.lineTo(side === -1 ? 0 : w, 0);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(20, 25, 22, 0.3)';
                                ctx.fill();
                            }

                            // Bright exit ahead
                            if (p > 0.7) {
                                var exitGlow = (p - 0.7) / 0.3;
                                ctx.fillStyle = 'rgba(200, 230, 240, ' + (exitGlow * 0.15) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'emerge') {
                            // Bursting out of cliffside into bright daylight
                            var bright = sm(0, 0.5, p);
                            var settle = sm(0.5, 1, p);
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            var skyBright = Math.round(30 + bright * 60);
                            skyG.addColorStop(0, 'rgb(' + Math.round(skyBright * 0.4) + ',' + Math.round(skyBright * 0.7) + ',' + skyBright + ')');
                            skyG.addColorStop(0.6, 'rgb(' + Math.round(skyBright * 0.5) + ',' + Math.round(skyBright * 0.8) + ',' + Math.round(skyBright * 1.1) + ')');
                            skyG.addColorStop(1, 'rgb(' + Math.round(skyBright * 0.3) + ',' + Math.round(skyBright * 0.5) + ',' + Math.round(skyBright * 0.3) + ')');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Cliff face receding
                            var cliffFade = 1 - bright;
                            if (cliffFade > 0.05) {
                                for (var side = -1; side <= 1; side += 2) {
                                    var edgeX = side === -1 ? w * (0.3 - bright * 0.3) : w * (0.7 + bright * 0.3);
                                    ctx.beginPath();
                                    for (var y = 0; y <= h; y += 3) {
                                        ctx.lineTo(edgeX + Math.sin(y * 0.02 + 0.7) * 10 * side, y);
                                    }
                                    ctx.lineTo(side === -1 ? 0 : w, h);
                                    ctx.lineTo(side === -1 ? 0 : w, 0);
                                    ctx.closePath();
                                    ctx.fillStyle = 'rgba(60, 55, 45, ' + (cliffFade * 0.3) + ')';
                                    ctx.fill();
                                }
                            }

                            // Waterfall pouring out of the cliff
                            if (cliffFade > 0.1) {
                                for (var i = 0; i < 3; i++) {
                                    ctx.beginPath();
                                    var fx = cx + (i - 1) * 15;
                                    for (var y = h * 0.4; y <= h; y += 3) {
                                        ctx.lineTo(fx + Math.sin(y * 0.03 + t * 2 + i) * 4, y);
                                    }
                                    ctx.strokeStyle = 'rgba(180, 210, 230, ' + (cliffFade * 0.04) + ')';
                                    ctx.lineWidth = 2;
                                    ctx.stroke();
                                }
                            }

                            // Sun
                            var sunX = w * 0.65, sunY = h * 0.2;
                            var sG = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 80);
                            sG.addColorStop(0, 'rgba(255, 250, 220, ' + (bright * 0.2) + ')');
                            sG.addColorStop(1, 'rgba(255, 200, 100, 0)');
                            ctx.fillStyle = sG;
                            ctx.fillRect(0, 0, w, h);

                            // Valley/landscape in the distance
                            if (bright > 0.3) {
                                var viewOp = (bright - 0.3) / 0.7;
                                // Distant hills
                                ctx.beginPath();
                                ctx.moveTo(0, h);
                                for (var x = 0; x <= w; x += 5) {
                                    var hy = h * 0.7 + Math.sin(x * 0.005 + 0.5) * 30 + Math.sin(x * 0.012 + 2) * 15;
                                    ctx.lineTo(x, hy);
                                }
                                ctx.lineTo(w, h);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(40, 70, 35, ' + (viewOp * 0.15) + ')';
                                ctx.fill();
                            }

                            // Fade to dark at end (loop to forest)
                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.5) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }
                    }
                };
            })();

            // --- Freefall theme ---
            // Orbital skydive: orbit  leap  entry  stratosphere  clouds  parachute  drift  land
            themes.freefall = (function () {
                var PHASES = [
                    { name: 'orbit', duration: 5 },
                    { name: 'leap', duration: 4 },
                    { name: 'entry', duration: 5 },
                    { name: 'strato', duration: 6 },
                    { name: 'clouds', duration: 5 },
                    { name: 'chute', duration: 4 },
                    { name: 'drift', duration: 7 },
                    { name: 'land', duration: 4 }
                ];
                var TOTAL = 0;
                for (var i = 0; i < PHASES.length; i++) TOTAL += PHASES[i].duration;

                function getPhase(t) {
                    var ct = t % TOTAL, el = 0;
                    for (var i = 0; i < PHASES.length; i++) {
                        if (ct < el + PHASES[i].duration)
                            return { name: PHASES[i].name, progress: (ct - el) / PHASES[i].duration, time: ct - el };
                        el += PHASES[i].duration;
                    }
                    return { name: 'orbit', progress: 0, time: 0 };
                }
                function sm(a, b, t) { t = Math.max(0, Math.min(1, (t - a) / (b - a))); return t * t * (3 - 2 * t); }

                function drawEarthCurve(ctx, w, h, curveY, colors) {
                    ctx.beginPath();
                    ctx.moveTo(-w * 0.3, h + 50);
                    ctx.quadraticCurveTo(w * 0.5, curveY, w * 1.3, h + 50);
                    ctx.closePath();
                    var eG = ctx.createLinearGradient(0, curveY, 0, h + 50);
                    eG.addColorStop(0, colors[0]);
                    eG.addColorStop(0.4, colors[1]);
                    eG.addColorStop(1, colors[2]);
                    ctx.fillStyle = eG;
                    ctx.fill();
                }

                return {
                    targetCount: 0,
                    spawn: function () { return { x: 0, y: 0 }; },
                    update: function () { return true; },
                    draw: function () {},
                    onActivate: function () {},

                    drawBackground: function (ctx, w, h) {
                        ctx.fillStyle = '#020206';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var ph = getPhase(t);
                        var p = ph.progress;
                        var cx = w * 0.5, cy = h * 0.5;

                        if (ph.name === 'orbit') {
                            // Floating in orbit: stars, Earth below
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);

                            for (var i = 0; i < 100; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h * 0.7;
                                var tw = Math.sin(t * 0.5 + i * 2.3) * 0.5 + 0.5;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4 + tw * 0.3, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(220, 230, 255, ' + (0.1 + tw * 0.15) + ')';
                                ctx.fill();
                            }

                            // Earth's curved limb at bottom
                            var curveY = h * 0.75;
                            drawEarthCurve(ctx, w, h, curveY, ['#1a4080', '#0a2850', '#061830']);

                            // Atmosphere glow
                            var aG = ctx.createLinearGradient(0, curveY - 15, 0, curveY + 5);
                            aG.addColorStop(0, 'rgba(100, 180, 255, 0)');
                            aG.addColorStop(0.5, 'rgba(100, 180, 255, 0.08)');
                            aG.addColorStop(1, 'rgba(100, 180, 255, 0)');
                            ctx.fillStyle = aG;
                            ctx.fillRect(0, curveY - 15, w, 20);

                            // Station hint (small structure)
                            var stX = w * 0.7, stY = h * 0.35;
                            ctx.strokeStyle = 'rgba(200, 210, 220, 0.08)';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(stX - 8, stY - 3, 16, 6);
                            ctx.beginPath();
                            ctx.moveTo(stX - 20, stY); ctx.lineTo(stX + 20, stY);
                            ctx.stroke();
                        }

                        else if (ph.name === 'leap') {
                            // Leaping into void, station receding
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);

                            for (var i = 0; i < 80; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(220, 230, 255, 0.12)';
                                ctx.fill();
                            }

                            // Earth growing below
                            var curveY = h * (0.75 - p * 0.2);
                            drawEarthCurve(ctx, w, h, curveY, ['#1a4080', '#0a2850', '#061830']);

                            // Atmosphere
                            var aG = ctx.createLinearGradient(0, curveY - 15, 0, curveY + 5);
                            aG.addColorStop(0, 'rgba(100, 180, 255, 0)');
                            aG.addColorStop(0.5, 'rgba(100, 180, 255, 0.1)');
                            aG.addColorStop(1, 'rgba(100, 180, 255, 0)');
                            ctx.fillStyle = aG;
                            ctx.fillRect(0, curveY - 15, w, 20);

                            // Station shrinking above
                            var stScale = 1 - p;
                            var stX = cx + p * w * 0.2, stY = h * 0.2 - p * h * 0.1;
                            ctx.strokeStyle = 'rgba(200, 210, 220, ' + (stScale * 0.06) + ')';
                            ctx.lineWidth = stScale;
                            ctx.strokeRect(stX - 6 * stScale, stY - 2 * stScale, 12 * stScale, 4 * stScale);
                        }

                        else if (ph.name === 'entry') {
                            // Atmospheric entry with orange heat shimmer
                            var heat = p < 0.6 ? p / 0.6 : 1 - (p - 0.6) / 0.4;
                            var skyDark = sm(0, 1, p);
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            skyG.addColorStop(0, '#020206');
                            skyG.addColorStop(0.5, 'rgb(' + Math.round(2 + skyDark * 5) + ',' + Math.round(2 + skyDark * 10) + ',' + Math.round(6 + skyDark * 25) + ')');
                            skyG.addColorStop(1, 'rgb(' + Math.round(5 + skyDark * 15) + ',' + Math.round(5 + skyDark * 25) + ',' + Math.round(10 + skyDark * 50) + ')');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Stars fading
                            var starFade = 1 - skyDark;
                            for (var i = 0; i < 50; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h * 0.5;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(220, 230, 255, ' + (starFade * 0.1) + ')';
                                ctx.fill();
                            }

                            // Heat shimmer
                            if (heat > 0.1) {
                                // Orange-red glow from edges
                                var hG = ctx.createRadialGradient(cx, cy * 0.5, 0, cx, cy * 0.5, Math.max(w, h) * 0.6);
                                hG.addColorStop(0, 'rgba(255, 150, 50, 0)');
                                hG.addColorStop(0.7, 'rgba(255, 100, 30, ' + (heat * 0.06) + ')');
                                hG.addColorStop(1, 'rgba(255, 60, 10, ' + (heat * 0.1) + ')');
                                ctx.fillStyle = hG;
                                ctx.fillRect(0, 0, w, h);

                                // Streaks of plasma
                                for (var i = 0; i < 8; i++) {
                                    var sx = (Math.sin(i * 4.3 + t * 0.5) * 0.5 + 0.5) * w;
                                    ctx.beginPath();
                                    ctx.moveTo(sx, 0);
                                    ctx.lineTo(sx + Math.sin(i * 2.7) * 20, h);
                                    ctx.strokeStyle = 'rgba(255, 180, 80, ' + (heat * 0.03) + ')';
                                    ctx.lineWidth = 1.5;
                                    ctx.stroke();
                                }
                            }
                        }

                        else if (ph.name === 'strato') {
                            // Freefall through stratosphere, bright blue sky
                            var skyBright = sm(0, 0.5, p);
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            var topB = Math.round(30 + skyBright * 80);
                            skyG.addColorStop(0, 'rgb(' + Math.round(topB * 0.15) + ',' + Math.round(topB * 0.4) + ',' + topB + ')');
                            skyG.addColorStop(1, 'rgb(' + Math.round(topB * 0.3) + ',' + Math.round(topB * 0.6) + ',' + Math.round(topB * 1.2) + ')');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Wind streaks rushing upward (we're falling)
                            for (var i = 0; i < 12; i++) {
                                var wx = (Math.sin(i * 5.7 + t * 0.1) * 0.5 + 0.5) * w;
                                var wy = h - ((ph.time * 200 + i * h * 0.1) % (h * 1.3)) + h * 0.15;
                                ctx.beginPath();
                                ctx.moveTo(wx, wy);
                                ctx.lineTo(wx + (Math.random() - 0.5) * 4, wy - 30 - Math.sin(i * 3.1) * 20);
                                ctx.strokeStyle = 'rgba(200, 220, 240, 0.04)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }

                            // Faint stars still visible at top
                            if (skyBright < 0.5) {
                                for (var i = 0; i < 20; i++) {
                                    var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                    var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h * 0.3;
                                    ctx.beginPath();
                                    ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(255, 255, 255, ' + ((1 - skyBright * 2) * 0.08) + ')';
                                    ctx.fill();
                                }
                            }

                            // Earth below getting more detailed
                            if (p > 0.5) {
                                var landVis = (p - 0.5) / 0.5;
                                var landG = ctx.createLinearGradient(0, h * 0.85, 0, h);
                                landG.addColorStop(0, 'rgba(60, 120, 60, 0)');
                                landG.addColorStop(1, 'rgba(60, 120, 60, ' + (landVis * 0.06) + ')');
                                ctx.fillStyle = landG;
                                ctx.fillRect(0, h * 0.85, w, h * 0.15);
                            }
                        }

                        else if (ph.name === 'clouds') {
                            // Clouds rushing upward past us
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            skyG.addColorStop(0, '#3070b0');
                            skyG.addColorStop(1, '#4890d0');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Cloud layers rushing up
                            for (var i = 0; i < 12; i++) {
                                var cloudX = (Math.sin(i * 4.7 + 1.3) * 0.5 + 0.5) * w;
                                var cloudY = h - ((ph.time * 120 + i * h * 0.12) % (h * 1.4)) + h * 0.2;
                                var cloudW = 60 + Math.sin(i * 3.1) * 35;
                                var cloudH = 15 + Math.sin(i * 2.3) * 8;

                                // Cloud puff (multiple ellipses)
                                for (var j = 0; j < 3; j++) {
                                    ctx.beginPath();
                                    ctx.ellipse(cloudX + (j - 1) * cloudW * 0.3, cloudY + Math.sin(j * 2 + i) * 3, cloudW * 0.5, cloudH, 0, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(240, 245, 255, 0.06)';
                                    ctx.fill();
                                }
                            }

                            // Ground visible below
                            var groundVis = sm(0.3, 1, p);
                            if (groundVis > 0) {
                                var gG = ctx.createLinearGradient(0, h * 0.8, 0, h);
                                gG.addColorStop(0, 'rgba(50, 100, 50, 0)');
                                gG.addColorStop(1, 'rgba(50, 100, 50, ' + (groundVis * 0.1) + ')');
                                ctx.fillStyle = gG;
                                ctx.fillRect(0, h * 0.8, w, h * 0.2);
                            }
                        }

                        else if (ph.name === 'chute') {
                            // Parachute jolt  everything slows dramatically
                            var jolt = p < 0.2 ? p / 0.2 : 1;
                            var slow = sm(0, 0.3, p);
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            skyG.addColorStop(0, '#4088c0');
                            skyG.addColorStop(1, '#60a0d0');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Parachute canopy above
                            var chuteY = h * 0.15;
                            var chuteW = w * 0.25;
                            // Canopy arc
                            ctx.beginPath();
                            ctx.ellipse(cx, chuteY, chuteW, chuteW * 0.4, 0, Math.PI, 0);
                            ctx.fillStyle = 'rgba(220, 60, 30, 0.08)';
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(220, 60, 30, 0.06)';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            // Lines from canopy
                            for (var i = 0; i < 5; i++) {
                                var lx = cx + (i - 2) * chuteW * 0.4;
                                ctx.beginPath();
                                ctx.moveTo(lx, chuteY);
                                ctx.lineTo(cx + (i - 2) * 5, h * 0.45);
                                ctx.strokeStyle = 'rgba(180, 180, 180, 0.04)';
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }

                            // Gentle wind
                            for (var i = 0; i < 6; i++) {
                                var wy = h - ((ph.time * 30 + i * h * 0.2) % (h * 1.2));
                                var wx = (Math.sin(i * 4.3 + t * 0.1) * 0.5 + 0.5) * w;
                                ctx.beginPath();
                                ctx.moveTo(wx, wy);
                                ctx.lineTo(wx + 2, wy - 10);
                                ctx.strokeStyle = 'rgba(200, 220, 240, 0.03)';
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }

                            // Ground getting closer
                            var groundRise = sm(0, 1, p);
                            var gY = h * (0.9 - groundRise * 0.2);
                            ctx.beginPath();
                            ctx.moveTo(0, h); ctx.lineTo(0, gY);
                            for (var x = 0; x <= w; x += 5) {
                                ctx.lineTo(x, gY + Math.sin(x * 0.01 + 0.5) * 5);
                            }
                            ctx.lineTo(w, h); ctx.closePath();
                            ctx.fillStyle = 'rgba(70, 120, 50, ' + (0.05 + groundRise * 0.1) + ')';
                            ctx.fill();

                            // Jolt flash
                            if (p < 0.1) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + ((1 - p / 0.1) * 0.1) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'drift') {
                            // Gentle drift over patchwork fields
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, '#5098d0');
                            skyG.addColorStop(1, '#70b0e0');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Parachute above (gentle sway)
                            var sway = Math.sin(t * 0.5) * 10;
                            var chuteY = h * 0.1;
                            var chuteW = w * 0.2;
                            ctx.beginPath();
                            ctx.ellipse(cx + sway, chuteY, chuteW, chuteW * 0.35, 0, Math.PI, 0);
                            ctx.fillStyle = 'rgba(220, 60, 30, 0.06)';
                            ctx.fill();
                            for (var i = 0; i < 4; i++) {
                                ctx.beginPath();
                                ctx.moveTo(cx + sway + (i - 1.5) * chuteW * 0.4, chuteY);
                                ctx.lineTo(cx + (i - 1.5) * 4, h * 0.4);
                                ctx.strokeStyle = 'rgba(180, 180, 180, 0.03)';
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }

                            // Ground with patchwork fields
                            var groundY = h * (0.65 - p * 0.15);
                            // Fields
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(0, groundY, w, h - groundY);
                            ctx.clip();
                            var fieldScroll = t * 10;
                            for (var i = 0; i < 20; i++) {
                                var fx = ((Math.sin(i * 5.3) * 0.5 + 0.5) * w * 1.5 - fieldScroll * 0.5 + i * 30) % (w * 1.4) - w * 0.2;
                                var fy = groundY + (Math.sin(i * 3.7) * 0.5 + 0.5) * (h - groundY) * 0.8;
                                var fw = 40 + Math.sin(i * 2.9) * 20;
                                var hues = [90, 100, 60, 110, 80, 45];
                                ctx.fillStyle = 'hsla(' + hues[i % hues.length] + ', 30%, 35%, 0.08)';
                                ctx.fillRect(fx, fy, fw, fw * 0.6);
                            }
                            // River
                            ctx.beginPath();
                            for (var x = 0; x <= w; x += 4) {
                                var ry = groundY + (h - groundY) * 0.5 + Math.sin(x * 0.01 + 1.5) * 20;
                                if (x === 0) ctx.moveTo(x, ry); else ctx.lineTo(x, ry);
                            }
                            ctx.strokeStyle = 'rgba(80, 140, 180, 0.06)';
                            ctx.lineWidth = 4;
                            ctx.stroke();
                            ctx.restore();
                        }

                        else if (ph.name === 'land') {
                            // Soft landing, stillness
                            var settle = sm(0, 0.4, p);
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, '#5098d0');
                            skyG.addColorStop(1, '#70b0e0');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Ground level view
                            var groundY = h * 0.55;
                            var gG = ctx.createLinearGradient(0, groundY, 0, h);
                            gG.addColorStop(0, '#4a8030');
                            gG.addColorStop(0.3, '#3a6828');
                            gG.addColorStop(1, '#2a4820');
                            ctx.fillStyle = gG;
                            ctx.fillRect(0, groundY, w, h - groundY);

                            // Parachute collapsing (only early)
                            if (p < 0.4) {
                                var collapse = p / 0.4;
                                var chuteY = h * (0.2 + collapse * 0.15);
                                var chuteW = w * 0.2 * (1 - collapse * 0.5);
                                ctx.beginPath();
                                ctx.ellipse(cx + 20 * collapse, chuteY, chuteW, chuteW * 0.3 * (1 - collapse * 0.6), collapse * 0.5, Math.PI, 0);
                                ctx.fillStyle = 'rgba(220, 60, 30, ' + (0.05 * (1 - collapse)) + ')';
                                ctx.fill();
                            }

                            // Grass details
                            for (var i = 0; i < 30; i++) {
                                var gx = (Math.sin(i * 5.7 + 0.3) * 0.5 + 0.5) * w;
                                var gy = groundY + Math.sin(i * 3.1) * 3;
                                ctx.beginPath();
                                ctx.moveTo(gx, gy);
                                ctx.lineTo(gx + Math.sin(t * 0.8 + i) * 3, gy - 5 - Math.sin(i * 2.3) * 3);
                                ctx.strokeStyle = 'rgba(80, 140, 50, 0.04)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }

                            // Distant trees
                            for (var i = 0; i < 6; i++) {
                                var tx = w * (0.1 + i * 0.15);
                                var ty = groundY + 5;
                                ctx.beginPath();
                                ctx.arc(tx, ty - 10, 8, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(30, 60, 25, 0.06)';
                                ctx.fill();
                                ctx.fillStyle = 'rgba(50, 35, 20, 0.04)';
                                ctx.fillRect(tx - 1.5, ty - 5, 3, 10);
                            }

                            // Fade to black for loop
                            if (p > 0.7) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.7) / 0.3 * 0.8) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }
                    }
                };
            })();

            // --- Timeline theme ---
            // Journey through Earth's ages: molten  volcanic  oceans  jungle  ice age  city  future ruins
            themes.timeline = (function () {
                var PHASES = [
                    { name: 'molten', duration: 7 },
                    { name: 'volcanic', duration: 7 },
                    { name: 'oceans', duration: 6 },
                    { name: 'jungle', duration: 7 },
                    { name: 'ice', duration: 7 },
                    { name: 'city', duration: 6 },
                    { name: 'ruins', duration: 7 }
                ];
                var TOTAL = 0;
                for (var i = 0; i < PHASES.length; i++) TOTAL += PHASES[i].duration;

                function getPhase(t) {
                    var ct = t % TOTAL, el = 0;
                    for (var i = 0; i < PHASES.length; i++) {
                        if (ct < el + PHASES[i].duration)
                            return { name: PHASES[i].name, progress: (ct - el) / PHASES[i].duration, time: ct - el };
                        el += PHASES[i].duration;
                    }
                    return { name: 'molten', progress: 0, time: 0 };
                }
                function sm(a, b, t) { t = Math.max(0, Math.min(1, (t - a) / (b - a))); return t * t * (3 - 2 * t); }
                function lerp(a, b, t) { return a + (b - a) * t; }

                return {
                    targetCount: 0,
                    spawn: function () { return { x: 0, y: 0 }; },
                    update: function () { return true; },
                    draw: function () {},
                    onActivate: function () {},

                    drawBackground: function (ctx, w, h) {
                        ctx.fillStyle = '#0a0404';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var ph = getPhase(t);
                        var p = ph.progress;
                        var cx = w * 0.5, cy = h * 0.5;

                        if (ph.name === 'molten') {
                            // Primordial Earth: lava rivers, meteors, red sky
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            skyG.addColorStop(0, '#1a0804');
                            skyG.addColorStop(0.3, '#301008');
                            skyG.addColorStop(0.6, '#501810');
                            skyG.addColorStop(1, '#803018');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Lava rivers on the ground
                            var groundY = h * 0.65;
                            ctx.fillStyle = '#200808';
                            ctx.fillRect(0, groundY, w, h - groundY);

                            // Lava flows
                            for (var i = 0; i < 8; i++) {
                                ctx.beginPath();
                                var lx = w * (Math.sin(i * 4.3 + 0.5) * 0.5 + 0.5);
                                ctx.moveTo(lx, groundY);
                                for (var y = groundY; y <= h; y += 3) {
                                    lx += Math.sin(y * 0.02 + t * 0.5 + i * 2) * 2;
                                    ctx.lineTo(lx, y);
                                }
                                var pulse = Math.sin(t * 1.5 + i * 1.7) * 0.02;
                                ctx.strokeStyle = 'rgba(255, 100, 20, ' + (0.06 + pulse) + ')';
                                ctx.lineWidth = 3 + Math.sin(i * 2.1) * 2;
                                ctx.stroke();
                            }

                            // Lava glow from below
                            var lavaG = ctx.createLinearGradient(0, groundY, 0, h);
                            lavaG.addColorStop(0, 'rgba(255, 80, 20, 0)');
                            lavaG.addColorStop(0.5, 'rgba(255, 60, 10, 0.04)');
                            lavaG.addColorStop(1, 'rgba(255, 40, 0, 0.08)');
                            ctx.fillStyle = lavaG;
                            ctx.fillRect(0, groundY, w, h - groundY);

                            // Meteors
                            for (var i = 0; i < 4; i++) {
                                var mPhase = (t * 0.3 + i * 1.7) % 3;
                                if (mPhase < 1) {
                                    var mx = w * (Math.sin(i * 5.3 + 0.7) * 0.5 + 0.5) - mPhase * w * 0.3;
                                    var my = mPhase * h * 0.5;
                                    ctx.beginPath();
                                    ctx.arc(mx, my, 2, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(255, 200, 100, 0.2)';
                                    ctx.fill();
                                    // Trail
                                    ctx.beginPath();
                                    ctx.moveTo(mx, my);
                                    ctx.lineTo(mx + 15, my - 10);
                                    ctx.strokeStyle = 'rgba(255, 180, 80, 0.08)';
                                    ctx.lineWidth = 1;
                                    ctx.stroke();
                                }
                            }

                            // Transition fade
                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'volcanic') {
                            // Volcanic hellscape with ash clouds
                            var ashDark = sm(0, 0.5, p) * 0.3;
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            skyG.addColorStop(0, 'rgb(' + Math.round(20 + ashDark * 20) + ',' + Math.round(10 + ashDark * 10) + ',' + Math.round(8 + ashDark * 8) + ')');
                            skyG.addColorStop(0.4, '#401510');
                            skyG.addColorStop(1, '#201008');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Volcanic peaks
                            var groundY = h * 0.6;
                            for (var i = 0; i < 5; i++) {
                                var vx = w * (0.1 + i * 0.2);
                                var vw = w * 0.12;
                                var vh = h * (0.15 + Math.sin(i * 3.7) * 0.08);
                                ctx.beginPath();
                                ctx.moveTo(vx - vw, groundY);
                                ctx.lineTo(vx, groundY - vh);
                                ctx.lineTo(vx + vw, groundY);
                                ctx.closePath();
                                ctx.fillStyle = '#1a0c08';
                                ctx.fill();

                                // Eruption glow at peak
                                if (i === 2 || i === 4) {
                                    var erupt = Math.sin(t * 1.2 + i * 3) * 0.5 + 0.5;
                                    var eG = ctx.createRadialGradient(vx, groundY - vh, 0, vx, groundY - vh, 25);
                                    eG.addColorStop(0, 'rgba(255, 120, 30, ' + (erupt * 0.12) + ')');
                                    eG.addColorStop(1, 'rgba(255, 60, 10, 0)');
                                    ctx.beginPath();
                                    ctx.arc(vx, groundY - vh, 25, 0, Math.PI * 2);
                                    ctx.fillStyle = eG;
                                    ctx.fill();
                                }
                            }

                            // Ground
                            ctx.fillStyle = '#150a06';
                            ctx.fillRect(0, groundY, w, h - groundY);

                            // Ash particles falling
                            for (var i = 0; i < 25; i++) {
                                var ax = (Math.sin(i * 6.7 + t * 0.05) * 0.5 + 0.5) * w;
                                var ay = (t * 15 + i * h * 0.05) % (h * 1.1) - h * 0.05;
                                ctx.beginPath();
                                ctx.arc(ax + Math.sin(t * 0.5 + i) * 5, ay, 0.8 + Math.sin(i * 2.3) * 0.3, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(100, 90, 80, 0.05)';
                                ctx.fill();
                            }

                            // Ash cloud banks
                            for (var i = 0; i < 4; i++) {
                                var cloudY = h * (0.1 + i * 0.08);
                                var cloudX = (cx + Math.sin(t * 0.1 + i * 2) * w * 0.3 + t * 5 * (i % 2 === 0 ? 1 : -1)) % (w * 1.4) - w * 0.2;
                                ctx.beginPath();
                                ctx.ellipse(cloudX, cloudY, 80, 15, 0, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(60, 50, 40, 0.04)';
                                ctx.fill();
                            }

                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'oceans') {
                            // First oceans under stormy skies
                            var calm = sm(0, 1, p);
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, 'rgb(' + Math.round(20 + calm * 15) + ',' + Math.round(25 + calm * 20) + ',' + Math.round(35 + calm * 30) + ')');
                            skyG.addColorStop(1, 'rgb(' + Math.round(30 + calm * 20) + ',' + Math.round(40 + calm * 30) + ',' + Math.round(55 + calm * 35) + ')');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Ocean
                            var waterY = h * 0.48;
                            var wG = ctx.createLinearGradient(0, waterY, 0, h);
                            wG.addColorStop(0, 'rgb(15,' + Math.round(40 + calm * 20) + ',' + Math.round(60 + calm * 30) + ')');
                            wG.addColorStop(1, 'rgb(8,' + Math.round(20 + calm * 10) + ',' + Math.round(35 + calm * 20) + ')');
                            ctx.fillStyle = wG;
                            ctx.fillRect(0, waterY, w, h - waterY);

                            // Waves
                            for (var i = 0; i < 6; i++) {
                                ctx.beginPath();
                                var waveY = waterY + i * 8;
                                for (var x = 0; x <= w; x += 4) {
                                    var amp = 4 + (1 - calm) * 4;
                                    var y = waveY + Math.sin(x * 0.008 + t * (0.6 + i * 0.15) + i) * amp;
                                    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                                }
                                ctx.strokeStyle = 'rgba(80, 130, 160, 0.04)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }

                            // Storm clouds (fading as it calms)
                            if (calm < 0.7) {
                                var stormOp = (1 - calm / 0.7) * 0.04;
                                for (var i = 0; i < 5; i++) {
                                    var scx = (cx + Math.sin(t * 0.08 + i * 3) * w * 0.3 + t * 8) % (w * 1.3) - w * 0.15;
                                    var scy = h * (0.1 + Math.sin(i * 2.7) * 0.05);
                                    ctx.beginPath();
                                    ctx.ellipse(scx, scy, 70, 18, 0, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(40, 45, 55, ' + stormOp + ')';
                                    ctx.fill();
                                }
                            }

                            // Lightning flash (early)
                            if (p < 0.3) {
                                var lFlash = Math.sin(t * 5 + 1.3);
                                if (lFlash > 0.95) {
                                    ctx.fillStyle = 'rgba(200, 220, 255, 0.04)';
                                    ctx.fillRect(0, 0, w, h * 0.5);
                                }
                            }

                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'jungle') {
                            // Lush prehistoric jungle with giant ferns
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.4);
                            skyG.addColorStop(0, '#1a3520');
                            skyG.addColorStop(1, '#2a5530');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Dense foliage background
                            var groundG = ctx.createLinearGradient(0, h * 0.3, 0, h);
                            groundG.addColorStop(0, '#1a3518');
                            groundG.addColorStop(0.5, '#0a2008');
                            groundG.addColorStop(1, '#061505');
                            ctx.fillStyle = groundG;
                            ctx.fillRect(0, h * 0.3, w, h * 0.7);

                            // Giant fern fronds
                            for (var i = 0; i < 10; i++) {
                                var fx = w * (Math.sin(i * 4.7 + 0.3) * 0.5 + 0.5);
                                var fy = h * (0.2 + Math.sin(i * 3.1) * 0.1);
                                var fernLen = 60 + Math.sin(i * 2.3) * 30;
                                var sway = Math.sin(t * 0.3 + i * 1.7) * 5;

                                // Stem
                                ctx.beginPath();
                                ctx.moveTo(fx, h);
                                ctx.quadraticCurveTo(fx + sway, fy + fernLen * 0.5, fx + sway * 2, fy);
                                ctx.strokeStyle = 'rgba(30, 80, 20, 0.06)';
                                ctx.lineWidth = 2;
                                ctx.stroke();

                                // Leaflets
                                for (var j = 0; j < 6; j++) {
                                    var lf = j / 6;
                                    var lx = fx + sway * lf;
                                    var ly = h - (h - fy) * lf;
                                    var leafSize = 15 * (1 - lf * 0.5);
                                    for (var side = -1; side <= 1; side += 2) {
                                        ctx.beginPath();
                                        ctx.ellipse(lx + side * leafSize, ly, leafSize, 3, side * 0.3 + sway * 0.02, 0, Math.PI * 2);
                                        ctx.fillStyle = 'rgba(25, 70, 15, 0.04)';
                                        ctx.fill();
                                    }
                                }
                            }

                            // Mist/humidity
                            for (var i = 0; i < 5; i++) {
                                var mx = (cx + Math.sin(t * 0.05 + i * 3) * w * 0.4);
                                var my = h * (0.4 + Math.sin(i * 2.7) * 0.15);
                                ctx.beginPath();
                                ctx.ellipse(mx, my, 60, 15, 0, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(100, 150, 80, 0.015)';
                                ctx.fill();
                            }

                            // Light shafts through canopy
                            for (var i = 0; i < 3; i++) {
                                var lx = w * (0.25 + i * 0.25);
                                var lPulse = Math.sin(t * 0.2 + i * 2) * 0.5 + 0.5;
                                ctx.beginPath();
                                ctx.moveTo(lx - 5, 0); ctx.lineTo(lx + 5, 0);
                                ctx.lineTo(lx + 25, h); ctx.lineTo(lx - 15, h);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(180, 220, 100, ' + (lPulse * 0.012) + ')';
                                ctx.fill();
                            }

                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'ice') {
                            // Ice age: glaciers, frozen landscape, pale sky
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, '#c8d8e8');
                            skyG.addColorStop(1, '#90a8c0');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Frozen ground
                            var groundY = h * 0.55;
                            var gG = ctx.createLinearGradient(0, groundY, 0, h);
                            gG.addColorStop(0, '#d0dce8');
                            gG.addColorStop(0.3, '#b8c8d8');
                            gG.addColorStop(1, '#a0b0c0');
                            ctx.fillStyle = gG;
                            ctx.fillRect(0, groundY, w, h - groundY);

                            // Glacier/mountain shapes
                            for (var i = 0; i < 6; i++) {
                                var gx = w * (Math.sin(i * 4.3 + 0.5) * 0.5 + 0.5);
                                var gw = w * 0.1;
                                var gh = h * (0.1 + Math.sin(i * 2.7) * 0.06);
                                ctx.beginPath();
                                ctx.moveTo(gx - gw, groundY);
                                ctx.lineTo(gx, groundY - gh);
                                ctx.lineTo(gx + gw, groundY);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(200, 215, 230, 0.15)';
                                ctx.fill();
                                // Snow cap highlight
                                ctx.beginPath();
                                ctx.moveTo(gx - gw * 0.3, groundY - gh * 0.7);
                                ctx.lineTo(gx, groundY - gh);
                                ctx.lineTo(gx + gw * 0.3, groundY - gh * 0.7);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(240, 245, 255, 0.08)';
                                ctx.fill();
                            }

                            // Snow falling
                            for (var i = 0; i < 30; i++) {
                                var sx = (Math.sin(i * 7.3 + t * 0.03) * 0.5 + 0.5) * w;
                                var sy = (t * 12 + i * h * 0.04) % (h * 1.05) - h * 0.025;
                                var drift = Math.sin(t * 0.3 + i * 2) * 10;
                                ctx.beginPath();
                                ctx.arc(sx + drift, sy, 1 + Math.sin(i * 2.1) * 0.5, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(240, 245, 255, 0.08)';
                                ctx.fill();
                            }

                            // Pale sun
                            var sunX = w * 0.7, sunY = h * 0.15;
                            var sG = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 50);
                            sG.addColorStop(0, 'rgba(255, 250, 240, 0.1)');
                            sG.addColorStop(1, 'rgba(255, 240, 220, 0)');
                            ctx.fillStyle = sG;
                            ctx.fillRect(0, 0, w, h);

                            // Wind streaks
                            for (var i = 0; i < 5; i++) {
                                var wy = groundY + (Math.sin(i * 3.7) * 0.5 + 0.5) * (h - groundY) * 0.3;
                                ctx.beginPath();
                                var startX = ((t * 40 + i * w * 0.25) % (w * 1.3)) - w * 0.15;
                                ctx.moveTo(startX, wy);
                                ctx.lineTo(startX + 40, wy + Math.sin(i * 2.1) * 2);
                                ctx.strokeStyle = 'rgba(220, 230, 240, 0.03)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }

                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'city') {
                            // Modern cityscape at night with glowing windows
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, '#0a0c18');
                            skyG.addColorStop(1, '#141828');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // City light pollution glow
                            var cityG = ctx.createLinearGradient(0, h * 0.4, 0, h);
                            cityG.addColorStop(0, 'rgba(40, 30, 50, 0)');
                            cityG.addColorStop(1, 'rgba(40, 30, 50, 0.2)');
                            ctx.fillStyle = cityG;
                            ctx.fillRect(0, h * 0.4, w, h * 0.6);

                            // Stars (dimmed by light pollution)
                            for (var i = 0; i < 30; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h * 0.35;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.4, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 210, 230, 0.06)';
                                ctx.fill();
                            }

                            // Buildings (skyline)
                            var baseY = h * 0.55;
                            for (var i = 0; i < 18; i++) {
                                var bx = w * (i / 18);
                                var bw = w * 0.04 + Math.sin(i * 3.7) * w * 0.015;
                                var bh = h * (0.1 + (Math.sin(i * 2.3 + 0.5) * 0.5 + 0.5) * 0.3);
                                var by = baseY - bh;
                                ctx.fillStyle = 'rgba(20, 22, 30, 0.3)';
                                ctx.fillRect(bx, by, bw, bh);

                                // Windows
                                for (var wy = by + 4; wy < baseY - 3; wy += 6) {
                                    for (var wx = bx + 2; wx < bx + bw - 2; wx += 5) {
                                        var lit = Math.sin(wx * 3.7 + wy * 2.3 + t * 0.1) > 0.2;
                                        if (lit) {
                                            ctx.fillStyle = 'rgba(255, 220, 120, 0.04)';
                                            ctx.fillRect(wx, wy, 2.5, 3);
                                        }
                                    }
                                }
                            }

                            // Street level glow
                            ctx.fillStyle = 'rgba(20, 18, 25, 0.3)';
                            ctx.fillRect(0, baseY, w, h - baseY);

                            // Street lights
                            for (var i = 0; i < 8; i++) {
                                var lx = w * (0.05 + i * 0.12);
                                var ly = baseY + 5;
                                var lG = ctx.createRadialGradient(lx, ly, 0, lx, ly, 15);
                                lG.addColorStop(0, 'rgba(255, 200, 100, 0.06)');
                                lG.addColorStop(1, 'rgba(255, 180, 80, 0)');
                                ctx.beginPath();
                                ctx.arc(lx, ly, 15, 0, Math.PI * 2);
                                ctx.fillStyle = lG;
                                ctx.fill();
                            }

                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.3) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        else if (ph.name === 'ruins') {
                            // Far-future ruins overtaken by nature
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, '#182818');
                            skyG.addColorStop(1, '#284028');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Overgrown ground
                            var groundG = ctx.createLinearGradient(0, h * 0.5, 0, h);
                            groundG.addColorStop(0, '#1a3015');
                            groundG.addColorStop(1, '#0a1808');
                            ctx.fillStyle = groundG;
                            ctx.fillRect(0, h * 0.5, w, h * 0.5);

                            // Ruined building silhouettes with broken edges
                            for (var i = 0; i < 10; i++) {
                                var bx = w * (i / 10);
                                var bw = w * 0.06 + Math.sin(i * 3.7) * w * 0.02;
                                var bh = h * (0.05 + (Math.sin(i * 2.3) * 0.5 + 0.5) * 0.2);
                                var by = h * 0.55 - bh;

                                // Broken top edge
                                ctx.beginPath();
                                ctx.moveTo(bx, h * 0.55);
                                ctx.lineTo(bx, by);
                                for (var x = bx; x <= bx + bw; x += 3) {
                                    ctx.lineTo(x, by + Math.sin(x * 0.1 + i * 2) * 5 + Math.random() * 2);
                                }
                                ctx.lineTo(bx + bw, h * 0.55);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(30, 35, 28, 0.12)';
                                ctx.fill();
                            }

                            // Vines climbing up ruins
                            for (var i = 0; i < 12; i++) {
                                var vx = w * (Math.sin(i * 4.7 + 0.3) * 0.5 + 0.5);
                                ctx.beginPath();
                                ctx.moveTo(vx, h);
                                for (var y = h; y > h * 0.3; y -= 3) {
                                    vx += Math.sin(y * 0.02 + t * 0.1 + i * 2) * 1.5;
                                    ctx.lineTo(vx, y);
                                }
                                ctx.strokeStyle = 'rgba(40, 80, 30, 0.03)';
                                ctx.lineWidth = 1.5;
                                ctx.stroke();

                                // Leaves
                                for (var j = 0; j < 4; j++) {
                                    var ly = h - (h * 0.7) * (j / 4) + Math.sin(i + j) * 15;
                                    var lx = vx + Math.sin(ly * 0.02 + i * 2) * 10;
                                    ctx.beginPath();
                                    ctx.ellipse(lx, ly, 4, 2, Math.sin(i + j) * 0.5, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(50, 90, 35, 0.04)';
                                    ctx.fill();
                                }
                            }

                            // Fireflies/bioluminescence in the ruins
                            for (var i = 0; i < 8; i++) {
                                var fx = (Math.sin(i * 5.3 + t * 0.05 + 0.7) * 0.5 + 0.5) * w;
                                var fy = h * (0.3 + Math.sin(i * 3.7 + t * 0.08) * 0.15);
                                var pulse = Math.sin(t * (0.8 + i * 0.3) + i * 2) * 0.5 + 0.5;
                                ctx.beginPath();
                                ctx.arc(fx, fy, 2, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(150, 220, 100, ' + (pulse * 0.08) + ')';
                                ctx.fill();
                                var fG = ctx.createRadialGradient(fx, fy, 0, fx, fy, 10);
                                fG.addColorStop(0, 'rgba(150, 220, 100, ' + (pulse * 0.03) + ')');
                                fG.addColorStop(1, 'rgba(100, 180, 60, 0)');
                                ctx.beginPath();
                                ctx.arc(fx, fy, 10, 0, Math.PI * 2);
                                ctx.fillStyle = fG;
                                ctx.fill();
                            }

                            // Soft mist
                            for (var i = 0; i < 4; i++) {
                                var mx = (cx + Math.sin(t * 0.04 + i * 3) * w * 0.3);
                                var my = h * (0.45 + Math.sin(i * 2.7) * 0.05);
                                ctx.beginPath();
                                ctx.ellipse(mx, my, 70, 12, 0, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(80, 120, 70, 0.012)';
                                ctx.fill();
                            }

                            if (p > 0.85) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.85) / 0.15 * 0.4) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }
                    }
                };
            })();

            // --- Apollo theme ---
            // Moon mission: launch  ascent  staging  transit  moon approach  dark side  return  reentry  splashdown
            themes.apollo = (function () {
                var PHASES = [
                    { name: 'launch', duration: 7 },
                    { name: 'ascent', duration: 6 },
                    { name: 'staging', duration: 5 },
                    { name: 'transit', duration: 7 },
                    { name: 'approach', duration: 6 },
                    { name: 'darkside', duration: 7 },
                    { name: 'return', duration: 6 },
                    { name: 'reentry', duration: 5 },
                    { name: 'splashdown', duration: 6 }
                ];
                var TOTAL = 0;
                for (var i = 0; i < PHASES.length; i++) TOTAL += PHASES[i].duration;

                // Detached booster state
                var boosters = [
                    { x: 0, y: 0, rot: 0, vx: 0, vy: 0, vr: 0, active: false },
                    { x: 0, y: 0, rot: 0, vx: 0, vy: 0, vr: 0, active: false }
                ];
                var stage2 = { x: 0, y: 0, rot: 0, vx: 0, vy: 0, vr: 0, active: false };
                var lastPhase = '';

                function getPhase(t) {
                    var ct = t % TOTAL, el = 0;
                    for (var i = 0; i < PHASES.length; i++) {
                        if (ct < el + PHASES[i].duration)
                            return { name: PHASES[i].name, progress: (ct - el) / PHASES[i].duration, time: ct - el };
                        el += PHASES[i].duration;
                    }
                    return { name: 'launch', progress: 0, time: 0 };
                }
                function sm(a, b, t) { t = Math.max(0, Math.min(1, (t - a) / (b - a))); return t * t * (3 - 2 * t); }

                function drawRocket(ctx, rx, ry, scale, hasBoost, hasFairings) {
                    ctx.save();
                    ctx.translate(rx, ry);
                    ctx.scale(scale, scale);

                    // Main body
                    ctx.fillStyle = 'rgba(220, 225, 230, 0.25)';
                    ctx.fillRect(-6, -40, 12, 50);
                    // Nose cone
                    ctx.beginPath();
                    ctx.moveTo(-6, -40);
                    ctx.lineTo(0, -55);
                    ctx.lineTo(6, -40);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(230, 235, 240, 0.3)';
                    ctx.fill();

                    // Side boosters
                    if (hasBoost) {
                        for (var side = -1; side <= 1; side += 2) {
                            ctx.fillStyle = 'rgba(200, 205, 210, 0.2)';
                            ctx.fillRect(side * 10 - 3, -25, 6, 35);
                            // Booster nose
                            ctx.beginPath();
                            ctx.moveTo(side * 10 - 3, -25);
                            ctx.lineTo(side * 10, -32);
                            ctx.lineTo(side * 10 + 3, -25);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }

                    // Fairings (2nd stage marker)
                    if (hasFairings) {
                        ctx.fillStyle = 'rgba(180, 185, 190, 0.15)';
                        ctx.fillRect(-7, -20, 14, 8);
                    }

                    ctx.restore();
                }

                function drawExhaust(ctx, ex, ey, scale, intensity, t) {
                    var flicker = Math.sin(t * 20) * 0.3 + 0.7;
                    var len = 30 * scale * intensity * flicker;
                    var wid = 8 * scale;
                    // Outer flame
                    var fG = ctx.createRadialGradient(ex, ey + len * 0.3, 0, ex, ey + len * 0.3, len);
                    fG.addColorStop(0, 'rgba(255, 200, 80, ' + (intensity * 0.15 * flicker) + ')');
                    fG.addColorStop(0.4, 'rgba(255, 120, 30, ' + (intensity * 0.08 * flicker) + ')');
                    fG.addColorStop(1, 'rgba(255, 60, 10, 0)');
                    ctx.beginPath();
                    ctx.moveTo(ex - wid, ey);
                    ctx.quadraticCurveTo(ex, ey + len, ex + wid, ey);
                    ctx.closePath();
                    ctx.fillStyle = fG;
                    ctx.fill();
                    // Inner bright core
                    ctx.beginPath();
                    ctx.moveTo(ex - wid * 0.4, ey);
                    ctx.quadraticCurveTo(ex, ey + len * 0.6, ex + wid * 0.4, ey);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255, 255, 220, ' + (intensity * 0.08 * flicker) + ')';
                    ctx.fill();
                }

                function drawMoon(ctx, mx, my, radius) {
                    // Moon disc
                    var mG = ctx.createRadialGradient(mx - radius * 0.25, my - radius * 0.2, radius * 0.1, mx, my, radius);
                    mG.addColorStop(0, '#c8c4b8');
                    mG.addColorStop(0.5, '#a8a498');
                    mG.addColorStop(1, '#787468');
                    ctx.beginPath();
                    ctx.arc(mx, my, radius, 0, Math.PI * 2);
                    ctx.fillStyle = mG;
                    ctx.fill();
                    // Craters
                    var craters = [
                        { x: -0.2, y: -0.15, r: 0.12 }, { x: 0.25, y: 0.1, r: 0.08 },
                        { x: -0.1, y: 0.3, r: 0.1 }, { x: 0.3, y: -0.25, r: 0.06 },
                        { x: -0.35, y: 0.1, r: 0.07 }, { x: 0.1, y: -0.35, r: 0.09 }
                    ];
                    for (var i = 0; i < craters.length; i++) {
                        var c = craters[i];
                        ctx.beginPath();
                        ctx.arc(mx + c.x * radius, my + c.y * radius, c.r * radius, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(80, 78, 70, 0.12)';
                        ctx.fill();
                    }
                }

                function drawCapsule(ctx, capX, capY, scale) {
                    ctx.save();
                    ctx.translate(capX, capY);
                    ctx.scale(scale, scale);
                    // Cone shape
                    ctx.beginPath();
                    ctx.moveTo(-8, 5);
                    ctx.lineTo(0, -12);
                    ctx.lineTo(8, 5);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(210, 215, 220, 0.25)';
                    ctx.fill();
                    // Heat shield
                    ctx.beginPath();
                    ctx.ellipse(0, 6, 9, 3, 0, 0, Math.PI);
                    ctx.fillStyle = 'rgba(120, 80, 50, 0.2)';
                    ctx.fill();
                    ctx.restore();
                }

                function drawStars(ctx, w, h, t, opacity) {
                    for (var i = 0; i < 100; i++) {
                        var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                        var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                        var tw = Math.sin(t * 0.5 + i * 2.3) * 0.5 + 0.5;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 0.4 + tw * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(220, 230, 255, ' + (opacity * (0.08 + tw * 0.12)) + ')';
                        ctx.fill();
                    }
                }

                function drawEarth(ctx, ex, ey, radius) {
                    var eG = ctx.createRadialGradient(ex - radius * 0.2, ey - radius * 0.2, radius * 0.1, ex, ey, radius);
                    eG.addColorStop(0, '#4090c0');
                    eG.addColorStop(0.4, '#2870a0');
                    eG.addColorStop(0.7, '#1a5080');
                    eG.addColorStop(1, '#0a2840');
                    ctx.beginPath();
                    ctx.arc(ex, ey, radius, 0, Math.PI * 2);
                    ctx.fillStyle = eG;
                    ctx.fill();
                    // Continents
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(ex, ey, radius, 0, Math.PI * 2);
                    ctx.clip();
                    for (var i = 0; i < 5; i++) {
                        var lx = ex + Math.sin(i * 4.7 + 0.5) * radius * 0.5;
                        var ly = ey + Math.cos(i * 3.3 + 1.2) * radius * 0.4;
                        var ls = radius * (0.15 + Math.sin(i * 2.9) * 0.08);
                        ctx.beginPath();
                        ctx.ellipse(lx, ly, ls, ls * 0.7, Math.sin(i) * 0.5, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(40, 100, 50, 0.12)';
                        ctx.fill();
                    }
                    ctx.restore();
                    // Atmosphere
                    var aG = ctx.createRadialGradient(ex, ey, radius * 0.9, ex, ey, radius * 1.12);
                    aG.addColorStop(0, 'rgba(100, 180, 255, 0)');
                    aG.addColorStop(0.5, 'rgba(100, 180, 255, 0.06)');
                    aG.addColorStop(1, 'rgba(100, 180, 255, 0)');
                    ctx.beginPath();
                    ctx.arc(ex, ey, radius * 1.12, 0, Math.PI * 2);
                    ctx.fillStyle = aG;
                    ctx.fill();
                }

                return {
                    targetCount: 0,
                    spawn: function () { return { x: 0, y: 0 }; },
                    update: function () { return true; },
                    draw: function () {},
                    onActivate: function () {
                        boosters[0].active = false;
                        boosters[1].active = false;
                        stage2.active = false;
                        lastPhase = '';
                    },

                    drawBackground: function (ctx, w, h) {
                        ctx.fillStyle = '#020206';
                        ctx.fillRect(0, 0, w, h);
                    },

                    drawForeground: function (ctx, w, h, state, dt) {
                        dt = dt || FALLBACK_DT;
                        var t = state.timeElapsed;
                        var ph = getPhase(t);
                        var p = ph.progress;
                        var cx = w * 0.5, cy = h * 0.5;

                        // Reset detached parts when cycling back to launch
                        if (ph.name === 'launch' && lastPhase !== 'launch') {
                            boosters[0].active = false;
                            boosters[1].active = false;
                            stage2.active = false;
                        }
                        lastPhase = ph.name;

                        // ==================== LAUNCH ====================
                        if (ph.name === 'launch') {
                            // Rocket on launch pad, engines ignite, lifts off
                            // Sky gradient: blue at top fading to orange at horizon
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            skyG.addColorStop(0, '#2050a0');
                            skyG.addColorStop(0.5, '#3070b0');
                            skyG.addColorStop(0.8, '#c08040');
                            skyG.addColorStop(1, '#604020');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Ground level
                            var groundY = h * 0.78;
                            ctx.fillStyle = '#303028';
                            ctx.fillRect(0, groundY, w, h - groundY);

                            // Launch tower
                            var towerX = cx + 25;
                            ctx.fillStyle = 'rgba(120, 120, 110, 0.08)';
                            ctx.fillRect(towerX, groundY - 80, 4, 80);
                            // Cross beams
                            for (var i = 0; i < 6; i++) {
                                ctx.beginPath();
                                ctx.moveTo(towerX, groundY - 12 * i - 5);
                                ctx.lineTo(towerX + 10, groundY - 12 * i - 12);
                                ctx.strokeStyle = 'rgba(120, 120, 110, 0.05)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }

                            // Launch pad
                            ctx.fillStyle = 'rgba(80, 80, 75, 0.1)';
                            ctx.fillRect(cx - 30, groundY - 3, 60, 6);

                            // Rocket
                            var liftoff = sm(0.5, 1, p);
                            var rocketY = groundY - 10 - liftoff * h * 0.3;
                            var engineOn = sm(0.3, 0.5, p);
                            drawRocket(ctx, cx, rocketY, 1.0, true, true);

                            // Exhaust
                            if (engineOn > 0) {
                                drawExhaust(ctx, cx, rocketY + 10, 1.0, engineOn, t);
                                // Side booster exhaust
                                drawExhaust(ctx, cx - 10, rocketY + 10, 0.6, engineOn * 0.7, t + 0.5);
                                drawExhaust(ctx, cx + 10, rocketY + 10, 0.6, engineOn * 0.7, t + 1.0);

                                // Smoke billowing on the pad
                                if (liftoff < 0.3) {
                                    for (var i = 0; i < 10; i++) {
                                        var smx = cx + (Math.sin(i * 4.3 + t * 0.5) - 0.5) * 60;
                                        var smy = groundY - 5 + Math.sin(i * 2.7) * 10;
                                        var smR = 15 + i * 5 + t * 3;
                                        ctx.beginPath();
                                        ctx.arc(smx, smy, smR, 0, Math.PI * 2);
                                        ctx.fillStyle = 'rgba(180, 175, 165, ' + (engineOn * 0.02 * (1 - liftoff / 0.3)) + ')';
                                        ctx.fill();
                                    }
                                }
                            }

                            // Rumble/vibration hint near ignition
                            if (engineOn > 0 && engineOn < 0.5) {
                                var glow = ctx.createRadialGradient(cx, groundY, 0, cx, groundY, h * 0.3);
                                glow.addColorStop(0, 'rgba(255, 180, 80, ' + (engineOn * 0.06) + ')');
                                glow.addColorStop(1, 'rgba(255, 100, 30, 0)');
                                ctx.fillStyle = glow;
                                ctx.fillRect(0, groundY - h * 0.3, w, h * 0.6);
                            }
                        }

                        // ==================== ASCENT ====================
                        else if (ph.name === 'ascent') {
                            // Rising through atmosphere, sky darkening
                            var dark = sm(0, 1, p);
                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            var skyR = Math.round(32 - dark * 28);
                            var skyGv = Math.round(80 - dark * 70);
                            var skyB = Math.round(160 - dark * 150);
                            skyG.addColorStop(0, 'rgb(' + Math.round(skyR * 0.5) + ',' + Math.round(skyGv * 0.5) + ',' + Math.round(skyB * 0.8) + ')');
                            skyG.addColorStop(1, 'rgb(' + skyR + ',' + skyGv + ',' + skyB + ')');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Stars appearing
                            if (dark > 0.3) {
                                drawStars(ctx, w, h, t, (dark - 0.3) / 0.7);
                            }

                            // Earth receding at bottom
                            if (dark > 0.4) {
                                var curveY = h * (0.8 + (dark - 0.4) * 0.5);
                                if (curveY < h + 200) {
                                    ctx.beginPath();
                                    ctx.moveTo(-w * 0.3, h + 100);
                                    ctx.quadraticCurveTo(cx, curveY, w * 1.3, h + 100);
                                    ctx.closePath();
                                    ctx.fillStyle = '#1a5080';
                                    ctx.fill();
                                    // Atmos line
                                    var aG = ctx.createLinearGradient(0, curveY - 10, 0, curveY + 5);
                                    aG.addColorStop(0, 'rgba(100, 180, 255, 0)');
                                    aG.addColorStop(0.5, 'rgba(100, 180, 255, 0.06)');
                                    aG.addColorStop(1, 'rgba(100, 180, 255, 0)');
                                    ctx.fillStyle = aG;
                                    ctx.fillRect(0, curveY - 10, w, 15);
                                }
                            }

                            // Rocket (smaller as it climbs into view from our perspective)
                            var rScale = 1.0 - dark * 0.2;
                            drawRocket(ctx, cx, cy - 20, rScale, true, true);
                            drawExhaust(ctx, cx, cy - 20 + 10 * rScale, rScale, 1.0, t);
                            drawExhaust(ctx, cx - 10 * rScale, cy - 20 + 10 * rScale, rScale * 0.6, 0.7, t + 0.5);
                            drawExhaust(ctx, cx + 10 * rScale, cy - 20 + 10 * rScale, rScale * 0.6, 0.7, t + 1.0);

                            // Cloud layers rushing past
                            if (dark < 0.5) {
                                var cloudFade = 1 - dark / 0.5;
                                for (var i = 0; i < 6; i++) {
                                    var cloudY = ((ph.time * 150 + i * h * 0.2) % (h * 1.4)) - h * 0.2;
                                    var cloudX = (Math.sin(i * 5.7 + 1.3) * 0.5 + 0.5) * w;
                                    ctx.beginPath();
                                    ctx.ellipse(cloudX, cloudY, 70, 10, 0, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(220, 230, 240, ' + (cloudFade * 0.04) + ')';
                                    ctx.fill();
                                }
                            }
                        }

                        // ==================== STAGING ====================
                        else if (ph.name === 'staging') {
                            // Boosters detach, then 2nd stage separates
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);
                            drawStars(ctx, w, h, t, 1);

                            // Earth in the distance below
                            drawEarth(ctx, cx, h + h * 0.6, h * 0.8);

                            var boosterSep = sm(0, 0.35, p);
                            var stageSep = sm(0.45, 0.75, p);

                            // Initialize boosters on separation
                            if (boosterSep > 0 && !boosters[0].active) {
                                boosters[0].active = true;
                                boosters[0].x = cx - 10; boosters[0].y = cy;
                                boosters[0].vx = -15; boosters[0].vy = 8; boosters[0].vr = 0.3;
                                boosters[1].active = true;
                                boosters[1].x = cx + 10; boosters[1].y = cy;
                                boosters[1].vx = 15; boosters[1].vy = 8; boosters[1].vr = -0.3;
                            }
                            if (stageSep > 0 && !stage2.active) {
                                stage2.active = true;
                                stage2.x = cx; stage2.y = cy + 5;
                                stage2.vx = 0; stage2.vy = 12; stage2.vr = 0.1;
                            }

                            // Update detached parts
                            for (var i = 0; i < 2; i++) {
                                if (boosters[i].active) {
                                    boosters[i].x += boosters[i].vx * dt;
                                    boosters[i].y += boosters[i].vy * dt;
                                    boosters[i].rot += boosters[i].vr * dt;
                                }
                            }
                            if (stage2.active) {
                                stage2.x += stage2.vx * dt;
                                stage2.y += stage2.vy * dt;
                                stage2.rot += stage2.vr * dt;
                            }

                            // Draw detached boosters tumbling away
                            for (var i = 0; i < 2; i++) {
                                if (boosters[i].active) {
                                    ctx.save();
                                    ctx.translate(boosters[i].x, boosters[i].y);
                                    ctx.rotate(boosters[i].rot);
                                    ctx.fillStyle = 'rgba(180, 185, 190, 0.12)';
                                    ctx.fillRect(-3, -15, 6, 30);
                                    ctx.beginPath();
                                    ctx.moveTo(-3, -15); ctx.lineTo(0, -20); ctx.lineTo(3, -15);
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.restore();
                                }
                            }

                            // Draw detached 2nd stage
                            if (stage2.active) {
                                ctx.save();
                                ctx.translate(stage2.x, stage2.y);
                                ctx.rotate(stage2.rot);
                                ctx.fillStyle = 'rgba(170, 175, 180, 0.1)';
                                ctx.fillRect(-5, -12, 10, 24);
                                ctx.restore();
                            }

                            // Main rocket/capsule continues
                            var hasBoost = boosterSep < 0.5;
                            var hasFairing = stageSep < 0.5;
                            if (stageSep > 0.5) {
                                // Just capsule + service module now
                                drawCapsule(ctx, cx, cy - 15, 1.2);
                                // Service module
                                ctx.fillStyle = 'rgba(200, 205, 210, 0.18)';
                                ctx.fillRect(cx - 5, cy - 5, 10, 15);
                                // Small engine
                                drawExhaust(ctx, cx, cy + 10, 0.4, 0.6, t);
                            } else {
                                drawRocket(ctx, cx, cy - 10, 0.8, hasBoost, hasFairing);
                                drawExhaust(ctx, cx, cy, 0.8, 0.8, t);
                            }

                            // Flash on separation events
                            if (p > 0.0 && p < 0.08) {
                                ctx.fillStyle = 'rgba(255, 220, 150, ' + ((1 - p / 0.08) * 0.06) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                            if (p > 0.45 && p < 0.52) {
                                ctx.fillStyle = 'rgba(255, 220, 150, ' + ((1 - (p - 0.45) / 0.07) * 0.06) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        // ==================== TRANSIT ====================
                        else if (ph.name === 'transit') {
                            // Cruising through space toward the moon
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);
                            drawStars(ctx, w, h, t, 1);

                            // Earth shrinking behind (bottom-left)
                            var earthR = Math.max(8, w * 0.15 * (1 - p * 0.7));
                            var earthX = w * (0.3 - p * 0.15);
                            var earthY = h * (0.7 + p * 0.1);
                            drawEarth(ctx, earthX, earthY, earthR);

                            // Moon dot appearing and growing ahead (top-right)
                            var moonAppear = sm(0.2, 1, p);
                            if (moonAppear > 0) {
                                var moonR = 2 + moonAppear * 15;
                                var moonX = w * (0.7 + (1 - moonAppear) * 0.05);
                                var moonY = h * (0.3 - (1 - moonAppear) * 0.02);
                                drawMoon(ctx, moonX, moonY, moonR);
                            }

                            // Capsule in centre
                            drawCapsule(ctx, cx, cy, 1.0);
                            ctx.fillStyle = 'rgba(200, 205, 210, 0.15)';
                            ctx.fillRect(cx - 4, cy + 3, 8, 12);
                            // Gentle thrust
                            var thrustPulse = Math.sin(t * 3) * 0.3 + 0.7;
                            drawExhaust(ctx, cx, cy + 15, 0.3, 0.3 * thrustPulse, t);
                        }

                        // ==================== APPROACH ====================
                        else if (ph.name === 'approach') {
                            // Moon growing large, capsule approaching
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);
                            drawStars(ctx, w, h, t, 1);

                            // Moon growing to fill view
                            var grow = sm(0, 1, p);
                            var moonR = 20 + grow * Math.max(w, h) * 0.5;
                            var moonX = cx + (1 - grow) * w * 0.15;
                            var moonY = cy + grow * h * 0.15;
                            drawMoon(ctx, moonX, moonY, moonR);

                            // Earth small in the distance
                            var earthR2 = Math.max(5, 12 * (1 - grow * 0.3));
                            drawEarth(ctx, w * 0.15, h * 0.2, earthR2);

                            // Capsule
                            if (grow < 0.7) {
                                var capScale = 1.0 - grow * 0.5;
                                drawCapsule(ctx, cx - grow * 30, cy - grow * 20, capScale);
                            }

                            // Lunar surface detail as we get close
                            if (grow > 0.6) {
                                var detail = (grow - 0.6) / 0.4;
                                ctx.save();
                                ctx.beginPath();
                                ctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
                                ctx.clip();
                                for (var i = 0; i < 12; i++) {
                                    var crX = moonX + Math.sin(i * 5.3 + 0.7) * moonR * 0.6;
                                    var crY = moonY + Math.cos(i * 4.1 + 1.3) * moonR * 0.5;
                                    var crR = moonR * (0.02 + Math.sin(i * 2.9) * 0.01);
                                    ctx.beginPath();
                                    ctx.arc(crX, crY, crR, 0, Math.PI * 2);
                                    ctx.strokeStyle = 'rgba(100, 96, 88, ' + (detail * 0.06) + ')';
                                    ctx.lineWidth = 1;
                                    ctx.stroke();
                                }
                                ctx.restore();
                            }
                        }

                        // ==================== DARK SIDE ====================
                        else if (ph.name === 'darkside') {
                            // Orbiting around the dark side of the moon
                            ctx.fillStyle = '#010103';
                            ctx.fillRect(0, 0, w, h);

                            // Fewer stars  dark, lonely
                            for (var i = 0; i < 60; i++) {
                                var sx = (Math.sin(i * 7.3 + 0.5) * 0.5 + 0.5) * w;
                                var sy = (Math.sin(i * 4.1 + 2.7) * 0.5 + 0.5) * h;
                                ctx.beginPath();
                                ctx.arc(sx, sy, 0.3, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(200, 210, 230, 0.08)';
                                ctx.fill();
                            }

                            // Moon limb  huge curved edge, mostly dark
                            var limbProgress = p; // 01 as we go around
                            var limbX = w * (0.7 - limbProgress * 0.4);
                            // Moon edge as a massive arc taking up most of the screen
                            ctx.beginPath();
                            ctx.arc(limbX + w * 0.6, cy, w * 0.6, 0, Math.PI * 2);
                            ctx.fillStyle = '#080808';
                            ctx.fill();

                            // Faint terminator glow (sunlight just around the edge)
                            var termGlow = Math.sin(limbProgress * Math.PI) * 0.08;
                            var tG = ctx.createLinearGradient(limbX - 5, 0, limbX + 20, 0);
                            tG.addColorStop(0, 'rgba(200, 195, 180, 0)');
                            tG.addColorStop(0.4, 'rgba(200, 195, 180, ' + termGlow + ')');
                            tG.addColorStop(1, 'rgba(200, 195, 180, 0)');
                            ctx.fillStyle = tG;
                            ctx.fillRect(limbX - 5, 0, 25, h);

                            // Earth rise on the far side (appears mid-transit)
                            if (p > 0.3 && p < 0.8) {
                                var earthVis = Math.sin((p - 0.3) / 0.5 * Math.PI);
                                var erX = w * 0.1;
                                var erY = h * (0.4 - (p - 0.3) * 0.2);
                                drawEarth(ctx, erX, erY, 10 + earthVis * 8);
                            }

                            // Capsule silhouette
                            drawCapsule(ctx, w * 0.25, cy + Math.sin(t * 0.3) * 10, 0.8);

                            // Emerge back into light at end
                            if (p > 0.85) {
                                var emerge = (p - 0.85) / 0.15;
                                ctx.fillStyle = 'rgba(200, 195, 180, ' + (emerge * 0.05) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }

                        // ==================== RETURN ====================
                        else if (ph.name === 'return') {
                            // Heading back to Earth, moon shrinking, Earth growing
                            ctx.fillStyle = '#020206';
                            ctx.fillRect(0, 0, w, h);
                            drawStars(ctx, w, h, t, 1);

                            // Moon shrinking behind
                            var moonShrink = 1 - p;
                            var moonR2 = Math.max(5, 30 * moonShrink);
                            drawMoon(ctx, w * (0.75 + p * 0.1), h * (0.25 - p * 0.05), moonR2);

                            // Earth growing ahead
                            var earthGrow = sm(0, 1, p);
                            var earthR3 = 8 + earthGrow * 50;
                            drawEarth(ctx, w * (0.35 - earthGrow * 0.05), h * (0.6 + earthGrow * 0.05), earthR3);

                            // Capsule
                            drawCapsule(ctx, cx, cy, 1.0);
                            ctx.fillStyle = 'rgba(200, 205, 210, 0.15)';
                            ctx.fillRect(cx - 4, cy + 3, 8, 12);

                            // Correction burn
                            if (p > 0.3 && p < 0.6) {
                                var burn = Math.sin((p - 0.3) / 0.3 * Math.PI);
                                drawExhaust(ctx, cx, cy + 15, 0.3, burn * 0.4, t);
                            }
                        }

                        // ==================== REENTRY ====================
                        else if (ph.name === 'reentry') {
                            // Heat shield, plasma, sky brightening
                            var heat = p < 0.6 ? sm(0, 0.4, p) : sm(0.4, 0.8, 1 - p);
                            var skyBright = sm(0.3, 1, p);

                            var skyG = ctx.createLinearGradient(0, 0, 0, h);
                            skyG.addColorStop(0, 'rgb(' + Math.round(2 + skyBright * 40) + ',' + Math.round(2 + skyBright * 60) + ',' + Math.round(6 + skyBright * 120) + ')');
                            skyG.addColorStop(1, 'rgb(' + Math.round(5 + skyBright * 50) + ',' + Math.round(5 + skyBright * 80) + ',' + Math.round(10 + skyBright * 140) + ')');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Fading stars
                            if (skyBright < 0.5) {
                                drawStars(ctx, w, h, t, 1 - skyBright * 2);
                            }

                            // Capsule (heat shield facing down)
                            drawCapsule(ctx, cx, cy - 10, 1.3);

                            // Plasma / heat effects
                            if (heat > 0.05) {
                                // Orange-red heat envelope
                                var hG = ctx.createRadialGradient(cx, cy + 15, 0, cx, cy + 15, 80);
                                hG.addColorStop(0, 'rgba(255, 180, 60, ' + (heat * 0.2) + ')');
                                hG.addColorStop(0.3, 'rgba(255, 100, 20, ' + (heat * 0.12) + ')');
                                hG.addColorStop(0.7, 'rgba(255, 50, 10, ' + (heat * 0.05) + ')');
                                hG.addColorStop(1, 'rgba(200, 30, 5, 0)');
                                ctx.beginPath();
                                ctx.arc(cx, cy + 15, 80, 0, Math.PI * 2);
                                ctx.fillStyle = hG;
                                ctx.fill();

                                // Plasma streaks
                                for (var i = 0; i < 10; i++) {
                                    var px = cx + (Math.sin(i * 4.3 + t * 2) - 0.5) * 30;
                                    var py = cy + 10;
                                    ctx.beginPath();
                                    ctx.moveTo(px, py);
                                    ctx.lineTo(px + Math.sin(i * 2.7 + t) * 8, py + 20 + Math.sin(i * 3.1) * 10);
                                    ctx.strokeStyle = 'rgba(255, 160, 60, ' + (heat * 0.06) + ')';
                                    ctx.lineWidth = 1.5;
                                    ctx.stroke();
                                }
                            }

                            // Glowing edges
                            if (heat > 0.1) {
                                ctx.beginPath();
                                ctx.ellipse(cx, cy + 8, 12, 5, 0, 0, Math.PI);
                                ctx.strokeStyle = 'rgba(255, 200, 100, ' + (heat * 0.15) + ')';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                            }
                        }

                        // ==================== SPLASHDOWN ====================
                        else if (ph.name === 'splashdown') {
                            // Parachutes deploy, then ocean landing
                            var chuteOpen = sm(0, 0.25, p);
                            var descend = sm(0, 0.7, p);
                            var splash = sm(0.7, 0.85, p);
                            var settle = sm(0.85, 1, p);

                            // Blue sky
                            var skyG = ctx.createLinearGradient(0, 0, 0, h * 0.5);
                            skyG.addColorStop(0, '#4088c0');
                            skyG.addColorStop(1, '#60a8d8');
                            ctx.fillStyle = skyG;
                            ctx.fillRect(0, 0, w, h);

                            // Ocean
                            var oceanY = h * (0.55 + descend * 0.05);
                            var oG = ctx.createLinearGradient(0, oceanY, 0, h);
                            oG.addColorStop(0, '#1a5878');
                            oG.addColorStop(1, '#0a3050');
                            ctx.fillStyle = oG;
                            ctx.fillRect(0, oceanY, w, h - oceanY);

                            // Waves
                            for (var i = 0; i < 5; i++) {
                                ctx.beginPath();
                                for (var x = 0; x <= w; x += 4) {
                                    var wy = oceanY + i * 6 + Math.sin(x * 0.008 + t * (0.5 + i * 0.15) + i * 1.5) * 4;
                                    if (x === 0) ctx.moveTo(x, wy); else ctx.lineTo(x, wy);
                                }
                                ctx.strokeStyle = 'rgba(100, 180, 210, 0.04)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }

                            // Capsule position descending
                            var capY = h * 0.3 + descend * (oceanY - h * 0.32);
                            if (splash > 0) capY = oceanY - 5;

                            // Parachutes (3 main chutes)
                            if (chuteOpen > 0 && splash < 0.5) {
                                var chuteFade = splash > 0 ? 1 - splash * 2 : 1;
                                for (var i = -1; i <= 1; i++) {
                                    var chuteX = cx + i * 35 * chuteOpen;
                                    var chuteTopY = capY - 70 * chuteOpen;
                                    var chuteW = 20 * chuteOpen;
                                    // Canopy
                                    ctx.beginPath();
                                    ctx.ellipse(chuteX, chuteTopY, chuteW, chuteW * 0.5, 0, Math.PI, 0);
                                    ctx.fillStyle = 'rgba(220, 100, 40, ' + (0.07 * chuteFade) + ')';
                                    ctx.fill();
                                    ctx.strokeStyle = 'rgba(200, 80, 30, ' + (0.05 * chuteFade) + ')';
                                    ctx.lineWidth = 0.5;
                                    ctx.stroke();
                                    // Shroud lines
                                    ctx.beginPath();
                                    ctx.moveTo(chuteX - chuteW * 0.8, chuteTopY);
                                    ctx.lineTo(cx, capY - 10);
                                    ctx.moveTo(chuteX + chuteW * 0.8, chuteTopY);
                                    ctx.lineTo(cx, capY - 10);
                                    ctx.strokeStyle = 'rgba(180, 180, 170, ' + (0.03 * chuteFade) + ')';
                                    ctx.lineWidth = 0.5;
                                    ctx.stroke();
                                }
                            }

                            // Capsule
                            drawCapsule(ctx, cx, capY, 1.2);

                            // Splash effect
                            if (splash > 0 && splash < 0.8) {
                                var splashInt = splash < 0.4 ? splash / 0.4 : 1 - (splash - 0.4) / 0.4;
                                for (var i = 0; i < 10; i++) {
                                    var spx = cx + (Math.sin(i * 3.7 + 0.5) - 0.5) * 60 * splashInt;
                                    var spy = oceanY - Math.abs(Math.sin(i * 2.3 + 0.7)) * 40 * splashInt;
                                    ctx.beginPath();
                                    ctx.arc(spx, spy, 2 * splashInt, 0, Math.PI * 2);
                                    ctx.fillStyle = 'rgba(180, 220, 240, ' + (splashInt * 0.1) + ')';
                                    ctx.fill();
                                }
                                // White water ring
                                ctx.beginPath();
                                ctx.ellipse(cx, oceanY, 30 * splashInt, 6 * splashInt, 0, 0, Math.PI * 2);
                                ctx.strokeStyle = 'rgba(220, 240, 250, ' + (splashInt * 0.06) + ')';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                            }

                            // Bobbing on waves after landing
                            if (settle > 0) {
                                var bob = Math.sin(t * 1.5) * 3 * settle;
                                drawCapsule(ctx, cx, oceanY - 3 + bob, 1.2);
                            }

                            // Fade to black for loop
                            if (p > 0.88) {
                                ctx.fillStyle = 'rgba(0, 0, 0, ' + ((p - 0.88) / 0.12 * 0.7) + ')';
                                ctx.fillRect(0, 0, w, h);
                            }
                        }
                    }
                };
            })();

            // Default/placeholder theme configuration
            function getDefaultThemeConfig() {
                return {
                    targetCount: 0,
                    // Create a single particle with custom properties
                    spawn: function (w, h) {
                        return { x: Math.random() * w, y: Math.random() * h, vx: 0, vy: 0 };
                    },
                    // Update a particle each frame; return false to recycle it
                    update: function (p, dt, w, h, state) {
                        return true;
                    },
                    // Draw a single particle
                    draw: function (p, ctx, state) {},
                    // Draw the scene background/effects (called before particles)
                    drawBackground: function (ctx, w, h, state) {
                        ctx.fillStyle = '#0a0a0f';
                        ctx.fillRect(0, 0, w, h);
                    },
                    // Draw foreground effects (called after particles)
                    drawForeground: function (ctx, w, h, state) {},
                    // Optional activation callback
                    onActivate: null
                };
            }

            // Get the active theme config, falling back to defaults
            function getThemeConfig(themeName) {
                const config = themes[themeName] || {};
                const defaults = getDefaultThemeConfig();
                return {
                    targetCount: config.targetCount !== undefined ? config.targetCount : defaults.targetCount,
                    spawn: config.spawn || defaults.spawn,
                    update: config.update || defaults.update,
                    draw: config.draw || defaults.draw,
                    drawBackground: config.drawBackground || defaults.drawBackground,
                    drawForeground: config.drawForeground || defaults.drawForeground,
                    onActivate: config.onActivate || null
                };
            }

            // --- Particle system ---

            // Cached theme config - rebuilt only on theme switch
            let cachedThemeConfig = null;

            // Spawn particles up to the theme's target count
            function spawnParticles() {
                const config = cachedThemeConfig;
                const target = config.targetCount;
                const w = canvas.width;
                const h = canvas.height;
                const particles = [];
                for (let i = 0; i < target; i++) {
                    particles.push(config.spawn(w, h));
                }
                return particles;
            }

            // Update all particles; recycle any that are off-screen or flagged
            function updateParticles(dt) {
                const config = cachedThemeConfig;
                const w = canvas.width;
                const h = canvas.height;
                const particles = state.particles;

                for (let i = 0; i < particles.length; i++) {
                    const alive = config.update(particles[i], dt, w, h, state);
                    if (!alive) {
                        // Recycle: replace with a fresh particle
                        particles[i] = config.spawn(w, h);
                    }
                }

                // Maintain target count (add if below, trim if above)
                const target = config.targetCount;
                while (particles.length < target) {
                    particles.push(config.spawn(w, h));
                }
                if (particles.length > target) {
                    particles.length = target;
                }
            }

            // Draw all particles
            function drawParticles() {
                const config = cachedThemeConfig;
                for (let i = 0; i < state.particles.length; i++) {
                    config.draw(state.particles[i], ctx, state);
                }
            }

            // Re-initialise particles for a new theme
            function reinitialiseParticles(themeName, preserveTime) {
                state.currentTheme = themeName;
                if (!preserveTime) state.timeElapsed = 0;
                cachedThemeConfig = getThemeConfig(themeName);
                // Reset stale timers for themes with periodic effects
                if (cachedThemeConfig.onActivate) cachedThemeConfig.onActivate();
                state.particles = spawnParticles();
            }

            // --- Animation loop ---
            let lastTimestamp = 0;

            function animate(timestamp) {
                requestAnimationFrame(animate);

                // Delta time in seconds, capped to avoid jumps
                const dt = lastTimestamp ? Math.min((timestamp - lastTimestamp) / 1000, MAX_DT) : FALLBACK_DT;
                lastTimestamp = timestamp;

                state.timeElapsed += dt;

                if (state.autoCycle) {
                    state.cycleTimer += dt;
                    if (state.cycleTimer >= state.cycleInterval) {
                        state.cycleTimer = 0;
                        const currentIdx = THEME_NAMES.indexOf(state.currentTheme);
                        const nextIdx = (currentIdx + 1) % THEME_NAMES.length;
                        switchTheme(THEME_NAMES[nextIdx]);
                    }
                }

                const w = canvas.width;
                const h = canvas.height;
                const config = cachedThemeConfig;

                // Draw background
                config.drawBackground(ctx, w, h, state);

                // Update and draw particles
                updateParticles(dt);
                drawParticles();

                // Draw foreground effects
                config.drawForeground(ctx, w, h, state, dt);

                // Cross-fade transition overlay (old frame fading out)
                if (transition.active) {
                    transition.progress += dt / transition.duration;
                    if (transition.progress >= 1) {
                        transition.active = false;
                        transition.snapshotCanvas = null;
                    } else if (transition.snapshotCanvas) {
                        ctx.save();
                        ctx.globalAlpha = 1 - transition.progress;
                        ctx.drawImage(transition.snapshotCanvas, 0, 0);
                        ctx.restore();
                    }
                }

                // Share a single Date object per frame
                const frameDate = new Date();

                // Draw Sun & Moon clock on the main canvas
                drawSunMoonClock(ctx, w, h, frameDate);

                // Update clock overlays
                updateDigitalClock(frameDate);
                updateAnalogueClock(frameDate);
            }

            // --- Handle window resize: consolidated single handler ---
            window.addEventListener('resize', function () {
                resizeCanvas();
                transition.active = false;
                transition.snapshotCanvas = null;
                reinitialiseParticles(state.currentTheme, true);
            });

            // --- localStorage persistence ---
            function savePreferences() {
                try {
                    localStorage.setItem('calmVisualiser_theme', state.currentTheme);
                    localStorage.setItem('calmVisualiser_clockType', state.clockType);
                    localStorage.setItem('calmVisualiser_clockOpacity', String(state.clockOpacity));
                    localStorage.setItem('calmVisualiser_autoCycle', state.autoCycle ? 'true' : 'false');
                    localStorage.setItem('calmVisualiser_cycleInterval', String(state.cycleInterval));
                } catch (e) {
                    // localStorage may be unavailable
                }
            }

            function loadPreferences() {
                try {
                    const savedTheme = localStorage.getItem('calmVisualiser_theme');
                    const savedClockType = localStorage.getItem('calmVisualiser_clockType');
                    const savedOpacity = localStorage.getItem('calmVisualiser_clockOpacity');

                    if (savedTheme && themes[savedTheme]) {
                        themeBtns.forEach(function (b) { b.classList.remove('active'); });
                        const targetBtn = Array.from(themeBtns).find(function (b) { return b.dataset.theme === savedTheme; });
                        if (targetBtn) targetBtn.classList.add('active');
                        sceneTitle.textContent = savedTheme;
                        state.currentTheme = savedTheme;
                    }

                    if (savedClockType) {
                        clockTypeBtns.forEach(function (b) { b.classList.remove('active'); });
                        const targetBtn = Array.from(clockTypeBtns).find(function (b) { return b.dataset.clock === savedClockType; });
                        if (targetBtn) targetBtn.classList.add('active');
                        state.clockType = savedClockType;
                    }

                    if (savedOpacity !== null) {
                        const val = parseFloat(savedOpacity);
                        if (!isNaN(val)) {
                            state.clockOpacity = val;
                            opacitySlider.value = String(Math.round(val * 100));
                            opacityValue.textContent = Math.round(val * 100) + '%';
                        }
                    }

                    const savedAutoCycle = localStorage.getItem('calmVisualiser_autoCycle');
                    const savedCycleInterval = localStorage.getItem('calmVisualiser_cycleInterval');

                    if (savedAutoCycle === 'true') {
                        state.autoCycle = true;
                        btnAutoCycle.textContent = 'On';
                        btnAutoCycle.classList.add('active');
                        cycleIntervalRow.style.display = '';
                    }

                    if (savedCycleInterval !== null) {
                        const interval = parseInt(savedCycleInterval, 10);
                        if (!isNaN(interval) && interval >= 10 && interval <= 300) {
                            state.cycleInterval = interval;
                            cycleIntervalSlider.value = String(interval);
                            cycleIntervalValue.textContent = interval + 's';
                        }
                    }
                } catch (e) {
                    // localStorage may be unavailable
                }
            }

            // --- Initialise and start ---
            loadPreferences();
            reinitialiseParticles(state.currentTheme);
            requestAnimationFrame(animate);
        })();
    </script>
</body>
</html>
